From 777975d6a8172011ee45555deee67d29e192a417 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 24 Sep 2018 18:57:46 +0200
Subject: [PATCH 1/1] efi_loader: typedef struct efi_object *efi_handle_t

All our handles point to a struct efi_object. So let's define the
efi_handle_t accordingly. This helps us to discover coding errors much
more easily. This becomes evident by the corrections to the usage of
handles in this patch.

Rename variable image_handle to image_obj where applicable.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                              | 28 +++++++++++-----------
 include/efi.h                              |  2 +-
 include/efi_api.h                          |  8 +++----
 lib/efi/efi.c                              |  2 +-
 lib/efi_loader/efi_boottime.c              | 18 +++++++-------
 lib/efi_selftest/efi_selftest_devicepath.c |  2 +-
 6 files changed, 30 insertions(+), 30 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 9c51a2cbd1..b3d507a0d8 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -343,7 +343,7 @@ static efi_status_t do_bootefi_exec(void *efi,
 	efi_handle_t mem_handle = NULL;
 	struct efi_device_path *memdp = NULL;
 	efi_status_t ret;
-	struct efi_loaded_image_obj *image_handle = NULL;
+	struct efi_loaded_image_obj *image_obj = NULL;
 	struct efi_loaded_image *loaded_image_info = NULL;
 
 	EFIAPI efi_status_t (*entry)(efi_handle_t image_handle,
@@ -374,7 +374,7 @@ static efi_status_t do_bootefi_exec(void *efi,
 		assert(device_path && image_path);
 	}
 
-	ret = efi_setup_loaded_image(device_path, image_path, &image_handle,
+	ret = efi_setup_loaded_image(device_path, image_path, &image_obj,
 				     &loaded_image_info);
 	if (ret != EFI_SUCCESS)
 		goto exit;
@@ -388,7 +388,7 @@ static efi_status_t do_bootefi_exec(void *efi,
 	/* Transfer environment variable bootargs as load options */
 	set_load_options(loaded_image_info, "bootargs");
 	/* Load the EFI payload */
-	entry = efi_load_pe(image_handle, efi, loaded_image_info);
+	entry = efi_load_pe(image_obj, efi, loaded_image_info);
 	if (!entry) {
 		ret = EFI_LOAD_ERROR;
 		goto exit;
@@ -409,8 +409,8 @@ static efi_status_t do_bootefi_exec(void *efi,
 	/* Call our payload! */
 	debug("%s:%d Jumping to 0x%lx\n", __func__, __LINE__, (long)entry);
 
-	if (setjmp(&image_handle->exit_jmp)) {
-		ret = image_handle->exit_status;
+	if (setjmp(&image_obj->exit_jmp)) {
+		ret = image_obj->exit_status;
 		goto exit;
 	}
 
@@ -422,7 +422,7 @@ static efi_status_t do_bootefi_exec(void *efi,
 
 		/* Move into EL2 and keep running there */
 		armv8_switch_to_el2((ulong)entry,
-				    (ulong)image_handle,
+				    (ulong)&image_obj->parent,
 				    (ulong)&systab, 0, (ulong)efi_run_in_el2,
 				    ES_TO_AARCH64);
 
@@ -439,7 +439,7 @@ static efi_status_t do_bootefi_exec(void *efi,
 		secure_ram_addr(_do_nonsec_entry)(
 					efi_run_in_hyp,
 					(uintptr_t)entry,
-					(uintptr_t)image_handle,
+					(uintptr_t)&image_obj->parent,
 					(uintptr_t)&systab);
 
 		/* Should never reach here, efi exits with longjmp */
@@ -447,12 +447,12 @@ static efi_status_t do_bootefi_exec(void *efi,
 	}
 #endif
 
-	ret = efi_do_enter(image_handle, &systab, entry);
+	ret = efi_do_enter(&image_obj->parent, &systab, entry);
 
 exit:
 	/* image has returned, loaded-image obj goes *poof*: */
-	if (image_handle)
-		efi_delete_handle(&image_handle->parent);
+	if (image_obj)
+		efi_delete_handle(&image_obj->parent);
 	if (mem_handle)
 		efi_delete_handle(mem_handle);
 
@@ -537,7 +537,7 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 #endif
 #ifdef CONFIG_CMD_BOOTEFI_SELFTEST
 	if (!strcmp(argv[1], "selftest")) {
-		struct efi_loaded_image_obj *image_handle;
+		struct efi_loaded_image_obj *image_obj;
 		struct efi_loaded_image *loaded_image_info;
 
 		/* Construct a dummy device path. */
@@ -547,7 +547,7 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		bootefi_image_path = efi_dp_from_file(NULL, 0, "\\selftest");
 
 		r = efi_setup_loaded_image(bootefi_device_path,
-					   bootefi_image_path, &image_handle,
+					   bootefi_image_path, &image_obj,
 					   &loaded_image_info);
 		if (r != EFI_SUCCESS)
 			return CMD_RET_FAILURE;
@@ -561,10 +561,10 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		/* Transfer environment variable efi_selftest as load options */
 		set_load_options(loaded_image_info, "efi_selftest");
 		/* Execute the test */
-		r = efi_selftest(image_handle, &systab);
+		r = efi_selftest(&image_obj->parent, &systab);
 		efi_restore_gd();
 		free(loaded_image_info->load_options);
-		efi_delete_handle(&image_handle->parent);
+		efi_delete_handle(&image_obj->parent);
 		return r != EFI_SUCCESS;
 	} else
 #endif
diff --git a/include/efi.h b/include/efi.h
index b1deb609b4..b5e2c64f38 100644
--- a/include/efi.h
+++ b/include/efi.h
@@ -96,7 +96,7 @@ typedef struct {
 typedef unsigned long efi_status_t;
 typedef u64 efi_physical_addr_t;
 typedef u64 efi_virtual_addr_t;
-typedef void *efi_handle_t;
+typedef struct efi_object *efi_handle_t;
 
 #define EFI_GUID(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \
 	{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, \
diff --git a/include/efi_api.h b/include/efi_api.h
index c42df6900a..e6566bb358 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -86,10 +86,10 @@ struct efi_boot_services {
 	efi_status_t (EFIAPI *check_event)(struct efi_event *event);
 #define EFI_NATIVE_INTERFACE	0x00000000
 	efi_status_t (EFIAPI *install_protocol_interface)(
-			void **handle, const efi_guid_t *protocol,
+			efi_handle_t *handle, const efi_guid_t *protocol,
 			int protocol_interface_type, void *protocol_interface);
 	efi_status_t (EFIAPI *reinstall_protocol_interface)(
-			void *handle, const efi_guid_t *protocol,
+			efi_handle_t handle, const efi_guid_t *protocol,
 			void *old_interface, void *new_interface);
 	efi_status_t (EFIAPI *uninstall_protocol_interface)(
 			efi_handle_t handle, const efi_guid_t *protocol,
@@ -165,9 +165,9 @@ struct efi_boot_services {
 	efi_status_t (EFIAPI *locate_protocol)(const efi_guid_t *protocol,
 			void *registration, void **protocol_interface);
 	efi_status_t (EFIAPI *install_multiple_protocol_interfaces)(
-			void **handle, ...);
+			efi_handle_t *handle, ...);
 	efi_status_t (EFIAPI *uninstall_multiple_protocol_interfaces)(
-			void *handle, ...);
+			efi_handle_t handle, ...);
 	efi_status_t (EFIAPI *calculate_crc32)(const void *data,
 					       efi_uintn_t data_size,
 					       u32 *crc32);
diff --git a/lib/efi/efi.c b/lib/efi/efi.c
index c6639f96cc..2c6a50824f 100644
--- a/lib/efi/efi.c
+++ b/lib/efi/efi.c
@@ -69,7 +69,7 @@ int efi_init(struct efi_priv *priv, const char *banner, efi_handle_t image,
 	efi_putc(priv, ' ');
 
 	ret = boot->open_protocol(priv->parent_image, &loaded_image_guid,
-				  (void **)&loaded_image, &priv->parent_image,
+				  (void **)&loaded_image, priv->parent_image,
 				  NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
 	if (ret) {
 		efi_puts(priv, "Failed to get loaded image protocol\n");
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 8e3c7456e1..bc6ad84495 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -1019,7 +1019,7 @@ efi_status_t efi_add_protocol(const efi_handle_t handle,
  * Return: status code
  */
 static efi_status_t EFIAPI efi_install_protocol_interface(
-			void **handle, const efi_guid_t *protocol,
+			efi_handle_t *handle, const efi_guid_t *protocol,
 			int protocol_interface_type, void *protocol_interface)
 {
 	efi_status_t r;
@@ -2279,8 +2279,8 @@ out:
  *
  * Return: status code
  */
-static efi_status_t EFIAPI efi_install_multiple_protocol_interfaces(
-			void **handle, ...)
+static efi_status_t EFIAPI efi_install_multiple_protocol_interfaces
+				(efi_handle_t *handle, ...)
 {
 	EFI_ENTRY("%p", handle);
 
@@ -2316,7 +2316,7 @@ static efi_status_t EFIAPI efi_install_multiple_protocol_interfaces(
 	for (; i; --i) {
 		protocol = efi_va_arg(argptr, efi_guid_t*);
 		protocol_interface = efi_va_arg(argptr, void*);
-		EFI_CALL(efi_uninstall_protocol_interface(handle, protocol,
+		EFI_CALL(efi_uninstall_protocol_interface(*handle, protocol,
 							  protocol_interface));
 	}
 	efi_va_end(argptr);
@@ -2339,7 +2339,7 @@ static efi_status_t EFIAPI efi_install_multiple_protocol_interfaces(
  * Return: status code
  */
 static efi_status_t EFIAPI efi_uninstall_multiple_protocol_interfaces(
-			void *handle, ...)
+			efi_handle_t handle, ...)
 {
 	EFI_ENTRY("%p", handle);
 
@@ -2554,10 +2554,10 @@ out:
  *
  * Return: status code
  */
-static efi_status_t EFIAPI efi_open_protocol(
-			void *handle, const efi_guid_t *protocol,
-			void **protocol_interface, void *agent_handle,
-			void *controller_handle, uint32_t attributes)
+static efi_status_t EFIAPI efi_open_protocol
+			(efi_handle_t handle, const efi_guid_t *protocol,
+			 void **protocol_interface, efi_handle_t agent_handle,
+			 efi_handle_t controller_handle, uint32_t attributes)
 {
 	struct efi_handler *handler;
 	efi_status_t r = EFI_INVALID_PARAMETER;
diff --git a/lib/efi_selftest/efi_selftest_devicepath.c b/lib/efi_selftest/efi_selftest_devicepath.c
index adcf531e90..105ce2c92b 100644
--- a/lib/efi_selftest/efi_selftest_devicepath.c
+++ b/lib/efi_selftest/efi_selftest_devicepath.c
@@ -257,7 +257,7 @@ static int teardown(void)
 static int execute(void)
 {
 	struct efi_device_path *remaining_dp;
-	void *handle;
+	efi_handle_t handle;
 	/*
 	 * This device path node ends with the letter 't' of 'u-boot'.
 	 * The following '.bin' does not belong to the node but is
-- 
2.19.0

