From 7f3816e9e15400713f3c4a0f67dc5cee8f65d9f8 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 29 Jan 2018 18:55:00 +0100
Subject: [PATCH 1/1] efi_loader: clean up efi_exit

Currently we require the handle of a loaded image to be the address of the
loaded image protocol.

In case an application passes the wrong handle this will lead to a long
jump with an invalid address in efi_exit() or an illegal memory access in
efi_start_image().

With the patch we completely separate the handle and the loaded image
protocol.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                 | 25 ++++++++-------
 include/efi_loader.h          |  2 +-
 lib/efi_loader/efi_boottime.c | 72 ++++++++++++++++++++++++-------------------
 3 files changed, 56 insertions(+), 43 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 4233d36b72..44aa302ecd 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -159,7 +159,7 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 				    struct efi_device_path *image_path)
 {
 	struct efi_loaded_image loaded_image_info = {};
-	struct efi_object loaded_image_info_obj = {};
+	efi_handle_t handle;
 	struct efi_device_path *memdp = NULL;
 	ulong ret;
 
@@ -187,7 +187,11 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 	if (!efi_obj_list_initalized)
 		efi_init_obj_list();
 
-	efi_setup_loaded_image(&loaded_image_info, &loaded_image_info_obj,
+	ret = efi_create_handle(&handle);
+	if (ret != EFI_SUCCESS)
+		return EFI_OUT_OF_RESOURCES;
+
+	efi_setup_loaded_image(&loaded_image_info, handle,
 			       device_path, image_path);
 
 	/*
@@ -268,12 +272,9 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 	}
 #endif
 
-	ret = efi_do_enter(loaded_image_info_obj.handle, &systab, entry);
+	ret = efi_do_enter(handle, &systab, entry);
 
 exit:
-	/* image has returned, loaded-image obj goes *poof*: */
-	list_del(&loaded_image_info_obj.link);
-
 	return ret;
 }
 
@@ -332,7 +333,7 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 #ifdef CONFIG_CMD_BOOTEFI_SELFTEST
 	if (!strcmp(argv[1], "selftest")) {
 		struct efi_loaded_image loaded_image_info = {};
-		struct efi_object loaded_image_info_obj = {};
+		efi_handle_t handle;
 
 		/* Construct a dummy device path. */
 		bootefi_device_path = efi_dp_from_mem(EFI_RESERVED_MEMORY_TYPE,
@@ -340,8 +341,11 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 						      (uintptr_t)&efi_selftest);
 		bootefi_image_path = efi_dp_from_file(NULL, 0, "\\selftest");
 
-		efi_setup_loaded_image(&loaded_image_info,
-				       &loaded_image_info_obj,
+		r = efi_create_handle(&handle);
+		if (r != EFI_SUCCESS)
+			return CMD_RET_FAILURE;
+
+		efi_setup_loaded_image(&loaded_image_info, handle,
 				       bootefi_device_path, bootefi_image_path);
 		/*
 		 * gd lives in a fixed register which may get clobbered while we
@@ -355,10 +359,9 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		/* Transfer environment variable efi_selftest as load options */
 		set_load_options(&loaded_image_info, "efi_selftest");
 		/* Execute the test */
-		r = efi_selftest(loaded_image_info_obj.handle, &systab);
+		r = efi_selftest(handle, &systab);
 		efi_restore_gd();
 		free(loaded_image_info.load_options);
-		list_del(&loaded_image_info_obj.link);
 		return r != EFI_SUCCESS;
 	} else
 #endif
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 21c03c5c28..d51ecdc818 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -279,7 +279,7 @@ int efi_memory_init(void);
 efi_status_t efi_install_configuration_table(const efi_guid_t *guid, void *table);
 /* Sets up a loaded image */
 efi_status_t efi_setup_loaded_image(
-			struct efi_loaded_image *info, struct efi_object *obj,
+			struct efi_loaded_image *info, efi_handle_t handle,
 			struct efi_device_path *device_path,
 			struct efi_device_path *file_path);
 efi_status_t efi_load_image_from_path(struct efi_device_path *file_path,
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 599f0c597d..7fb5f7b832 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -1355,17 +1355,12 @@ static efi_status_t EFIAPI efi_install_configuration_table_ext(efi_guid_t *guid,
  * @return		status code
  */
 efi_status_t efi_setup_loaded_image(
-			struct efi_loaded_image *info, struct efi_object *obj,
+			struct efi_loaded_image *info, efi_handle_t handle,
 			struct efi_device_path *device_path,
 			struct efi_device_path *file_path)
 {
 	efi_status_t ret;
 
-	/* Add internal object to object list */
-	efi_add_handle(obj);
-	/* efi_exit() assumes that the handle points to the info */
-	obj->handle = info;
-
 	info->file_path = file_path;
 
 	if (device_path) {
@@ -1374,7 +1369,7 @@ efi_status_t efi_setup_loaded_image(
 		 * When asking for the device path interface, return
 		 * bootefi_device_path
 		 */
-		ret = efi_add_protocol(obj->handle, &efi_guid_device_path,
+		ret = efi_add_protocol(handle, &efi_guid_device_path,
 				       device_path);
 		if (ret != EFI_SUCCESS)
 			goto failure;
@@ -1384,12 +1379,11 @@ efi_status_t efi_setup_loaded_image(
 	 * When asking for the loaded_image interface, just
 	 * return handle which points to loaded_image_info
 	 */
-	ret = efi_add_protocol(obj->handle, &efi_guid_loaded_image, info);
+	ret = efi_add_protocol(handle, &efi_guid_loaded_image, info);
 	if (ret != EFI_SUCCESS)
 		goto failure;
 
-	ret = efi_add_protocol(obj->handle,
-			       &efi_guid_device_path_to_text_protocol,
+	ret = efi_add_protocol(handle, &efi_guid_device_path_to_text_protocol,
 			       (void *)&efi_device_path_to_text);
 	if (ret != EFI_SUCCESS)
 		goto failure;
@@ -1472,14 +1466,21 @@ static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 					  efi_handle_t *image_handle)
 {
 	struct efi_loaded_image *info;
-	struct efi_object *obj;
+	efi_handle_t handle;
 	efi_status_t ret;
 
 	EFI_ENTRY("%d, %p, %pD, %p, %ld, %p", boot_policy, parent_image,
 		  file_path, source_buffer, source_size, image_handle);
 
+	ret = efi_create_handle(&handle);
+	if (ret != EFI_SUCCESS)
+		return EFI_EXIT(ret);
+
 	info = calloc(1, sizeof(*info));
-	obj = calloc(1, sizeof(*obj));
+	if (!info) {
+		ret = EFI_OUT_OF_RESOURCES;
+		goto failure2;
+	}
 
 	if (!source_buffer) {
 		struct efi_device_path *dp, *fp;
@@ -1492,14 +1493,14 @@ static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 		 * file parts:
 		 */
 		efi_dp_split_file_path(file_path, &dp, &fp);
-		ret = efi_setup_loaded_image(info, obj, dp, fp);
+		ret = efi_setup_loaded_image(info, handle, dp, fp);
 		if (ret != EFI_SUCCESS)
 			goto failure;
 	} else {
 		/* In this case, file_path is the "device" path, ie.
 		 * something like a HARDWARE_DEVICE:MEMORY_MAPPED
 		 */
-		ret = efi_setup_loaded_image(info, obj, file_path, NULL);
+		ret = efi_setup_loaded_image(info, handle, file_path, NULL);
 		if (ret != EFI_SUCCESS)
 			goto failure;
 	}
@@ -1510,11 +1511,12 @@ static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 	}
 	info->system_table = &systab;
 	info->parent_handle = parent_image;
-	*image_handle = obj->handle;
+	*image_handle = handle;
 	return EFI_EXIT(EFI_SUCCESS);
 failure:
 	free(info);
-	efi_delete_handle(obj);
+failure2:
+	efi_delete_handle(handle);
 	return EFI_EXIT(ret);
 }
 
@@ -1536,15 +1538,22 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
 {
 	EFIAPI efi_status_t (*entry)(efi_handle_t image_handle,
 				     struct efi_system_table *st);
-	struct efi_loaded_image *info = image_handle;
+	struct efi_loaded_image *info;
+	struct efi_handler *handler;
 	efi_status_t ret;
 
 	EFI_ENTRY("%p, %p, %p", image_handle, exit_data_size, exit_data);
-	entry = info->reserved;
 
 	efi_is_direct_boot = false;
 
-	/* call the image! */
+	/* Retrieve the loaded image protocol */
+	ret = efi_search_protocol(image_handle, &efi_guid_loaded_image,
+				  &handler);
+	if (ret != EFI_SUCCESS)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+	info = handler->protocol_interface;
+
+	/* Call the image! */
 	if (setjmp(&info->exit_jmp)) {
 		/*
 		 * We called the entry point of the child image with EFI_CALL
@@ -1573,6 +1582,7 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
 		return EFI_EXIT(info->exit_status);
 	}
 
+	entry = info->reserved;
 	ret = EFI_CALL(entry(image_handle, &systab));
 
 	/*
@@ -1591,6 +1601,8 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
  * See the Unified Extensible Firmware Interface (UEFI) specification
  * for details.
  *
+ * TODO: We should call the unload procedure of the loaded image protocol.
+ *
  * @image_handle	handle of the application or driver that is exiting
  * @exit_status		status code
  * @exit_data_size	size of the buffer in bytes
@@ -1601,22 +1613,20 @@ static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 			efi_status_t exit_status, unsigned long exit_data_size,
 			int16_t *exit_data)
 {
-	/*
-	 * We require that the handle points to the original loaded
-	 * image protocol interface.
-	 *
-	 * For getting the longjmp address this is safer than locating
-	 * the protocol because the protocol may have been reinstalled
-	 * pointing to another memory location.
-	 *
-	 * TODO: We should call the unload procedure of the loaded
-	 *	 image protocol.
-	 */
-	struct efi_loaded_image *loaded_image_info = (void*)image_handle;
+	struct efi_loaded_image *loaded_image_info;
+	struct efi_handler *handler;
+	efi_status_t ret;
 
 	EFI_ENTRY("%p, %ld, %ld, %p", image_handle, exit_status,
 		  exit_data_size, exit_data);
 
+	/* Retrieve the loaded image protocol */
+	ret = efi_search_protocol(image_handle, &efi_guid_loaded_image,
+				  &handler);
+	if (ret != EFI_SUCCESS)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+	loaded_image_info = handler->protocol_interface;
+
 	/* Make sure entry/exit counts for EFI world cross-overs match */
 	EFI_EXIT(exit_status);
 
-- 
2.15.1

