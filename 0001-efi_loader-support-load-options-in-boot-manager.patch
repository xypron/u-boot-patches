From 62070fc6c14bad75e954c10ba5e2851ab89ee5f8 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 23 Jul 2020 20:46:58 +0200
Subject: [PATCH 1/1] efi_loader: support load options in boot manager

UEFI variables BootXXXX specify both an image to run as well as load
options to be passed in the load image protocol. Up to now our boot manager
simply ignored the load options and used the value of environment variable
bootargs instead.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                | 157 ++++++++++++++++++-----------------
 cmd/efidebug.c               |   2 +-
 include/efi_loader.h         |   4 +-
 lib/efi_loader/efi_bootmgr.c |   4 +-
 4 files changed, 86 insertions(+), 81 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 8154efde52..01525e1458 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -30,24 +30,52 @@ DECLARE_GLOBAL_DATA_PTR;
 static struct efi_device_path *bootefi_image_path;
 static struct efi_device_path *bootefi_device_path;
 
+static efi_status_t env_load_options(const char *env_var,
+				     efi_uintn_t *load_options_size,
+				     void **load_options)
+{
+	const char *env = env_get(env_var);
+	efi_status_t ret = EFI_SUCCESS;
+
+	*load_options = NULL;
+
+	if (env) {
+		u16 *pos;
+
+		*load_options_size = sizeof(u16) * (utf8_utf16_strlen(env) + 1);
+		*load_options = calloc(*load_options_size, sizeof(u16));
+		if (!*load_options) {
+			log_err("ERROR: Out of memory\n");
+			ret = EFI_OUT_OF_RESOURCES;
+			goto out;
+		}
+		pos = *load_options;
+		utf8_utf16_strcpy(&pos, env);
+	}
+
+out:
+	if (!*load_options)
+		*load_options_size = 0;
+
+	return ret;
+}
+
 /**
  * Set the load options of an image from an environment variable.
  *
  * @handle:		the image handle
  * @env_var:		name of the environment variable
- * @load_options:	pointer to load options (output)
+ * @load_options_size:	size of load options
+ * @load_options:	pointer to load options
  * Return:		status code
  */
-static efi_status_t set_load_options(efi_handle_t handle, const char *env_var,
-				     u16 **load_options)
+static efi_status_t set_load_options(efi_handle_t handle,
+				     efi_uintn_t load_options_size,
+				     void *load_options)
 {
 	struct efi_loaded_image *loaded_image_info;
-	size_t size;
-	const char *env = env_get(env_var);
-	u16 *pos;
 	efi_status_t ret;
 
-	*load_options = NULL;
 	ret = EFI_CALL(systab.boottime->open_protocol(
 					handle,
 					&efi_guid_loaded_image,
@@ -57,26 +85,9 @@ static efi_status_t set_load_options(efi_handle_t handle, const char *env_var,
 	if (ret != EFI_SUCCESS)
 		return EFI_INVALID_PARAMETER;
 
-	loaded_image_info->load_options = NULL;
-	loaded_image_info->load_options_size = 0;
-	if (!env)
-		goto out;
-
-	size = utf8_utf16_strlen(env) + 1;
-	loaded_image_info->load_options = calloc(size, sizeof(u16));
-	if (!loaded_image_info->load_options) {
-		log_err("ERROR: Out of memory\n");
-		EFI_CALL(systab.boottime->close_protocol(handle,
-							 &efi_guid_loaded_image,
-							 efi_root, NULL));
-		return EFI_OUT_OF_RESOURCES;
-	}
-	pos = loaded_image_info->load_options;
-	*load_options = pos;
-	utf8_utf16_strcpy(&pos, env);
-	loaded_image_info->load_options_size = size * 2;
+	loaded_image_info->load_options = load_options;
+	loaded_image_info->load_options_size = load_options_size;
 
-out:
 	return EFI_CALL(systab.boottime->close_protocol(handle,
 							&efi_guid_loaded_image,
 							efi_root, NULL));
@@ -323,22 +334,25 @@ efi_status_t efi_install_fdt(void *fdt)
  * do_bootefi_exec() - execute EFI binary
  *
  * @handle:		handle of loaded image
+ * @load_options_size:	size of load options
+ * @load_option:	load options
  * Return:		status code
  *
  * Load the EFI binary into a newly assigned memory unwinding the relocation
  * information, install the loaded image protocol, and call the binary.
  */
-static efi_status_t do_bootefi_exec(efi_handle_t handle)
+static efi_status_t do_bootefi_exec(efi_handle_t handle,
+				    efi_uintn_t load_options_size,
+				    void *load_options)
 {
 	efi_status_t ret;
 	efi_uintn_t exit_data_size = 0;
 	u16 *exit_data = NULL;
-	u16 *load_options;
 
 	/* Transfer environment variable as load options */
-	ret = set_load_options(handle, "bootargs", &load_options);
+	ret = set_load_options(handle, load_options_size, load_options);
 	if (ret != EFI_SUCCESS)
-		return ret;
+		goto out;
 
 	/* Call our payload! */
 	ret = EFI_CALL(efi_start_image(handle, &exit_data_size, &exit_data));
@@ -351,8 +365,8 @@ static efi_status_t do_bootefi_exec(efi_handle_t handle)
 		}
 	}
 
+out:
 	efi_restore_gd();
-
 	free(load_options);
 
 	return ret;
@@ -367,14 +381,16 @@ static int do_efibootmgr(void)
 {
 	efi_handle_t handle;
 	efi_status_t ret;
+	efi_uintn_t load_options_size;
+	void *load_options;
 
-	ret = efi_bootmgr_load(&handle);
+	ret = efi_bootmgr_load(&handle, &load_options_size, &load_options);
 	if (ret != EFI_SUCCESS) {
 		log_notice("EFI boot manager: Cannot load any image\n");
 		return CMD_RET_FAILURE;
 	}
 
-	ret = do_bootefi_exec(handle);
+	ret = do_bootefi_exec(handle, load_options_size, load_options);
 
 	if (ret != EFI_SUCCESS)
 		return CMD_RET_FAILURE;
@@ -453,6 +469,8 @@ efi_status_t efi_run_image(void *source_buffer, efi_uintn_t source_size)
 	efi_handle_t mem_handle = NULL, handle;
 	struct efi_device_path *file_path = NULL;
 	efi_status_t ret;
+	efi_uintn_t load_options_size;
+	void *load_options;
 
 	if (!bootefi_device_path || !bootefi_image_path) {
 		/*
@@ -485,7 +503,11 @@ efi_status_t efi_run_image(void *source_buffer, efi_uintn_t source_size)
 	if (ret != EFI_SUCCESS)
 		goto out;
 
-	ret = do_bootefi_exec(handle);
+	ret = env_load_options("bootargs", &load_options_size, &load_options);
+	if (ret != EFI_SUCCESS)
+		goto out;
+
+	ret = do_bootefi_exec(handle, load_options_size, load_options);
 
 out:
 	efi_delete_handle(mem_handle);
@@ -494,24 +516,6 @@ out:
 }
 
 #ifdef CONFIG_CMD_BOOTEFI_SELFTEST
-static efi_status_t bootefi_run_prepare(const char *load_options_path,
-		struct efi_device_path *device_path,
-		struct efi_device_path *image_path,
-		struct efi_loaded_image_obj **image_objp,
-		struct efi_loaded_image **loaded_image_infop)
-{
-	efi_status_t ret;
-	u16 *load_options;
-
-	ret = efi_setup_loaded_image(device_path, image_path, image_objp,
-				     loaded_image_infop);
-	if (ret != EFI_SUCCESS)
-		return ret;
-
-	/* Transfer environment variable as load options */
-	return set_load_options((efi_handle_t)*image_objp, load_options_path,
-				&load_options);
-}
 
 /**
  * bootefi_test_prepare() - prepare to run an EFI test
@@ -522,14 +526,11 @@ static efi_status_t bootefi_run_prepare(const char *load_options_path,
  * @loaded_image_infop:	pointer to be set to the loaded image protocol
  * @path:		dummy file path used to construct the device path
  *			set in the loaded image protocol
- * @load_options_path:	name of a U-Boot environment variable. Its value is
- *			set as load options in the loaded image protocol.
  * Return:		status code
  */
 static efi_status_t bootefi_test_prepare
 		(struct efi_loaded_image_obj **image_objp,
-		 struct efi_loaded_image **loaded_image_infop, const char *path,
-		 const char *load_options_path)
+		 struct efi_loaded_image **loaded_image_infop, const char *path)
 {
 	efi_status_t ret;
 
@@ -544,34 +545,18 @@ static efi_status_t bootefi_test_prepare
 		goto failure;
 	}
 
-	ret = bootefi_run_prepare(load_options_path, bootefi_device_path,
-				  bootefi_image_path, image_objp,
-				  loaded_image_infop);
-	if (ret == EFI_SUCCESS)
-		return ret;
+	ret = efi_setup_loaded_image(bootefi_device_path, bootefi_image_path,
+				     image_objp, loaded_image_infop);
 
 	efi_free_pool(bootefi_image_path);
-	bootefi_image_path = NULL;
+
 failure:
 	efi_free_pool(bootefi_device_path);
+	bootefi_image_path = NULL;
 	bootefi_device_path = NULL;
 	return ret;
 }
 
-/**
- * bootefi_run_finish() - finish up after running an EFI test
- *
- * @loaded_image_info: Pointer to a struct which holds the loaded image info
- * @image_obj: Pointer to a struct which holds the loaded image object
- */
-static void bootefi_run_finish(struct efi_loaded_image_obj *image_obj,
-			       struct efi_loaded_image *loaded_image_info)
-{
-	efi_restore_gd();
-	free(loaded_image_info->load_options);
-	efi_delete_handle(&image_obj->header);
-}
-
 /**
  * do_efi_selftest() - execute EFI selftest
  *
@@ -581,16 +566,32 @@ static int do_efi_selftest(void)
 {
 	struct efi_loaded_image_obj *image_obj;
 	struct efi_loaded_image *loaded_image_info;
+	efi_uintn_t load_options_size;
+	void *load_options;
 	efi_status_t ret;
 
 	ret = bootefi_test_prepare(&image_obj, &loaded_image_info,
-				   "\\selftest", "efi_selftest");
+				   "\\selftest");
 	if (ret != EFI_SUCCESS)
 		return CMD_RET_FAILURE;
 
+	ret = env_load_options("efi_selftest", &load_options_size,
+			       &load_options);
+	if (ret != EFI_SUCCESS)
+		goto out;
+
+	ret = set_load_options(&image_obj->header, load_options_size,
+			       load_options);
+	if (ret == EFI_SUCCESS)
+		goto out;
+
 	/* Execute the test */
 	ret = EFI_CALL(efi_selftest(&image_obj->header, &systab));
-	bootefi_run_finish(image_obj, loaded_image_info);
+
+out:
+	efi_restore_gd();
+	free(load_options);
+	efi_delete_handle(&image_obj->header);
 
 	return ret != EFI_SUCCESS;
 }
diff --git a/cmd/efidebug.c b/cmd/efidebug.c
index 58018f700c..2644aadbf4 100644
--- a/cmd/efidebug.c
+++ b/cmd/efidebug.c
@@ -1127,7 +1127,7 @@ static int do_efi_test_bootmgr(struct cmd_tbl *cmdtp, int flag,
 	u16 *exit_data = NULL;
 	efi_status_t ret;
 
-	ret = efi_bootmgr_load(&image);
+	ret = efi_bootmgr_load(&image, 0, NULL);
 	printf("efi_bootmgr_load() returned: %ld\n", ret & ~EFI_ERROR_MASK);
 
 	/* We call efi_start_image() even if error for test purpose. */
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 98944640be..dcc9d1c644 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -717,7 +717,9 @@ struct efi_load_option {
 efi_status_t efi_deserialize_load_option(struct efi_load_option *lo, u8 *data,
 					 efi_uintn_t *size);
 unsigned long efi_serialize_load_option(struct efi_load_option *lo, u8 **data);
-efi_status_t efi_bootmgr_load(efi_handle_t *handle);
+efi_status_t efi_bootmgr_load(efi_handle_t *handle,
+			      efi_uintn_t *load_options_size,
+			      void **load_options);
 
 /**
  * efi_image_regions - A list of memory regions
diff --git a/lib/efi_loader/efi_bootmgr.c b/lib/efi_loader/efi_bootmgr.c
index e03198b57a..47daf14cb3 100644
--- a/lib/efi_loader/efi_bootmgr.c
+++ b/lib/efi_loader/efi_bootmgr.c
@@ -250,7 +250,9 @@ error:
  * @handle:	on return handle for the newly installed image
  * Return:	status code
  */
-efi_status_t efi_bootmgr_load(efi_handle_t *handle)
+efi_status_t efi_bootmgr_load(efi_handle_t *handle,
+			      efi_uintn_t *load_options_size,
+			      void **load_options)
 {
 	u16 bootnext, *bootorder;
 	efi_uintn_t size;
-- 
2.27.0

