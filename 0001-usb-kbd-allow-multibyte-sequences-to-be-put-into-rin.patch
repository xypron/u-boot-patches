From 735bd66982cf22d92a5da6491d076ab5ff208dd0 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 21 Feb 2018 18:17:55 +0100
Subject: [PATCH 1/1] usb: kbd: allow multibyte sequences to be put into ring
 buffer

The USB keyboard driver provides a ring buffer for key strokes.

Function keys cannot be encoded as single bytes. Instead xterm control
sequences have to be put into the ring buffer.

This preparatory patch changes function usb_kbd_put_queue() to allow adding
multiple characters at once. If the buffer cannot accommodate the whole
sequence, it is rejected completely.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 common/usb_kbd.c | 55 +++++++++++++++++++++----------------------------------
 lib/Makefile     |  4 +++-
 2 files changed, 24 insertions(+), 35 deletions(-)

diff --git a/common/usb_kbd.c b/common/usb_kbd.c
index 8cbdba6ac2..3e6339c7a4 100644
--- a/common/usb_kbd.c
+++ b/common/usb_kbd.c
@@ -8,6 +8,7 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <common.h>
+#include <circbuf.h>
 #include <console.h>
 #include <dm.h>
 #include <errno.h>
@@ -110,9 +111,7 @@ struct usb_kbd_pdata {
 
 	uint32_t	repeat_delay;
 
-	uint32_t	usb_in_pointer;
-	uint32_t	usb_out_pointer;
-	uint8_t		usb_kbd_buffer[USB_KBD_BUFFER_LEN];
+	circbuf_t	buf;
 
 	uint8_t		*new;
 	uint8_t		old[USB_KBD_BOOT_REPORT_SIZE];
@@ -125,26 +124,6 @@ extern int __maybe_unused net_busy_flag;
 /* The period of time between two calls of usb_kbd_testc(). */
 static unsigned long __maybe_unused kbd_testc_tms;
 
-/* Puts character in the queue and sets up the in and out pointer. */
-static void usb_kbd_put_queue(struct usb_kbd_pdata *data, char c)
-{
-	if (data->usb_in_pointer == USB_KBD_BUFFER_LEN - 1) {
-		/* Check for buffer full. */
-		if (data->usb_out_pointer == 0)
-			return;
-
-		data->usb_in_pointer = 0;
-	} else {
-		/* Check for buffer full. */
-		if (data->usb_in_pointer == data->usb_out_pointer - 1)
-			return;
-
-		data->usb_in_pointer++;
-	}
-
-	data->usb_kbd_buffer[data->usb_in_pointer] = c;
-}
-
 /*
  * Set the LEDs. Since this is used in the irq routine, the control job is
  * issued with a timeout of 0. This means, that the job is queued without
@@ -237,7 +216,7 @@ static int usb_kbd_translate(struct usb_kbd_pdata *data, unsigned char scancode,
 	/* Report keycode if any */
 	if (keycode) {
 		debug("%c", keycode);
-		usb_kbd_put_queue(data, keycode);
+		buf_push(&data->buf, (char *)&keycode, 1);
 	}
 
 	return 0;
@@ -351,7 +330,12 @@ static inline void usb_kbd_poll_for_event(struct usb_device *dev)
 #endif
 }
 
-/* test if a character is in the queue */
+/*
+ * test if a character is in the queue
+ *
+ * @sdev:	io device
+ * @return:	0 if buffer is empty
+ */
 static int usb_kbd_testc(struct stdio_dev *sdev)
 {
 	struct stdio_dev *dev;
@@ -374,12 +358,13 @@ static int usb_kbd_testc(struct stdio_dev *sdev)
 
 	usb_kbd_poll_for_event(usb_kbd_dev);
 
-	return !(data->usb_in_pointer == data->usb_out_pointer);
+	return data->buf.size != 0;
 }
 
 /* gets the character from the queue */
 static int usb_kbd_getc(struct stdio_dev *sdev)
 {
+	unsigned char ret;
 	struct stdio_dev *dev;
 	struct usb_device *usb_kbd_dev;
 	struct usb_kbd_pdata *data;
@@ -388,15 +373,9 @@ static int usb_kbd_getc(struct stdio_dev *sdev)
 	usb_kbd_dev = (struct usb_device *)dev->priv;
 	data = usb_kbd_dev->privptr;
 
-	while (data->usb_in_pointer == data->usb_out_pointer)
-		usb_kbd_poll_for_event(usb_kbd_dev);
+	buf_pop(&data->buf, (char *)&ret, 1);
 
-	if (data->usb_out_pointer == USB_KBD_BUFFER_LEN - 1)
-		data->usb_out_pointer = 0;
-	else
-		data->usb_out_pointer++;
-
-	return data->usb_kbd_buffer[data->usb_out_pointer];
+	return ret;
 }
 
 /* probes the USB device dev for keyboard type. */
@@ -443,6 +422,13 @@ static int usb_kbd_probe_dev(struct usb_device *dev, unsigned int ifnum)
 	/* Clear private data */
 	memset(data, 0, sizeof(struct usb_kbd_pdata));
 
+	/* allocate circular buffer for key strokes */
+	if (buf_init(&data->buf, USB_KBD_BUFFER_LEN)) {
+		free(data);
+		printf("USB KBD: Error allocating buffer\n");
+		return 0;
+	}
+
 	/* allocate input buffer aligned and sized to USB DMA alignment */
 	data->new = memalign(USB_DMA_MINALIGN,
 		roundup(USB_KBD_BOOT_REPORT_SIZE, USB_DMA_MINALIGN));
@@ -635,6 +621,7 @@ static int usb_kbd_remove(struct udevice *dev)
 #ifdef CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUE
 	destroy_int_queue(udev, data->intq);
 #endif
+	buf_free(&data->buf);
 	free(data->new);
 	free(data);
 
diff --git a/lib/Makefile b/lib/Makefile
index 0db41c19f3..51ccf0d604 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -21,7 +21,9 @@ obj-$(CONFIG_ARCH_AT91) += at91/
 
 obj-$(CONFIG_AES) += aes.o
 obj-y += charset.o
-obj-$(CONFIG_USB_TTY) += circbuf.o
+ifneq ($(CONFIG_USB_TTY)$(CONFIG_USB_KEYBOARD),)
+obj-y += circbuf.o
+endif
 obj-y += crc7.o
 obj-y += crc8.o
 obj-y += crc16.o
-- 
2.11.0

