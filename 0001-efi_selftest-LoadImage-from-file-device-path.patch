From 383c4f3218eb6e794f4385f568d4e29d658787d6 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 9 Jan 2019 19:04:14 +0100
Subject: [PATCH 1/1] efi_selftest: LoadImage from file device path

Provide a unit test that calls LoadImage() with a file device path and
executes the application via StartImage().

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_selftest/Makefile                 |   3 +
 lib/efi_selftest/efi_selftest_loadimage.c | 456 ++++++++++++++++++++++
 2 files changed, 459 insertions(+)
 create mode 100644 lib/efi_selftest/efi_selftest_loadimage.c

diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index b3d3dadf59..686b28633a 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -50,6 +50,7 @@ endif
 ifeq ($(CONFIG_SANDBOX)$(CONFIG_CPU_V7M)$(CONFIG_X86_64),)
 
 obj-y += \
+efi_selftest_loadimage.o \
 efi_selftest_startimage_exit.o \
 efi_selftest_startimage_return.o
 
@@ -67,6 +68,8 @@ $(obj)/efi_miniapp_file_image_return.h: $(obj)/efi_selftest_miniapp_return.efi
 	$(obj)/../../tools/file2include $(obj)/efi_selftest_miniapp_return.efi > \
 	$(obj)/efi_miniapp_file_image_return.h
 
+$(obj)/efi_selftest_loadimage.o: $(obj)/efi_miniapp_file_image_exit.h
+
 $(obj)/efi_selftest_startimage_exit.o: $(obj)/efi_miniapp_file_image_exit.h
 
 $(obj)/efi_selftest_startimage_return.o: $(obj)/efi_miniapp_file_image_return.h
diff --git a/lib/efi_selftest/efi_selftest_loadimage.c b/lib/efi_selftest/efi_selftest_loadimage.c
new file mode 100644
index 0000000000..a90d08f827
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_loadimage.c
@@ -0,0 +1,456 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * efi_selftest_start_image
+ *
+ * Copyright (c) 2019 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * This test checks the LoadImage and StartImage boot service.
+ *
+ * The efi_selftest_miniapp_exit.efi application is loaded via a file device
+ * path and started.
+ */
+
+#include <efi_selftest.h>
+/* Include containing the miniapp.efi application */
+#include "efi_miniapp_file_image_exit.h"
+
+/* Block size of compressed disk image */
+#define COMPRESSED_DISK_IMAGE_BLOCK_SIZE 8
+
+/* Binary logarithm of the block size */
+#define LB_BLOCK_SIZE 9
+
+#define FILE_NAME L"app.efi"
+#define VOLUME_NAME L"EfiDisk"
+
+static efi_handle_t image_handle;
+static struct efi_boot_services *boottime;
+
+/* One 8 byte block of the compressed disk image */
+struct line {
+	size_t addr;
+	char *line;
+};
+
+/* Compressed file image */
+struct compressed_file_image {
+	size_t length;
+	struct line lines[];
+};
+
+static struct compressed_file_image img = EFI_ST_DISK_IMG;
+
+/* Decompressed file image */
+static u8 *image;
+
+struct file_info {
+	struct efi_file_info info;
+	u16 file_name[sizeof(FILE_NAME)];
+};
+
+static efi_guid_t file_info_guid = EFI_FILE_INFO_GUID;
+
+struct file_system_info {
+	struct efi_file_system_info info;
+	u16 file_name[sizeof(VOLUME_NAME)];
+};
+
+static efi_guid_t file_system_info_guid = EFI_FILE_SYSTEM_INFO_GUID;
+
+static struct file_info priv_file_info = {
+	{
+		.size = sizeof(struct file_info),
+		.attribute = EFI_FILE_READ_ONLY,
+	},
+	FILE_NAME,
+};
+
+struct efi_file_info *file_info = &priv_file_info.info;
+
+static struct {
+	struct efi_device_path_vendor vendor;
+	struct efi_device_path end;
+} __packed dp_volume = {
+	.vendor = {
+		.dp = {
+			.type =	DEVICE_PATH_TYPE_HARDWARE_DEVICE,
+			.sub_type = DEVICE_PATH_SUB_TYPE_VENDOR,
+			.length = sizeof(struct efi_device_path_vendor),
+		},
+		.guid = EFI_GUID(0x4f9a0ebf, 0xa179, 0x88a6, 0x25, 0x68,
+				 0x10, 0x72, 0xb1, 0x93, 0x51, 0x71),
+	},
+	.end = {
+		.type = DEVICE_PATH_TYPE_END,
+		.sub_type = DEVICE_PATH_SUB_TYPE_END,
+		.length = sizeof(struct efi_device_path),
+	}
+};
+
+static struct {
+	struct efi_device_path_vendor vendor;
+	struct efi_device_path path;
+	u16 file[sizeof(FILE_NAME)];
+	struct efi_device_path end;
+} __packed dp_file = {
+	.vendor = {
+		.dp = {
+			.type =	DEVICE_PATH_TYPE_HARDWARE_DEVICE,
+			.sub_type = DEVICE_PATH_SUB_TYPE_VENDOR,
+			.length = sizeof(struct efi_device_path_vendor),
+		},
+		.guid = EFI_GUID(0x4f9a0ebf, 0xa179, 0x88a6, 0x25, 0x68,
+				 0x10, 0x72, 0xb1, 0x93, 0x51, 0x71),
+	},
+	.path = {
+		.type = DEVICE_PATH_TYPE_MEDIA_DEVICE,
+		.sub_type = DEVICE_PATH_SUB_TYPE_FILE_PATH,
+		.length = sizeof(struct efi_device_path) + sizeof(dp_file.file),
+	},
+	.file = FILE_NAME,
+	.end = {
+		.type = DEVICE_PATH_TYPE_END,
+		.sub_type = DEVICE_PATH_SUB_TYPE_END,
+		.length = sizeof(struct efi_device_path),
+	}
+};
+
+static struct file_system_info priv_file_system_info = {
+	{
+		.size = sizeof(struct file_system_info),
+		.read_only = true,
+		.volume_size = 0x100000,
+		.free_space = 0x0,
+		.block_size = 0x200,
+	},
+	VOLUME_NAME
+};
+
+static struct efi_file_system_info *file_system_info =
+	&priv_file_system_info.info;
+
+static efi_status_t EFIAPI open_volume
+	(struct efi_simple_file_system_protocol *this,
+	 struct efi_file_handle **root);
+
+static efi_status_t EFIAPI open
+	(struct efi_file_handle *this,
+	 struct efi_file_handle **new_handle,
+	 u16 *file_name, u64 open_mode, u64 attributes);
+
+static efi_status_t EFIAPI close(struct efi_file_handle *this);
+
+static efi_status_t EFIAPI delete(struct efi_file_handle *this);
+
+static efi_status_t EFIAPI read
+	(struct efi_file_handle *this, efi_uintn_t *buffer_size, void *buffer);
+
+static efi_status_t EFIAPI write
+	(struct efi_file_handle *this, efi_uintn_t *buffer_size, void *buffer);
+
+static efi_status_t EFIAPI getpos(struct efi_file_handle *this, u64 *pos);
+
+static efi_status_t EFIAPI setpos(struct efi_file_handle *this, u64 pos);
+
+static efi_status_t EFIAPI getinfo
+	(struct efi_file_handle *this, const efi_guid_t *info_type,
+	 efi_uintn_t *buffer_size, void *buffer);
+
+static efi_status_t EFIAPI setinfo
+	(struct efi_file_handle *this, const efi_guid_t *info_type,
+	 efi_uintn_t buffer_size, void *buffer);
+
+static efi_status_t EFIAPI flush(struct efi_file_handle *this);
+
+static struct {
+	int volume_open_count;
+	int file_open_count;
+	u64 file_size;
+	u64 file_pos;
+} priv;
+
+static struct efi_file_handle file = {
+	.rev = 0x00010000,
+	.open = open,
+	.close = close,
+	.delete = delete,
+	.read = read,
+	.write = write,
+	.getpos = getpos,
+	.setpos = setpos,
+	.getinfo = getinfo,
+	.setinfo = setinfo,
+	.flush = flush,
+};
+
+static struct efi_file_handle volume = {
+	.rev = 0x00010000,
+	.open = open,
+	.close = close,
+	.delete = delete,
+	.read = read,
+	.write = write,
+	.getpos = getpos,
+	.setpos = setpos,
+	.getinfo = getinfo,
+	.setinfo = setinfo,
+	.flush = flush,
+};
+
+struct efi_simple_file_system_protocol file_system = {
+	.rev = 0x00010000,
+	.open_volume = open_volume,
+};
+
+static efi_status_t EFIAPI open_volume
+	(struct efi_simple_file_system_protocol *this,
+	 struct efi_file_handle **root)
+{
+	if (this != &file_system || !root)
+		return EFI_INVALID_PARAMETER;
+
+	*root = &volume;
+	priv.volume_open_count++;
+
+	return EFI_SUCCESS;
+}
+
+static efi_status_t EFIAPI open
+	(struct efi_file_handle *this,
+	 struct efi_file_handle **new_handle,
+	 u16 *file_name, u64 open_mode, u64 attributes)
+{
+	if (this != &volume)
+		return EFI_INVALID_PARAMETER;
+
+	*new_handle = &file;
+	priv.file_pos = 0;
+	priv.file_open_count++;
+
+	return EFI_UNSUPPORTED;
+}
+
+static efi_status_t EFIAPI close(struct efi_file_handle *this)
+{
+	if (this == &file)
+		priv.file_open_count--;
+	else if (this == &volume)
+		priv.volume_open_count--;
+	else
+		return EFI_INVALID_PARAMETER;
+
+	return EFI_UNSUPPORTED;
+}
+
+static efi_status_t EFIAPI delete(struct efi_file_handle *this)
+{
+	if (this != &file)
+		return EFI_INVALID_PARAMETER;
+
+	return EFI_UNSUPPORTED;
+}
+
+static efi_status_t EFIAPI read
+	(struct efi_file_handle *this, efi_uintn_t *buffer_size, void *buffer)
+{
+	if (this != &file)
+		return EFI_INVALID_PARAMETER;
+
+	if (priv.file_pos >= img.length)
+		*buffer_size = 0;
+	else if (priv.file_pos + *buffer_size > img.length)
+		*buffer_size = img.length - priv.file_pos;
+
+	boottime->copy_mem(buffer, &image[priv.file_pos], *buffer_size);
+	priv.file_pos += *buffer_size;
+
+	return EFI_SUCCESS;
+}
+
+static efi_status_t EFIAPI write
+	(struct efi_file_handle *this, efi_uintn_t *buffer_size, void *buffer)
+{
+	if (this != &file)
+		return EFI_INVALID_PARAMETER;
+
+	return EFI_UNSUPPORTED;
+}
+
+static efi_status_t EFIAPI getpos(struct efi_file_handle *this, u64 *pos)
+{
+	if (this != &file)
+		return EFI_INVALID_PARAMETER;
+
+	*pos = priv.file_pos;
+
+	return EFI_UNSUPPORTED;
+}
+
+static efi_status_t EFIAPI setpos(struct efi_file_handle *this, u64 pos)
+{
+	if (this != &file)
+		return EFI_INVALID_PARAMETER;
+
+	priv.file_pos = pos;
+
+	return EFI_UNSUPPORTED;
+}
+
+static efi_status_t EFIAPI getinfo
+	(struct efi_file_handle *this, const efi_guid_t *info_type,
+	 efi_uintn_t *buffer_size, void *buffer)
+{
+	if (this == &file) {
+		if (efi_st_memcmp(info_type, &file_info_guid,
+				  sizeof(efi_guid_t)))
+			return EFI_INVALID_PARAMETER;
+		if (*buffer_size >= sizeof(struct file_info)) {
+			boottime->copy_mem(buffer, file_info,
+					   sizeof(struct file_info));
+		} else {
+			*buffer_size = sizeof(struct file_info);
+			return EFI_BUFFER_TOO_SMALL;
+		}
+	} else if (this == &volume) {
+		if (efi_st_memcmp(info_type, &file_system_info_guid,
+				  sizeof(efi_guid_t)))
+			return EFI_INVALID_PARAMETER;
+		if (*buffer_size >= sizeof(struct file_system_info)) {
+			boottime->copy_mem(buffer, file_system_info,
+					   sizeof(struct file_system_info));
+		} else {
+			*buffer_size = sizeof(struct file_system_info);
+			return EFI_BUFFER_TOO_SMALL;
+		}
+	} else {
+		return EFI_INVALID_PARAMETER;
+	}
+	return EFI_SUCCESS;
+}
+
+static efi_status_t EFIAPI setinfo
+	(struct efi_file_handle *this, const efi_guid_t *info_type,
+	 efi_uintn_t buffer_size, void *buffer)
+{
+	if (this != &file)
+		return EFI_INVALID_PARAMETER;
+
+	return EFI_UNSUPPORTED;
+}
+
+static efi_status_t EFIAPI flush(struct efi_file_handle *this)
+{
+	if (this != &file)
+		return EFI_INVALID_PARAMETER;
+
+	return EFI_UNSUPPORTED;
+}
+
+/*
+ * Decompress the disk image.
+ *
+ * @image	decompressed disk image
+ * @return	status code
+ */
+static efi_status_t decompress(u8 **image)
+{
+	u8 *buf;
+	size_t i;
+	size_t addr;
+	size_t len;
+	efi_status_t ret;
+
+	ret = boottime->allocate_pool(EFI_LOADER_DATA, img.length,
+				      (void **)&buf);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Out of memory\n");
+		return ret;
+	}
+	boottime->set_mem(buf, img.length, 0);
+
+	for (i = 0; ; ++i) {
+		if (!img.lines[i].line)
+			break;
+		addr = img.lines[i].addr;
+		len = COMPRESSED_DISK_IMAGE_BLOCK_SIZE;
+		if (addr + len > img.length)
+			len = img.length - addr;
+		boottime->copy_mem(buf + addr, img.lines[i].line, len);
+	}
+	*image = buf;
+	priv.file_size = img.length;
+	return ret;
+}
+
+/*
+ * Setup unit test.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int setup(const efi_handle_t handle,
+		 const struct efi_system_table *systable)
+{
+	image_handle = handle;
+	boottime = systable->boottime;
+
+	/* Load the application image into memory */
+	decompress(&image);
+
+	return EFI_ST_SUCCESS;
+}
+
+/*
+ * Tear down unit test.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int teardown(void)
+{
+	efi_status_t r = EFI_ST_SUCCESS;
+
+	if (image) {
+		r = efi_free_pool(image);
+		if (r != EFI_SUCCESS) {
+			efi_st_error("Failed to free image\n");
+			return EFI_ST_FAILURE;
+		}
+	}
+	return r;
+}
+
+/*
+ * Execute unit test.
+ *
+ * Load and start the application image.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int execute(void)
+{
+	efi_status_t ret;
+	efi_handle_t handle;
+
+	ret = boottime->load_image(false, image_handle, NULL, image,
+				   img.length, &handle);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to load image\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = boottime->start_image(handle, NULL, NULL);
+	if (ret != EFI_UNSUPPORTED) {
+		efi_st_error("Wrong return value from application\n");
+		return EFI_ST_FAILURE;
+	}
+
+	return EFI_ST_SUCCESS;
+}
+
+EFI_UNIT_TEST(loadimage) = {
+	.name = "load image from file",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup,
+	.execute = execute,
+	.teardown = teardown,
+};
-- 
2.20.1

