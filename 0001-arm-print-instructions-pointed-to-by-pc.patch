From 01cd778d4225914377e61c7d9f4b2bed04c60fe3 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 18 Apr 2018 20:35:14 +0200
Subject: [PATCH v3 1/2] arm: print instructions pointed to by pc

If an exception occurs in a loaded image and the relocation offset is
unknown, it is helful to know the instructions pointed to by the
program counter. This patch adds the missing output.

A possible output is:
    Code: e1c560d0 e12fff1e e120077b e12fff1e (e7f7defb)

The parentheses indicate the instruction causing the exception.

The output can be disassembled using the decodecode script provided
by the Linux kernel project.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v3:
	use the Linux output format for the 'Code:' line
---
 arch/arm/lib/interrupts.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/arch/arm/lib/interrupts.c b/arch/arm/lib/interrupts.c
index 28ba3f14f36..930b25ccb81 100644
--- a/arch/arm/lib/interrupts.c
+++ b/arch/arm/lib/interrupts.c
@@ -56,6 +56,30 @@ static void show_efi_loaded_images(struct pt_regs *regs)
 	efi_print_image_infos((void *)instruction_pointer(regs));
 }
 
+static void dump_instr(struct pt_regs *regs)
+{
+	unsigned long addr = instruction_pointer(regs);
+	const int thumb = thumb_mode(regs);
+	const int width = thumb ? 4 : 8;
+	int i;
+
+	if (thumb)
+		addr &= ~1L;
+	else
+		addr &= ~3L;
+	printf("Code: ");
+	for (i = -4; i < 1 + !!thumb; i++) {
+		unsigned int val;
+
+		if (thumb)
+			val = ((u16 *)addr)[i];
+		else
+			val = ((u32 *)addr)[i];
+		printf(i == 0 ? "(%0*x) " : "%0*x ", width, val);
+	}
+	printf("\n");
+}
+
 void show_regs (struct pt_regs *regs)
 {
 	unsigned long __maybe_unused flags;
@@ -96,6 +120,7 @@ void show_regs (struct pt_regs *regs)
 		fast_interrupts_enabled (regs) ? "on" : "off",
 		processor_modes[processor_mode (regs)],
 		thumb_mode (regs) ? " (T)" : "");
+	dump_instr(regs);
 }
 
 /* fixup PC to point to the instruction leading to the exception */
-- 
2.17.0

