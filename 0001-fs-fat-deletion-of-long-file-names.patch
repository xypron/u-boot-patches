From fc19b0381879c4090d86cdd4a5cad4286bcc3d6e Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 19 Nov 2020 07:31:18 +0100
Subject: [PATCH 1/1] fs: fat: deletion of long file names

Long file names are stored in multiple directory entries. When deleting a
file we must delete all of them.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 fs/fat/fat_write.c | 91 +++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 77 insertions(+), 14 deletions(-)

diff --git a/fs/fat/fat_write.c b/fs/fat/fat_write.c
index d04ee31704..6f27b298af 100644
--- a/fs/fat/fat_write.c
+++ b/fs/fat/fat_write.c
@@ -1401,32 +1401,95 @@ exit:
 	return count;
 }
 
-static int delete_dentry(fat_itr *itr)
+/**
+ * delete_single_dentry() - delete a single directory entry
+ *
+ * @itr:	directory iterator
+ * Return:	0 for success
+ */
+static int delete_single_dentry(fat_itr *itr)
+{
+	struct dir_entry *dent = itr->dent;
+
+	memset(dent, 0, sizeof(*dent));
+	dent->name[0] = DELETED_FLAG;
+
+	if (flush_dir(itr)) {
+		printf("error: writing directory entry\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+/**
+ * delete_long_name() - delete long name directory entries
+ *
+ * @itr:	directory iterator
+ * Return:	0 for success
+ */
+static int delete_long_name(fat_itr *itr)
+{
+	struct dir_entry *dent = itr->dent;
+	int seqn = itr->dent->name[0] & ~LAST_LONG_ENTRY_MASK;
+
+	while (seqn--) {
+		int ret;
+
+		ret = delete_single_dentry(itr);
+		if (ret)
+			return ret;
+		dent = next_dent(itr);
+		if (!dent)
+			return -EIO;
+	}
+	return 0;
+}
+
+/**
+ * delete_dentry_long() - remove directory entry
+ *
+ * @itr:	directory iterator
+ * Return:	0 for success
+ */
+static int delete_dentry_long(fat_itr *itr)
 {
 	fsdata *mydata = itr->fsdata;
-	dir_entry *dentptr = itr->dent;
+	dir_entry *dent = itr->dent;
+	unsigned nbytes;
 
 	/* free cluster blocks */
-	clear_fatent(mydata, START(dentptr));
+	clear_fatent(mydata, START(dent));
 	if (flush_dirty_fat_buffer(mydata) < 0) {
 		printf("Error: flush fat buffer\n");
 		return -EIO;
 	}
+	/* Position to first directory entry for long name */
+	if (itr->next_clust != itr->dent_clust) {
+		itr->next_clust = itr->dent_clust;
+		itr->last_cluster = 0;
+		fat_next_cluster(itr, &nbytes);
+		if (!nbytes)
+			return -EIO;
+	}
+	itr->dent = itr->dent_start;
+	itr->remaining = itr->dent_rem;
+	dent = itr->dent_start;
+	/* Delete long name */
+	if ((dent->attr & ATTR_VFAT) == ATTR_VFAT &&
+	    (dent->name[0] & LAST_LONG_ENTRY_MASK)) {
+		int ret;
+
+		ret = delete_long_name(itr);
+		if (ret)
+			return ret;
+	}
+	/* Delete short name */
+	delete_single_dentry(itr);
 
 	/*
-	 * update a directory entry
 	 * TODO:
-	 *  - long file name support
 	 *  - find and mark the "new" first invalid entry as name[0]=0x00
 	 */
-	memset(dentptr, 0, sizeof(*dentptr));
-	dentptr->name[0] = DELETED_FLAG;
-
-	if (flush_dir(itr)) {
-		printf("error: writing directory entry\n");
-		return -EIO;
-	}
-
 	return 0;
 }
 
@@ -1491,7 +1554,7 @@ int fat_unlink(const char *filename)
 		}
 	}
 
-	ret = delete_dentry(itr);
+	ret = delete_dentry_long(itr);
 
 exit:
 	free(fsdata.fatbuf);
-- 
2.29.2

