From fd34178bcc6760facb8a33e98f4df19852bfc091 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Fri, 12 Oct 2018 10:37:04 +0200
Subject: [PATCH v2 1/1] efi_loader: PSCI reset and shutdown

When an operating system started via bootefi tries to reset or power off
this is done by calling the EFI runtime ResetSystem(). On most ARMv8 system
the actual reset relies on PSCI. Depending on whether the PSCI firmware
resides the hypervisor or in the supervisor either an HVC or an SVC command
has to be issued. The current implementation always uses SVC. This results
in crashes on systems where the PSCI firmware is implemented in the
hypervisor, e.g. qemu-arm64_defconfig.

The logic to decide which call is needed based on the device tree is already
implemented in the PSCI firmware driver. So let's use it for the EFI
runtime.

As the same problem is also evident for the ARMv8 poweroff command
implementation fix it in the same way.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v2
	use the PSCI firmware driver as suggested by Sumit
---
 arch/arm/cpu/armv7/smccc-call.S |  2 +
 arch/arm/cpu/armv8/Kconfig      |  1 +
 arch/arm/cpu/armv8/fwcall.c     | 52 +++-------------------
 arch/arm/cpu/armv8/smccc-call.S |  2 +
 drivers/firmware/psci.c         | 76 +++++++++++++++++++++++++++++----
 lib/efi_loader/efi_runtime.c    | 10 +++++
 6 files changed, 88 insertions(+), 55 deletions(-)

diff --git a/arch/arm/cpu/armv7/smccc-call.S b/arch/arm/cpu/armv7/smccc-call.S
index 0d8b59eb6b..eae69e36c3 100644
--- a/arch/arm/cpu/armv7/smccc-call.S
+++ b/arch/arm/cpu/armv7/smccc-call.S
@@ -7,6 +7,8 @@
 #include <asm/opcodes-sec.h>
 #include <asm/opcodes-virt.h>
 
+	.section	.text.efi_runtime
+
 #define UNWIND(x...)
 	/*
 	 * Wrap c macros in asm macros to delay expansion until after the
diff --git a/arch/arm/cpu/armv8/Kconfig b/arch/arm/cpu/armv8/Kconfig
index c8bebabdf6..f64cf0cb0f 100644
--- a/arch/arm/cpu/armv8/Kconfig
+++ b/arch/arm/cpu/armv8/Kconfig
@@ -96,6 +96,7 @@ endmenu
 config PSCI_RESET
 	bool "Use PSCI for reset and shutdown"
 	default y
+	select ARM_SMCCC
 	depends on !ARCH_EXYNOS7 && !ARCH_BCM283X && \
 		   !TARGET_LS2080A_SIMU && !TARGET_LS2080AQDS && \
 		   !TARGET_LS2080ARDB && !TARGET_LS2080A_EMU && \
diff --git a/arch/arm/cpu/armv8/fwcall.c b/arch/arm/cpu/armv8/fwcall.c
index 0ba3dad8cc..9957c2974b 100644
--- a/arch/arm/cpu/armv8/fwcall.c
+++ b/arch/arm/cpu/armv8/fwcall.c
@@ -7,7 +7,6 @@
 
 #include <asm-offsets.h>
 #include <config.h>
-#include <efi_loader.h>
 #include <version.h>
 #include <asm/macro.h>
 #include <asm/psci.h>
@@ -19,7 +18,7 @@
  * x0~x7: input arguments
  * x0~x3: output arguments
  */
-static void __efi_runtime hvc_call(struct pt_regs *args)
+static void hvc_call(struct pt_regs *args)
 {
 	asm volatile(
 		"ldr x0, %0\n"
@@ -53,7 +52,7 @@ static void __efi_runtime hvc_call(struct pt_regs *args)
  * x0~x3: output arguments
  */
 
-void __efi_runtime smc_call(struct pt_regs *args)
+void smc_call(struct pt_regs *args)
 {
 	asm volatile(
 		"ldr x0, %0\n"
@@ -83,9 +82,9 @@ void __efi_runtime smc_call(struct pt_regs *args)
  * use PSCI on U-Boot running below a hypervisor, please detect
  * this and set the flag accordingly.
  */
-static const __efi_runtime_data bool use_smc_for_psci = true;
+static const bool use_smc_for_psci = true;
 
-void __noreturn __efi_runtime psci_system_reset(void)
+void __noreturn psci_system_reset(void)
 {
 	struct pt_regs regs;
 
@@ -100,7 +99,7 @@ void __noreturn __efi_runtime psci_system_reset(void)
 		;
 }
 
-void __noreturn __efi_runtime psci_system_off(void)
+void __noreturn psci_system_off(void)
 {
 	struct pt_regs regs;
 
@@ -114,44 +113,3 @@ void __noreturn __efi_runtime psci_system_off(void)
 	while (1)
 		;
 }
-
-#ifdef CONFIG_CMD_POWEROFF
-int do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	puts("poweroff ...\n");
-
-	udelay(50000); /* wait 50 ms */
-
-	disable_interrupts();
-
-	psci_system_off();
-
-	/*NOTREACHED*/
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_PSCI_RESET
-void reset_misc(void)
-{
-	psci_system_reset();
-}
-
-#ifdef CONFIG_EFI_LOADER
-void __efi_runtime EFIAPI efi_reset_system(
-			enum efi_reset_type reset_type,
-			efi_status_t reset_status,
-			unsigned long data_size, void *reset_data)
-{
-	if (reset_type == EFI_RESET_COLD ||
-	    reset_type == EFI_RESET_WARM ||
-	    reset_type == EFI_RESET_PLATFORM_SPECIFIC) {
-		psci_system_reset();
-	} else if (reset_type == EFI_RESET_SHUTDOWN) {
-		psci_system_off();
-	}
-
-	while (1) { }
-}
-#endif /* CONFIG_EFI_LOADER */
-#endif /* CONFIG_PSCI_RESET */
diff --git a/arch/arm/cpu/armv8/smccc-call.S b/arch/arm/cpu/armv8/smccc-call.S
index 16c9e298b4..86de4b4089 100644
--- a/arch/arm/cpu/armv8/smccc-call.S
+++ b/arch/arm/cpu/armv8/smccc-call.S
@@ -6,6 +6,8 @@
 #include <linux/arm-smccc.h>
 #include <generated/asm-offsets.h>
 
+	.section	.text.efi_runtime
+
 	.macro SMCCC instr
 	.cfi_startproc
 	\instr	#0
diff --git a/drivers/firmware/psci.c b/drivers/firmware/psci.c
index 2cb35f356f..fc0d7ff32c 100644
--- a/drivers/firmware/psci.c
+++ b/drivers/firmware/psci.c
@@ -9,17 +9,20 @@
 #include <common.h>
 #include <dm.h>
 #include <dm/lists.h>
+#include <efi_loader.h>
 #include <linux/libfdt.h>
 #include <linux/arm-smccc.h>
 #include <linux/errno.h>
 #include <linux/printk.h>
 #include <linux/psci.h>
 
-psci_fn *invoke_psci_fn;
+#define DRIVER_NAME "psci"
 
-static unsigned long __invoke_psci_fn_hvc(unsigned long function_id,
-			unsigned long arg0, unsigned long arg1,
-			unsigned long arg2)
+psci_fn __efi_runtime_data *invoke_psci_fn;
+
+static unsigned long __efi_runtime __invoke_psci_fn_hvc
+		(unsigned long function_id, unsigned long arg0,
+		 unsigned long arg1, unsigned long arg2)
 {
 	struct arm_smccc_res res;
 
@@ -27,9 +30,9 @@ static unsigned long __invoke_psci_fn_hvc(unsigned long function_id,
 	return res.a0;
 }
 
-static unsigned long __invoke_psci_fn_smc(unsigned long function_id,
-			unsigned long arg0, unsigned long arg1,
-			unsigned long arg2)
+static unsigned long __efi_runtime __invoke_psci_fn_smc
+		(unsigned long function_id, unsigned long arg0,
+		 unsigned long arg1, unsigned long arg2)
 {
 	struct arm_smccc_res res;
 
@@ -78,6 +81,63 @@ static int psci_probe(struct udevice *dev)
 	return 0;
 }
 
+/**
+ * void do_psci_probe() - probe PSCI firmware driver
+ *
+ * Ensure that invoke_psci_fn is initialized.
+ */
+static void __maybe_unused do_psci_probe(void)
+{
+	struct udevice *dev;
+
+	uclass_get_device_by_name(UCLASS_FIRMWARE, DRIVER_NAME, &dev);
+}
+
+#ifdef CONFIG_EFI_LOADER
+efi_status_t efi_reset_system_init(void)
+{
+	do_psci_probe();
+	return EFI_SUCCESS;
+}
+
+void __efi_runtime EFIAPI efi_reset_system(enum efi_reset_type reset_type,
+					   efi_status_t reset_status,
+					   unsigned long data_size,
+					   void *reset_data)
+{
+	if (!invoke_psci_fn)
+		while (1)
+			;
+	if (reset_type == EFI_RESET_COLD ||
+	    reset_type == EFI_RESET_WARM ||
+	    reset_type == EFI_RESET_PLATFORM_SPECIFIC) {
+		invoke_psci_fn(PSCI_0_2_FN_SYSTEM_RESET, 0, 0, 0);
+	} else if (reset_type == EFI_RESET_SHUTDOWN) {
+		invoke_psci_fn(PSCI_0_2_FN_SYSTEM_OFF, 0, 0, 0);
+	}
+	while (1)
+		;
+}
+#endif /* CONFIG_EFI_LOADER */
+
+#ifdef CONFIG_CMD_POWEROFF
+int do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	do_psci_probe();
+	if (!invoke_psci_fn)
+		return CMD_RET_FAILURE;
+
+	puts("poweroff ...\n");
+	udelay(50000); /* wait 50 ms */
+
+	disable_interrupts();
+	invoke_psci_fn(PSCI_0_2_FN_SYSTEM_OFF, 0, 0, 0);
+
+	/*NOTREACHED*/
+	return CMD_RET_SUCCESS;
+}
+#endif
+
 static const struct udevice_id psci_of_match[] = {
 	{ .compatible = "arm,psci" },
 	{ .compatible = "arm,psci-0.2" },
@@ -86,7 +146,7 @@ static const struct udevice_id psci_of_match[] = {
 };
 
 U_BOOT_DRIVER(psci) = {
-	.name = "psci",
+	.name = DRIVER_NAME,
 	.id = UCLASS_FIRMWARE,
 	.of_match = psci_of_match,
 	.bind = psci_bind,
diff --git a/lib/efi_loader/efi_runtime.c b/lib/efi_loader/efi_runtime.c
index c5fbd91fa3..8d24aeacd4 100644
--- a/lib/efi_loader/efi_runtime.c
+++ b/lib/efi_loader/efi_runtime.c
@@ -11,6 +11,7 @@
 #include <elf.h>
 #include <efi_loader.h>
 #include <rtc.h>
+#include <linux/psci.h>
 
 /* For manual relocation support */
 DECLARE_GLOBAL_DATA_PTR;
@@ -461,6 +462,15 @@ static efi_status_t EFIAPI efi_set_virtual_address_map(
 			ptr += off;
 			systab.tables = (struct efi_configuration_table *)ptr;
 		}
+#ifdef CONFIG_ARM_PSCI_FW
+		if ((map_start <= (uintptr_t)invoke_psci_fn) &&
+		    (map_end >= (uintptr_t)invoke_psci_fn)) {
+			char *ptr = (char *)invoke_psci_fn;
+
+			ptr += off;
+			invoke_psci_fn = (psci_fn *)ptr;
+		}
+#endif
 	}
 
 	/* Move the actual runtime code over */
-- 
2.19.1

