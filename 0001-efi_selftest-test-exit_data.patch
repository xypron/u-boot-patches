From e0b0d90d016949e9204062fc0c7f0edaa53e1df6 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 30 Sep 2018 13:26:36 +0200
Subject: [PATCH 1/1] efi_selftest: test exit_data

Amend the unit test 'start image exit' to transfer a string as exit data.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_selftest.h                          |  2 +-
 lib/efi_loader/efi_boottime.c                   | 17 ++++++++------
 lib/efi_selftest/efi_selftest_miniapp_exit.c    | 30 ++++++++++++++++++++-----
 lib/efi_selftest/efi_selftest_startimage_exit.c | 15 ++++++++++++-
 4 files changed, 50 insertions(+), 14 deletions(-)

diff --git a/include/efi_selftest.h b/include/efi_selftest.h
index 56beac305e..b328d4e5c9 100644
--- a/include/efi_selftest.h
+++ b/include/efi_selftest.h
@@ -16,7 +16,7 @@
 
 #define EFI_ST_SUCCESS 0
 #define EFI_ST_FAILURE 1
-
+#define EFI_ST_SUCCESS_STR L"SUCCESS"
 /*
  * Prints a message.
  */
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 464734eaef..56e26508b3 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -1739,6 +1739,7 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
 		 * missed out steps of EFI_CALL.
 		 */
 		assert(__efi_entry_check());
+		printf("%s(%d) %s:\n", __FILE__, __LINE__, __func__);
 		debug("%sEFI: %lu returned by started image\n",
 		      __efi_nesting_dec(),
 		      (unsigned long)((uintptr_t)image_obj->exit_status &
@@ -1822,6 +1823,15 @@ static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 		goto out;
 	}
 
+	image_obj->exit_status = exit_status;
+	if (image_obj->exit_data) {
+		*image_obj->exit_data = exit_data;
+		if (image_obj->exit_data_size)
+			*image_obj->exit_data_size = exit_data_size;
+	}
+
+	printf("%s(%d) %s:\n", __FILE__, __LINE__, __func__);
+
 	/* Make sure entry/exit counts for EFI world cross-overs match */
 	EFI_EXIT(exit_status);
 
@@ -1831,13 +1841,6 @@ static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 	 */
 	efi_restore_gd();
 
-	image_obj->exit_status = exit_status;
-	if (image_obj->exit_data) {
-		*image_obj->exit_data = exit_data;
-		if (image_obj->exit_data_size)
-			*image_obj->exit_data_size = exit_data_size;
-	}
-
 	longjmp(&image_obj->exit_jmp, 1);
 
 	panic("EFI application exited");
diff --git a/lib/efi_selftest/efi_selftest_miniapp_exit.c b/lib/efi_selftest/efi_selftest_miniapp_exit.c
index d63b9e3add..dac6702620 100644
--- a/lib/efi_selftest/efi_selftest_miniapp_exit.c
+++ b/lib/efi_selftest/efi_selftest_miniapp_exit.c
@@ -9,7 +9,7 @@
  */
 
 #include <common.h>
-#include <efi_api.h>
+#include <efi_selftest.h>
 
 static efi_guid_t loaded_image_protocol_guid = LOADED_IMAGE_GUID;
 
@@ -66,15 +66,35 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 			     struct efi_system_table *systable)
 {
 	struct efi_simple_text_output_protocol *con_out = systable->con_out;
-	efi_status_t ret = EFI_UNSUPPORTED;
+	efi_status_t ret;
+	u16 text[] = EFI_ST_SUCCESS_STR;
+	u16 exit_data_size = 0;
+	u16 *exit_data = NULL;
 
 	con_out->output_string(con_out, L"EFI application calling Exit\n");
 
-	if (check_loaded_image_protocol(handle, systable) != EFI_SUCCESS)
+	if (check_loaded_image_protocol(handle, systable) != EFI_SUCCESS) {
+		con_out->output_string(con_out,
+				       L"Loaded image protocol missing\n");
 		ret = EFI_NOT_FOUND;
+		goto out;
+	}
+	ret = systable->boottime->allocate_pool(EFI_ALLOCATE_ANY_PAGES,
+						sizeof(text),
+						(void *)&exit_data);
+	if (ret != EFI_SUCCESS) {
+		con_out->output_string(con_out,
+				       L"AllocatePool failed\n");
+		ret = EFI_OUT_OF_RESOURCES;
+		goto out;
+	}
+	systable->boottime->copy_mem(exit_data, text, sizeof(text));
+	exit_data_size = sizeof(text);
 
-	/* The return value is checked by the calling test */
-	systable->boottime->exit(handle, ret, 0, NULL);
+	/* This return value is expected by the calling test */
+	ret = EFI_UNSUPPORTED;
+out:
+	systable->boottime->exit(handle, ret, exit_data_size, exit_data);
 
 	/*
 	 * This statement should not be reached.
diff --git a/lib/efi_selftest/efi_selftest_startimage_exit.c b/lib/efi_selftest/efi_selftest_startimage_exit.c
index 0d9e16437a..aa85f6be3d 100644
--- a/lib/efi_selftest/efi_selftest_startimage_exit.c
+++ b/lib/efi_selftest/efi_selftest_startimage_exit.c
@@ -123,6 +123,9 @@ static int execute(void)
 {
 	efi_status_t ret;
 	efi_handle_t handle;
+	efi_uintn_t exit_data_size = 0;
+	u16 *exit_data = NULL;
+	u16 expected_text[] = EFI_ST_SUCCESS_STR;
 
 	ret = boottime->load_image(false, image_handle, NULL, image,
 				   img.length, &handle);
@@ -130,11 +133,21 @@ static int execute(void)
 		efi_st_error("Failed to load image\n");
 		return EFI_ST_FAILURE;
 	}
-	ret = boottime->start_image(handle, NULL, NULL);
+	ret = boottime->start_image(handle, &exit_data_size, &exit_data);
 	if (ret != EFI_UNSUPPORTED) {
 		efi_st_error("Wrong return value from application\n");
 		return EFI_ST_FAILURE;
 	}
+	if (!exit_data || exit_data_size != sizeof(expected_text) ||
+	    efi_st_memcmp(exit_data, expected_text, sizeof(expected_text))) {
+		efi_st_error("Incorrect exit data\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = boottime->free_pool(exit_data);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to free exit data\n");
+		return EFI_ST_FAILURE;
+	}
 
 	return EFI_ST_SUCCESS;
 }
-- 
2.11.0

