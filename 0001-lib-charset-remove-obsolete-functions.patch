From c36ca79712835cd5b3000492960ffddee6e47810 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 22 Jul 2018 13:47:57 +0200
Subject: [PATCH 1/1] lib: charset: remove obsolete functions

Remove functions:
- utf8_to_utf16()
- utf16_strcpy()
- utf16_strdup()

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/charset.h | 23 --------------
 lib/charset.c     | 79 -----------------------------------------------
 2 files changed, 102 deletions(-)

diff --git a/include/charset.h b/include/charset.h
index c0ea54f384..6fdfaa9579 100644
--- a/include/charset.h
+++ b/include/charset.h
@@ -177,16 +177,6 @@ size_t u16_strlen(const u16 *in);
  */
 size_t u16_strnlen(const u16 *in, size_t count);
 
-/**
- * utf16_strcpy() - UTF16 equivalent of strcpy()
- */
-uint16_t *utf16_strcpy(uint16_t *dest, const uint16_t *src);
-
-/**
- * utf16_strdup() - UTF16 equivalent of strdup()
- */
-uint16_t *utf16_strdup(const uint16_t *s);
-
 /**
  * utf16_to_utf8() - Convert an utf16 string to utf8
  *
@@ -203,17 +193,4 @@ uint16_t *utf16_strdup(const uint16_t *s);
  */
 uint8_t *utf16_to_utf8(uint8_t *dest, const uint16_t *src, size_t size);
 
-/**
- * utf8_to_utf16() - Convert an utf8 string to utf16
- *
- * Converts up to 'size' characters of the utf16 string 'src' to utf8
- * written to the 'dest' buffer. Stops at 0x00.
- *
- * @dest   the destination buffer to write the utf8 characters
- * @src    the source utf16 string
- * @size   maximum number of utf16 characters to convert
- * @return the pointer to the first unwritten byte in 'dest'
- */
-uint16_t *utf8_to_utf16(uint16_t *dest, const uint8_t *src, size_t size);
-
 #endif /* __CHARSET_H_ */
diff --git a/lib/charset.c b/lib/charset.c
index 736dca80e9..2308c15c67 100644
--- a/lib/charset.c
+++ b/lib/charset.c
@@ -305,29 +305,6 @@ size_t u16_strnlen(const u16 *in, size_t count)
 	return i;
 }
 
-uint16_t *utf16_strcpy(uint16_t *dest, const uint16_t *src)
-{
-	uint16_t *tmp = dest;
-
-	while ((*dest++ = *src++) != '\0')
-		/* nothing */;
-	return tmp;
-
-}
-
-uint16_t *utf16_strdup(const uint16_t *s)
-{
-	uint16_t *new;
-
-	if (!s)
-		return NULL;
-	new = malloc((u16_strlen(s) + 1) * 2);
-	if (!new)
-		return NULL;
-	utf16_strcpy(new, s);
-	return new;
-}
-
 /* Convert UTF-16 to UTF-8.  */
 uint8_t *utf16_to_utf8(uint8_t *dest, const uint16_t *src, size_t size)
 {
@@ -380,59 +357,3 @@ uint8_t *utf16_to_utf8(uint8_t *dest, const uint16_t *src, size_t size)
 
 	return dest;
 }
-
-uint16_t *utf8_to_utf16(uint16_t *dest, const uint8_t *src, size_t size)
-{
-	while (size--) {
-		int extension_bytes;
-		uint32_t code;
-
-		extension_bytes = 0;
-		if (*src <= 0x7f) {
-			code = *src++;
-			/* Exit on zero byte */
-			if (!code)
-				size = 0;
-		} else if (*src <= 0xbf) {
-			/* Illegal code */
-			code = '?';
-		} else if (*src <= 0xdf) {
-			code = *src++ & 0x1f;
-			extension_bytes = 1;
-		} else if (*src <= 0xef) {
-			code = *src++ & 0x0f;
-			extension_bytes = 2;
-		} else if (*src <= 0xf7) {
-			code = *src++ & 0x07;
-			extension_bytes = 3;
-		} else {
-			/* Illegal code */
-			code = '?';
-		}
-
-		for (; extension_bytes && size; --size, --extension_bytes) {
-			if ((*src & 0xc0) == 0x80) {
-				code <<= 6;
-				code |= *src++ & 0x3f;
-			} else {
-				/* Illegal code */
-				code = '?';
-				++src;
-				--size;
-				break;
-			}
-		}
-
-		if (code < 0x10000) {
-			*dest++ = code;
-		} else {
-			/*
-			 * Simplified expression for
-			 * (((code - 0x10000) >> 10) & 0x3ff) | 0xd800
-			 */
-			*dest++ = (code >> 10) + 0xd7c0;
-			*dest++ = (code & 0x3ff) | 0xdc00;
-		}
-	}
-	return dest;
-}
-- 
2.18.0

