From ab52e76f4c6544e4616c41a60326f494f9b9943d Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 21 Nov 2020 08:32:50 +0100
Subject: [PATCH 1/1] fs: fat: call set_name() only once

In set_name() we select the short name. Once this is correctly implemented
this will be a performance intensive operation because we need to check
that the name does not exist yet. So set_name should only be called once.

Use ATTR_ARCH instead of anonymous 0x20 when calling fill_dentry().

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 fs/fat/fat_write.c | 51 +++++++++++++++++++++++++++++++++-------------
 1 file changed, 37 insertions(+), 14 deletions(-)

diff --git a/fs/fat/fat_write.c b/fs/fat/fat_write.c
index 07c046ed42..5381352a56 100644
--- a/fs/fat/fat_write.c
+++ b/fs/fat/fat_write.c
@@ -22,6 +22,9 @@
 /* Characters that may only be used in long file names */
 static const char LONG_ONLY_CHARS[] = "+,;=[]";
 
+/* Combined size of the name and ext fields in the directory entry */
+#define SHORT_NAME_SIZE 11
+
 /**
  * str2fat() - convert string to valid FAT name characters
  *
@@ -66,15 +69,17 @@ static int str2fat(char *dest, char *src, int length)
  *
  * @dirent:	directory entry
  * @filename:	long file name
+ * @shortname:	buffer of 11 bytes to receive chosen short name and extension
  * Return:	0 only short name, 1 long name needed, negative on error
  */
-static int set_name(dir_entry *dirent, const char *filename)
+static int set_name(dir_entry *dirent, const char *filename, char *shortname)
 {
 	char *period;
 	char *pos;
 	int period_location;
 	char buf[13];
 	int i;
+	int ret;
 
 	if (!filename)
 		return -EIO;
@@ -103,8 +108,12 @@ static int set_name(dir_entry *dirent, const char *filename)
 
 	/* If filename and short name are the same, quit. */
 	sprintf(buf, "%.*s.%.3s", period_location, dirent->name, dirent->ext);
-	if (!strcmp(buf, filename))
-		return 0;
+	if (!strcmp(buf, filename)) {
+		ret = 0;
+		goto out;
+	} else {
+		ret = 1;
+	}
 
 	/* Construct an indexed short name */
 	for (i = 1; i < 10000000; ++i) {
@@ -121,9 +130,12 @@ static int set_name(dir_entry *dirent, const char *filename)
 			dirent->name, dirent->ext);
 		debug("short name: %s\n", buf);
 		/* TODO: Check that the short name does not exist yet. */
-		return 1;
+		goto out;
 	}
 	return -EIO;
+out:
+	memcpy(shortname, dirent->name, SHORT_NAME_SIZE);
+	return ret;
 }
 
 static int total_sector;
@@ -997,18 +1009,25 @@ getit:
 	return 0;
 }
 
-/*
- * Fill dir_entry
+/**
+ * fill_dentry() - fill directory entry with shortname
+ *
+ * @mydata:		private filesystem parameters
+ * @dentptr:		directory entry
+ * @shortname:		chosen short name
+ * @start_cluster:	first cluster of file
+ * @size:		file size
+ * @attr:		file attributes
  */
 static void fill_dentry(fsdata *mydata, dir_entry *dentptr,
-	const char *filename, __u32 start_cluster, __u32 size, __u8 attr)
+	const char *shortname, __u32 start_cluster, __u32 size, __u8 attr)
 {
 	set_start_cluster(mydata, dentptr, start_cluster);
 	dentptr->size = cpu_to_le32(size);
 
 	dentptr->attr = attr;
 
-	set_name(dentptr, filename);
+	memcpy(dentptr->name, shortname, SHORT_NAME_SIZE);
 }
 
 /*
@@ -1193,6 +1212,7 @@ int file_fat_write_at(const char *filename, loff_t pos, void *buffer,
 		retdent->size = cpu_to_le32(pos + size);
 	} else {
 		/* Create a new file */
+		char shortname[SHORT_NAME_SIZE];
 
 		if (itr->is_root) {
 			/* root dir cannot have "." or ".." */
@@ -1218,18 +1238,19 @@ int file_fat_write_at(const char *filename, loff_t pos, void *buffer,
 		memset(itr->dent, 0, sizeof(*itr->dent));
 
 		/* Check if long name is needed */
-		ret = set_name(itr->dent, filename);
+		ret = set_name(itr->dent, filename, shortname);
 		if (ret < 0)
 			goto exit;
 		if (ret) {
 			/* Set long name entries */
-			ret = fill_dir_slot(itr, filename)
+			ret = fill_dir_slot(itr, filename);
 			if (ret)
 				goto exit;
 		}
 
 		/* Set short name entry */
-		fill_dentry(itr->fsdata, itr->dent, filename, 0, size, 0x20);
+		fill_dentry(itr->fsdata, itr->dent, shortname, 0, size,
+			    ATTR_ARCH);
 
 		retdent = itr->dent;
 	}
@@ -1461,6 +1482,8 @@ int fat_mkdir(const char *new_dirname)
 		ret = -EEXIST;
 		goto exit;
 	} else {
+		char shortname[SHORT_NAME_SIZE];
+
 		if (itr->is_root) {
 			/* root dir cannot have "." or ".." */
 			if (!strcmp(l_dirname, ".") ||
@@ -1479,18 +1502,18 @@ int fat_mkdir(const char *new_dirname)
 		memset(itr->dent, 0, sizeof(*itr->dent));
 
 		/* Check if long name is needed */
-		ret = set_name(itr->dent, dirname);
+		ret = set_name(itr->dent, dirname, shortname);
 		if (ret < 0)
 			goto exit;
 		if (ret) {
 			/* Set long name entries */
-			ret = fill_dir_slot(itr, dirname)
+			ret = fill_dir_slot(itr, dirname);
 			if (ret)
 				goto exit;
 		}
 
 		/* Set attribute as archive for regular file */
-		fill_dentry(itr->fsdata, itr->dent, dirname, 0, 0,
+		fill_dentry(itr->fsdata, itr->dent, shortname, 0, 0,
 			    ATTR_DIR | ATTR_ARCH);
 
 		retdent = itr->dent;
-- 
2.29.2

