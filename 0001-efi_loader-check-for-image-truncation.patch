From 59bb40ef1ba88d84f1d58f129ef0a90d33a99c14 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 27 Aug 2020 17:50:54 +0200
Subject: [PATCH 1/1] efi_loader: check for image truncation

Check in efi_load_pe() that the image size parameter is at least as large
as the image size indicated in the optional PE header.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_image_loader.c | 27 +++++++++++++++++++++------
 1 file changed, 21 insertions(+), 6 deletions(-)

diff --git a/lib/efi_loader/efi_image_loader.c b/lib/efi_loader/efi_image_loader.c
index 94f76ef6b8..04ce96dbb4 100644
--- a/lib/efi_loader/efi_image_loader.c
+++ b/lib/efi_loader/efi_image_loader.c
@@ -704,6 +704,7 @@ efi_status_t efi_load_pe(struct efi_loaded_image_obj *handle,
 	unsigned long virt_size = 0;
 	int supported = 0;
 	efi_status_t ret;
+	size_t img_size;
 
 	/* Sanity check for a file header */
 	if (efi_size < sizeof(*dos)) {
@@ -761,6 +762,25 @@ efi_status_t efi_load_pe(struct efi_loaded_image_obj *handle,
 		goto err;
 	}
 
+	/* Check that the image is fully loaded */
+	if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
+		IMAGE_NT_HEADERS64 *nt64 = (void *)nt;
+
+		img_size = nt64->OptionalHeader.SizeOfImage;
+	} else if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
+		img_size = nt->OptionalHeader.SizeOfImage;
+	} else {
+		log_err("Invalid optional header magic %x\n",
+			nt->OptionalHeader.Magic);
+		ret = EFI_LOAD_ERROR;
+		goto err;
+	}
+	if (img_size > efi_size) {
+		log_err("Truncated image\n");
+		ret = EFI_LOAD_ERROR;
+		goto err;
+	}
+
 	/* Authenticate an image */
 	if (efi_image_authenticate(efi, efi_size)) {
 		handle->auth_status = EFI_IMAGE_AUTH_PASSED;
@@ -794,7 +814,7 @@ efi_status_t efi_load_pe(struct efi_loaded_image_obj *handle,
 		rel_size = opt->DataDirectory[rel_idx].Size;
 		rel = efi_reloc + opt->DataDirectory[rel_idx].VirtualAddress;
 		virt_size = ALIGN(virt_size, opt->SectionAlignment);
-	} else if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
+	} else { /* IMAGE_NT_OPTIONAL_HDR32_MAGIC */
 		IMAGE_OPTIONAL_HEADER32 *opt = &nt->OptionalHeader;
 		image_base = opt->ImageBase;
 		efi_set_code_and_data_type(loaded_image_info, opt->Subsystem);
@@ -810,11 +830,6 @@ efi_status_t efi_load_pe(struct efi_loaded_image_obj *handle,
 		rel_size = opt->DataDirectory[rel_idx].Size;
 		rel = efi_reloc + opt->DataDirectory[rel_idx].VirtualAddress;
 		virt_size = ALIGN(virt_size, opt->SectionAlignment);
-	} else {
-		log_err("Invalid optional header magic %x\n",
-			nt->OptionalHeader.Magic);
-		ret = EFI_LOAD_ERROR;
-		goto err;
 	}
 
 	/* Copy PE headers */
-- 
2.28.0

