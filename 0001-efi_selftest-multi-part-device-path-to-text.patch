From f2801bb919c2021da8e3906f969891b51cb279dc Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 18 Feb 2021 18:07:57 +0100
Subject: [PATCH 1/1] efi_selftest: multi part device path to text

Test EFI_DEVICE_PATH_TO_TEXT_PROTOCOL.ConvertDevicePathToText() for a multi
part device path.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_selftest/Makefile                  |   3 +
 lib/efi_selftest/dptest.c                  | 103 +++++++++++++++++++++
 lib/efi_selftest/efi_selftest_devicepath.c |  65 +++++++++++++
 3 files changed, 171 insertions(+)
 create mode 100644 lib/efi_selftest/dptest.c

diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index b02fd56e0a..6b95010767 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -10,6 +10,8 @@ ccflags-y += -DHOST_ARCH="$(HOST_ARCH)"
 
 CFLAGS_dtbdump.o := $(CFLAGS_EFI) -Os -ffreestanding
 CFLAGS_REMOVE_dtbdump.o := $(CFLAGS_NON_EFI)
+CFLAGS_dptest.o := $(CFLAGS_EFI) -Os -ffreestanding
+CFLAGS_REMOVE_dptest.o := $(CFLAGS_NON_EFI)
 CFLAGS_efi_selftest_miniapp_exit.o := $(CFLAGS_EFI) -Os -ffreestanding
 CFLAGS_REMOVE_efi_selftest_miniapp_exit.o := $(CFLAGS_NON_EFI)
 CFLAGS_efi_selftest_miniapp_return.o := $(CFLAGS_EFI) -Os -ffreestanding
@@ -83,6 +85,7 @@ efi_selftest_miniapp_return.efi
 ifeq ($(CONFIG_GENERATE_ACPI_TABLE),)
 always += dtbdump.efi
 endif
+always += dptest.efi
 
 ifdef CONFIG_EFI_LOAD_FILE2_INITRD
 always += initrddump.efi
diff --git a/lib/efi_selftest/dptest.c b/lib/efi_selftest/dptest.c
new file mode 100644
index 0000000000..cfa1f8ca92
--- /dev/null
+++ b/lib/efi_selftest/dptest.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020, Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * Test device path to text protocol.
+ */
+
+#include <common.h>
+#include <efi_api.h>
+
+static efi_handle_t handle;
+static struct efi_system_table *systable;
+static struct efi_simple_text_output_protocol *cout;
+static struct efi_boot_services *bs;
+
+static struct {
+	struct efi_device_path_vendor ven1;	
+	struct efi_device_path sep1;
+	struct efi_device_path_vendor ven2;	
+	struct efi_device_path sep2;
+	struct efi_device_path_vendor ven3;	
+	struct efi_device_path end;
+} dp = {
+	{
+		{
+			DEVICE_PATH_TYPE_MEDIA_DEVICE,
+			DEVICE_PATH_SUB_TYPE_VENDOR_PATH,
+			sizeof(struct efi_device_path_vendor),
+		},
+		{{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}},
+	},
+	{
+		DEVICE_PATH_TYPE_END,	
+		DEVICE_PATH_SUB_TYPE_INSTANCE_END,
+		sizeof(struct efi_device_path),
+	},
+	{
+		{
+			DEVICE_PATH_TYPE_MEDIA_DEVICE,
+			DEVICE_PATH_SUB_TYPE_VENDOR_PATH,
+			sizeof(struct efi_device_path_vendor),
+		},
+		{{ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}},
+	},
+	{
+		DEVICE_PATH_TYPE_END,	
+		DEVICE_PATH_SUB_TYPE_INSTANCE_END,
+		sizeof(struct efi_device_path),
+	},
+	{
+		{
+			DEVICE_PATH_TYPE_MEDIA_DEVICE,
+			DEVICE_PATH_SUB_TYPE_VENDOR_PATH,
+			sizeof(struct efi_device_path_vendor),
+		},
+		{{ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,}},
+	},
+	{
+		DEVICE_PATH_TYPE_END,	
+		DEVICE_PATH_SUB_TYPE_END,
+		sizeof(struct efi_device_path),
+	},
+};
+
+
+static efi_guid_t guid_device_path_to_text_protocol =
+	EFI_DEVICE_PATH_TO_TEXT_PROTOCOL_GUID;
+
+/**
+ * efi_main() - entry point of the EFI application.
+ *
+ * @handle:	handle of the loaded image
+ * @systab:	system table
+ * @return:	status code
+ */
+efi_status_t EFIAPI efi_main(efi_handle_t image_handle,
+			     struct efi_system_table *systab)
+{
+	handle = image_handle;
+	systable = systab;
+	cout = systable->con_out;
+	bs = systable->boottime;
+	struct efi_device_path_to_text_protocol *device_path_to_text;
+	u16 *string;
+	efi_status_t ret;
+
+	cout->output_string(cout, L"3-part device path\r\n");
+	ret = bs->locate_protocol(&guid_device_path_to_text_protocol,
+				  NULL, (void **)&device_path_to_text);
+	if (ret != EFI_SUCCESS) {
+		cout->output_string(cout,
+				    L"Device path to text protocol not found\r\n");
+		return ret;
+	}
+
+
+	string = device_path_to_text->convert_device_path_to_text(
+						(void *)&dp, true, false);
+	cout->output_string(cout, string);
+	cout->output_string(cout, L"\r\n");
+
+	return EFI_SUCCESS;
+}
diff --git a/lib/efi_selftest/efi_selftest_devicepath.c b/lib/efi_selftest/efi_selftest_devicepath.c
index 4ce3fad895..d87b9f7dcd 100644
--- a/lib/efi_selftest/efi_selftest_devicepath.c
+++ b/lib/efi_selftest/efi_selftest_devicepath.c
@@ -45,6 +45,55 @@ static u8 *dp1;
 static u8 *dp2;
 static u8 *dp3;
 
+static struct {
+	struct efi_device_path_sd_mmc_path sd1;
+	struct efi_device_path sep1;
+	struct efi_device_path_sd_mmc_path sd2;
+	struct efi_device_path sep2;
+	struct efi_device_path_sd_mmc_path sd3;
+	struct efi_device_path end;
+} multi_part_dp = {
+	{
+		{
+			DEVICE_PATH_TYPE_MESSAGING_DEVICE,
+			DEVICE_PATH_SUB_TYPE_MSG_SD,
+			sizeof(struct efi_device_path_sd_mmc_path),
+		},
+		0,
+	},
+	{
+		DEVICE_PATH_TYPE_END,
+		DEVICE_PATH_SUB_TYPE_INSTANCE_END,
+		sizeof(struct efi_device_path),
+	},
+	{
+		{
+			DEVICE_PATH_TYPE_MESSAGING_DEVICE,
+			DEVICE_PATH_SUB_TYPE_MSG_SD,
+			sizeof(struct efi_device_path_sd_mmc_path),
+		},
+		1,
+	},
+	{
+		DEVICE_PATH_TYPE_END,
+		DEVICE_PATH_SUB_TYPE_INSTANCE_END,
+		sizeof(struct efi_device_path),
+	},
+	{
+		{
+			DEVICE_PATH_TYPE_MESSAGING_DEVICE,
+			DEVICE_PATH_SUB_TYPE_MSG_SD,
+			sizeof(struct efi_device_path_sd_mmc_path),
+		},
+		2,
+	},
+	{
+		DEVICE_PATH_TYPE_END,
+		DEVICE_PATH_SUB_TYPE_END,
+		sizeof(struct efi_device_path),
+	},
+};
+
 struct efi_device_path_to_text_protocol *device_path_to_text;
 
 /*
@@ -340,6 +389,22 @@ static int execute(void)
 		return EFI_ST_FAILURE;
 	}
 
+	string = device_path_to_text->convert_device_path_to_text(
+			(struct efi_device_path *)&multi_part_dp, true, false);
+	if (efi_st_strcmp_16_8(
+		string,
+		"/SD(0),/SD(1),/SD(2)")
+	    ) {
+		efi_st_printf("multi_part_dp: %ps\n", string);
+		efi_st_error("Incorrect text from ConvertDevicePathToText\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = boottime->free_pool(string);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("FreePool failed\n");
+		return EFI_ST_FAILURE;
+	}
+
 	/* Test ConvertDeviceNodeToText */
 	string = device_path_to_text->convert_device_node_to_text(
 			(struct efi_device_path *)&dp_node, true, false);
-- 
2.30.0

