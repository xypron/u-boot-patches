From 83b65f5ee03e1be0d411f762b3e1e56cdf2a75dd Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 29 Mar 2020 18:21:19 +0000
Subject: [PATCH 1/1] cmd: mmc: provide boot area protection command

Provide command 'mmc wp' to power on write protect boot areas on eMMC
devices.

The B_PWR_WP_EN bit in the extended CSD register BOOT_WP is set. The boot
area are write protected until the next power cycle occurs.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/mmc.c         | 22 ++++++++++++++++++++++
 drivers/mmc/mmc.c |  5 +++++
 include/mmc.h     |  9 +++++++++
 3 files changed, 36 insertions(+)

diff --git a/cmd/mmc.c b/cmd/mmc.c
index d62c85e439..80a32d9fa9 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -896,9 +896,30 @@ static int do_mmc_bkops_enable(cmd_tbl_t *cmdtp, int flag,
 }
 #endif
 
+static int do_mmc_boot_wp(cmd_tbl_t *cmdtp, int flag,
+			  int argc, char * const argv[])
+{
+	int err;
+	struct mmc *mmc;
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+	if (IS_SD(mmc)) {
+		printf("It is not an eMMC device\n");
+		return CMD_RET_FAILURE;
+	}
+	err = mmc_boot_wp(mmc);
+	if (err)
+		return CMD_RET_FAILURE;
+	printf("boot areas protected\n");
+	return CMD_RET_SUCCESS;
+}
+
 static cmd_tbl_t cmd_mmc[] = {
 	U_BOOT_CMD_MKENT(info, 1, 0, do_mmcinfo, "", ""),
 	U_BOOT_CMD_MKENT(read, 4, 1, do_mmc_read, "", ""),
+	U_BOOT_CMD_MKENT(wp, 1, 0, do_mmc_boot_wp, "", ""),
 #if CONFIG_IS_ENABLED(MMC_WRITE)
 	U_BOOT_CMD_MKENT(write, 4, 0, do_mmc_write, "", ""),
 	U_BOOT_CMD_MKENT(erase, 3, 0, do_mmc_erase, "", ""),
@@ -968,6 +989,7 @@ U_BOOT_CMD(
 	"mmc part - lists available partition on current mmc device\n"
 	"mmc dev [dev] [part] - show or set current mmc device [partition]\n"
 	"mmc list - lists available devices\n"
+	"mmc wp - power on write protect booot partitions\n"
 #if CONFIG_IS_ENABLED(MMC_HW_PARTITIONING)
 	"mmc hwpartition [args...] - does hardware partitioning\n"
 	"  arguments (sizes in 512-byte blocks):\n"
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index bfcdaa665d..fc3123c3c3 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -810,6 +810,11 @@ int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 	return __mmc_switch(mmc, set, index, value, true);
 }
 
+int mmc_boot_wp(struct mmc *mmc)
+{
+	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BOOT_WP, 1);
+}
+
 #if !CONFIG_IS_ENABLED(MMC_TINY)
 static int mmc_set_card_speed(struct mmc *mmc, enum bus_mode mode,
 			      bool hsdowngrade)
diff --git a/include/mmc.h b/include/mmc.h
index 85fc3497a1..e92e920560 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -907,6 +907,15 @@ struct blk_desc *mmc_get_blk_desc(struct mmc *mmc);
  */
 int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd);
 
+/**
+ * mmc_boot_wp() - power on write protect boot partitions
+ *
+ * The boot partitions are write protected until the next power cycle.
+ *
+ * Return:	0 for success
+ */
+int mmc_boot_wp(struct mmc *mmc);
+
 static inline enum dma_data_direction mmc_get_dma_dir(struct mmc_data *data)
 {
 	return data->flags & MMC_DATA_WRITE ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-- 
2.20.1

