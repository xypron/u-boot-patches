From d8f6d6c776278e7dd475643a98813ad61de0e304 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 18 Oct 2018 21:32:09 +0200
Subject: [PATCH 1/1] efi_loader: fix typos

Fix typos in EFI subsystem comments.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                            |  2 +-
 lib/efi_loader/efi_bootmgr.c             |  2 +-
 lib/efi_loader/efi_console.c             |  4 ++--
 lib/efi_loader/efi_device_path_to_text.c |  8 ++++----
 lib/efi_loader/efi_gop.c                 | 11 +++++++----
 lib/efi_loader/efi_net.c                 |  8 ++++----
 6 files changed, 19 insertions(+), 16 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 78f126f1c6..3605c3ff96 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -354,7 +354,7 @@ static efi_status_t do_bootefi_exec(void *efi,
 	/*
 	 * Special case for efi payload not loaded from disk, such as
 	 * 'bootefi hello' or for example payload loaded directly into
-	 * memory via jtag, etc:
+	 * memory via JTAG, etc:
 	 */
 	if (!device_path && !image_path) {
 		printf("WARNING: using memory device/image path, this may confuse some payloads!\n");
diff --git a/lib/efi_loader/efi_bootmgr.c b/lib/efi_loader/efi_bootmgr.c
index 0c5764db12..2aae12e154 100644
--- a/lib/efi_loader/efi_bootmgr.c
+++ b/lib/efi_loader/efi_bootmgr.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- *  EFI utils
+ *  EFI boot manager
  *
  *  Copyright (c) 2017 Rob Clark
  */
diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index 7274d75204..66c33a551d 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -205,7 +205,7 @@ static int query_console_serial(int *rows, int *cols)
 	/*
 	 * Not all terminals understand CSI [18t for querying the console size.
 	 * We should adhere to escape sequences documented in the console_codes
-	 * manpage and the ECMA-48 standard.
+	 * man page and the ECMA-48 standard.
 	 *
 	 * So here we follow a different approach. We position the cursor to the
 	 * bottom right and query its position. Before leaving the function we
@@ -480,7 +480,7 @@ void set_shift_mask(int mod, struct efi_key_state *key_state)
  *
  * This gets called when we have already parsed CSI.
  *
- * @modifiers:  bitmask (shift, alt, ctrl)
+ * @modifiers:  bit mask (shift, alt, ctrl)
  * @return:	the unmodified code
  */
 static int analyze_modifiers(struct efi_key_state *key_state)
diff --git a/lib/efi_loader/efi_device_path_to_text.c b/lib/efi_loader/efi_device_path_to_text.c
index 0082236359..e219f84b28 100644
--- a/lib/efi_loader/efi_device_path_to_text.c
+++ b/lib/efi_loader/efi_device_path_to_text.c
@@ -269,9 +269,9 @@ static char *efi_convert_single_device_node_to_text(
  * for details.
  *
  * device_node		device node to be converted
- * display_only		true if the shorter text represenation shall be used
+ * display_only		true if the shorter text representation shall be used
  * allow_shortcuts	true if shortcut forms may be used
- * @return		text represenation of the device path
+ * @return		text representation of the device path
  *			NULL if out of memory of device_path is NULL
  */
 static uint16_t EFIAPI *efi_convert_device_node_to_text(
@@ -302,9 +302,9 @@ out:
  * for details.
  *
  * device_path		device path to be converted
- * display_only		true if the shorter text represenation shall be used
+ * display_only		true if the shorter text representation shall be used
  * allow_shortcuts	true if shortcut forms may be used
- * @return		text represenation of the device path
+ * @return		text representation of the device path
  *			NULL if out of memory of device_path is NULL
  */
 static uint16_t EFIAPI *efi_convert_device_path_to_text(
diff --git a/lib/efi_loader/efi_gop.c b/lib/efi_loader/efi_gop.c
index fbd5d97de9..d62ce45912 100644
--- a/lib/efi_loader/efi_gop.c
+++ b/lib/efi_loader/efi_gop.c
@@ -243,12 +243,12 @@ static efi_uintn_t gop_get_bpp(struct efi_gop *this)
 }
 
 /*
- * Gcc can't optimize our BLT function well, but we need to make sure that
+ * GCC can't optimize our BLT function well, but we need to make sure that
  * our 2-dimensional loop gets executed very quickly, otherwise the system
  * will feel slow.
  *
  * By manually putting all obvious branch targets into functions which call
- * our generic blt function with constants, the compiler can successfully
+ * our generic BLT function with constants, the compiler can successfully
  * optimize for speed.
  */
 static efi_status_t gop_blt_video_fill(struct efi_gop *this,
@@ -452,7 +452,7 @@ efi_status_t efi_gop_register(void)
 	ret = efi_add_protocol(&gopobj->header, &efi_gop_guid,
 			       &gopobj->ops);
 	if (ret != EFI_SUCCESS) {
-		printf("ERROR: Failure adding gop protocol\n");
+		printf("ERROR: Failure adding GOP protocol\n");
 		return ret;
 	}
 	gopobj->ops.query_mode = gop_query_mode;
@@ -470,7 +470,10 @@ efi_status_t efi_gop_register(void)
 	if (bpix == LCD_COLOR32)
 #endif
 	{
-		/* With 32bit color space we can directly expose the fb */
+		/*
+		 * With 32bit color space we can directly expose the frame
+		 * buffer
+		 */
 		gopobj->mode.fb_base = fb_base;
 		gopobj->mode.fb_size = fb_size;
 	}
diff --git a/lib/efi_loader/efi_net.c b/lib/efi_loader/efi_net.c
index c4f35cd50d..a64c603ed3 100644
--- a/lib/efi_loader/efi_net.c
+++ b/lib/efi_loader/efi_net.c
@@ -269,7 +269,7 @@ static efi_status_t EFIAPI efi_net_receive(struct efi_simple_network *this,
 	if (protocol)
 		*protocol = protlen;
 	if (*buffer_size < net_rx_packet_len) {
-		/* Packet doesn't fit, try again with bigger buf */
+		/* Packet doesn't fit, try again with bigger buffer */
 		*buffer_size = net_rx_packet_len;
 		return EFI_EXIT(EFI_BUFFER_TOO_SMALL);
 	}
@@ -319,11 +319,11 @@ efi_status_t efi_net_register(void)
 	efi_status_t r;
 
 	if (!eth_get_dev()) {
-		/* No eth device active, don't expose any */
+		/* No network device active, don't expose any */
 		return EFI_SUCCESS;
 	}
 
-	/* We only expose the "active" eth device, so one is enough */
+	/* We only expose the "active" network device, so one is enough */
 	netobj = calloc(1, sizeof(*netobj));
 	if (!netobj) {
 		printf("ERROR: Out of memory\n");
@@ -397,7 +397,7 @@ efi_status_t efi_net_register(void)
 		printf("ERROR: Failed to register network event\n");
 		return r;
 	}
-	/* Network is time critical, create event in every timer cyle */
+	/* Network is time critical, create event in every timer cycle */
 	r = efi_set_timer(network_timer_event, EFI_TIMER_PERIODIC, 0);
 	if (r != EFI_SUCCESS) {
 		printf("ERROR: Failed to set network timer\n");
-- 
2.19.1

