From d8e8073ead720665ec347620f22c09a30318eb4b Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 28 Dec 2019 15:40:40 +0100
Subject: [PATCH v2 1/1] efi_selftest: unit test for EFI_RNG_PROTOCOL

Provide a unit test for the EFI_RNG_PROTOCOL.

The list of algorithms is read. Two random numbers are generated. The test
checks that the two numbers differ.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v2:
	free allocated memory
---
 drivers/virtio/virtio_rng.c         |   2 +-
 include/efi_api.h                   |   2 +-
 lib/efi_selftest/Makefile           |   1 +
 lib/efi_selftest/efi_selftest_rng.c | 117 ++++++++++++++++++++++++++++
 4 files changed, 120 insertions(+), 2 deletions(-)
 create mode 100644 lib/efi_selftest/efi_selftest_rng.c

diff --git a/drivers/virtio/virtio_rng.c b/drivers/virtio/virtio_rng.c
index d0eed93bdd..4d1131a4b8 100644
--- a/drivers/virtio/virtio_rng.c
+++ b/drivers/virtio/virtio_rng.c
@@ -23,7 +23,7 @@ static int virtio_rng_read(struct udevice *dev, void *data, size_t len)
     unsigned char buf[BUFFER_SIZE] __aligned(4);
     unsigned char *ptr = data;
     struct virtio_sg sg;
-    struct virtio_sg *sgs = sg;
+    struct virtio_sg *sgs = &sg;
     struct virtio_rng_priv *priv = dev_get_priv(dev);
 
     while (len) {
diff --git a/include/efi_api.h b/include/efi_api.h
index 22396172e1..a3ff140ac9 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -322,7 +322,7 @@ struct efi_runtime_services {
 struct efi_configuration_table {
 	efi_guid_t guid;
 	void *table;
-} __packed;
+};
 
 #define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)
 
diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index 487cb4c674..3ad96e1cbf 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -47,6 +47,7 @@ efi_selftest_unicode_collation.o
 
 obj-$(CONFIG_CPU_V7) += efi_selftest_unaligned.o
 obj-$(CONFIG_EFI_LOADER_HII) += efi_selftest_hii.o
+obj-$(CONFIG_EFI_RNG_PROTOCOL) += efi_selftest_rng.o
 obj-$(CONFIG_EFI_GET_TIME) += efi_selftest_rtc.o
 
 ifeq ($(CONFIG_GENERATE_ACPI_TABLE),)
diff --git a/lib/efi_selftest/efi_selftest_rng.c b/lib/efi_selftest/efi_selftest_rng.c
new file mode 100644
index 0000000000..cb600bc3f1
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_rng.c
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * efi_selftest_rng
+ *
+ * Copyright (c) 2019 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * Test the random number generator service.
+ */
+
+#include <efi_selftest.h>
+#include <efi_rng.h>
+
+#define RNG_LEN 9
+
+static struct efi_boot_services *boottime;
+static efi_guid_t efi_rng_guid = EFI_RNG_PROTOCOL_GUID;
+
+/*
+ * Setup unit test.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int setup(const efi_handle_t handle,
+		 const struct efi_system_table *systable)
+{
+	boottime = systable->boottime;
+	return EFI_ST_SUCCESS;
+}
+
+/*
+ * Execute unit test.
+ *
+ * Retrieve available RNG algorithms.
+ * Retrieve two random values and compare them.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int execute(void)
+{
+	efi_status_t ret;
+	efi_uintn_t size;
+	struct efi_rng_protocol *rng;
+	efi_guid_t *algo_list;
+	u8 rnd1[RNG_LEN] __aligned(4), rnd2[RNG_LEN] __aligned(4);
+	int r;
+
+	/* Get random number generator protocol */
+	ret = boottime->locate_protocol(&efi_rng_guid, NULL, (void **)&rng);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error(
+			"Random number generator protocol not available\n");
+		return EFI_ST_FAILURE;
+	}
+
+	ret = rng->get_info(rng, &size, NULL);
+	if (ret != EFI_BUFFER_TOO_SMALL) {
+		efi_st_error("Could not retrieve alorithm list size\n");
+		return EFI_ST_FAILURE;
+	}
+	if (size < sizeof(efi_guid_t)) {
+		efi_st_error("Empty alorithm list\n");
+		return EFI_ST_FAILURE;
+	}
+
+	ret = boottime->allocate_pool(EFI_LOADER_DATA, size,
+				      (void **)&algo_list);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not allocate pool memory\n");
+		return EFI_ST_FAILURE;
+	}
+
+	ret = rng->get_info(rng, &size, algo_list);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not get info\n");
+		return EFI_ST_FAILURE;
+	}
+	if (size < sizeof(efi_guid_t)) {
+		efi_st_error("Empty alorithm list\n");
+		return EFI_ST_FAILURE;
+	}
+
+	memset(rnd1, 0, RNG_LEN);
+	memset(rnd2, 0, RNG_LEN);
+
+	ret = rng->get_rng(rng, NULL, RNG_LEN - 1, &rnd1[1]);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not get random value\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = rng->get_rng(rng, NULL, RNG_LEN - 1, &rnd2[1]);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not get random value\n");
+		return EFI_ST_FAILURE;
+	}
+	r = memcmp(rnd1, rnd2, RNG_LEN);
+	if (!r) {
+		efi_st_error("Two equal consecutive random numbers\n");
+		return EFI_ST_FAILURE;
+	}
+
+	ret = boottime->free_pool(algo_list);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not free pool memory\n");
+		return EFI_ST_FAILURE;
+	}
+
+	return EFI_ST_SUCCESS;
+}
+
+EFI_UNIT_TEST(rng) = {
+	.name = "random number generator",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup,
+	.execute = execute,
+};
-- 
2.24.1

