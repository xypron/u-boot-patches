From ee018daf40a43f0ce956fc6884d5fd09b111da34 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 20 Jun 2019 22:00:02 +0000
Subject: [PATCH 1/1] efi_loader: clean up runtime detaching

The detaching of the runtime will have to move to ExitBootServices() to
encompass operating system that do not call SetVirtualAddressMap().

This patch changes the logic for the relocation of the pointers in the
runtime table such that the relocation becomes independent of the entries
in the detach list.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_runtime.c | 56 +++++++++++++++++++++++-------------
 1 file changed, 36 insertions(+), 20 deletions(-)

diff --git a/lib/efi_loader/efi_runtime.c b/lib/efi_loader/efi_runtime.c
index dd91880ad6..e1937316f2 100644
--- a/lib/efi_loader/efi_runtime.c
+++ b/lib/efi_loader/efi_runtime.c
@@ -436,29 +436,43 @@ static const struct efi_runtime_detach_list_struct efi_runtime_detach_list[] = {
 	}
 };
 
-static bool efi_runtime_tobedetached(void *p)
+/**
+ * efi_is_runtime_service_pointer() - check if pointer points to runtime table
+ *
+ * @p:		pointer to check
+ * Return:	true if the pointer points to a service function pointer in the
+ *		runtime table
+ */
+static bool efi_is_runtime_service_pointer(void *p)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(efi_runtime_detach_list); i++)
-		if (efi_runtime_detach_list[i].ptr == p)
-			return true;
-
-	return false;
+	return p >= (void *)&efi_runtime_services.get_time &&
+	       p <= (void *)&efi_runtime_services.query_variable_info;
 }
 
-static void efi_runtime_detach(ulong offset)
+static __efi_runtime void efi_runtime_detach(ulong offset)
 {
 	int i;
-	ulong patchoff = offset - (ulong)gd->relocaddr;
+	ulong patchoff;
+	void **pos;
 
+	/*
+	 * Replace boottime functions by runtime functions
+	 * TODO: move this step to ExitBootServices()
+	 */
 	for (i = 0; i < ARRAY_SIZE(efi_runtime_detach_list); i++) {
 		ulong patchto = (ulong)efi_runtime_detach_list[i].patchto;
 		ulong *p = efi_runtime_detach_list[i].ptr;
-		ulong newaddr = patchto ? (patchto + patchoff) : 0;
 
-		debug("%s: Setting %p to %lx\n", __func__, p, newaddr);
-		*p = newaddr;
+		debug("%s: Setting %p to %lx\n", __func__, p, patchto);
+		*p = patchto;
+	}
+
+	/* Relocate the runtime services pointers */
+	patchoff = offset - gd->relocaddr;
+	for (pos = (void **)&efi_runtime_services.get_time;
+	     pos <= (void **)&efi_runtime_services.query_variable_info; ++pos) {
+		if (*pos)
+			*pos += patchoff;
 	}
 
 	/* Update CRC32 */
@@ -483,6 +497,10 @@ void efi_runtime_relocate(ulong offset, struct efi_mem_desc *map)
 
 		p = (void*)((ulong)rel->offset - base) + gd->relocaddr;
 
+		/* The runtime services are updated in efi_runtime_detach() */
+		if (map && efi_is_runtime_service_pointer(p))
+			continue;
+
 		debug("%s: rel->info=%#lx *p=%#lx rel->offset=%p\n", __func__,
 		      rel->info, *p, rel->offset);
 
@@ -506,9 +524,8 @@ void efi_runtime_relocate(ulong offset, struct efi_mem_desc *map)
 		}
 #endif
 		default:
-			if (!efi_runtime_tobedetached(p))
-				printf("%s: Unknown relocation type %llx\n",
-				       __func__, rel->info & R_MASK);
+			printf("%s: Unknown relocation type %llx\n",
+			       __func__, rel->info & R_MASK);
 			continue;
 		}
 
@@ -516,9 +533,8 @@ void efi_runtime_relocate(ulong offset, struct efi_mem_desc *map)
 		if (map && ((newaddr < map->virtual_start) ||
 		    newaddr > (map->virtual_start +
 			      (map->num_pages << EFI_PAGE_SHIFT)))) {
-			if (!efi_runtime_tobedetached(p))
-				printf("%s: Relocation at %p is out of "
-				       "range (%lx)\n", __func__, p, newaddr);
+			printf("%s: Relocation at %p is out of "
+			       "range (%lx)\n", __func__, p, newaddr);
 			continue;
 		}
 
@@ -632,10 +648,10 @@ static efi_status_t EFIAPI efi_set_virtual_address_map(
 			ulong new_offset = map->virtual_start -
 					   map->physical_start + gd->relocaddr;
 
-			efi_runtime_relocate(new_offset, map);
 			/* Once we're virtual, we can no longer handle
 			   complex callbacks */
 			efi_runtime_detach(new_offset);
+			efi_runtime_relocate(new_offset, map);
 			return EFI_EXIT(EFI_SUCCESS);
 		}
 	}
-- 
2.20.1

