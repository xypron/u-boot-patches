From 9726e81469a2bbb1a4097e223cf6e49f85ea41c5 Mon Sep 17 00:00:00 2001
From: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date: Thu, 29 Oct 2020 13:47:53 +0900
Subject: [PATCH] efi_loader: add firmware management protocol for raw image

In this commit, a very simple firmware management protocol driver
is implemented. It will take a binary image in a capsule file and
apply the data using dfu backend storage drivers via dfu_write_by_alt()
interface.

So "dfu_alt_info" variable should be properly set to specify a device
and location to be updated. Please read README.dfu.

Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
---
 include/efi_api.h             |   4 +
 include/efi_loader.h          |   1 +
 lib/efi_loader/Kconfig        |  16 +++
 lib/efi_loader/Makefile       |   2 +-
 lib/efi_loader/efi_capsule.c  |   8 ++
 lib/efi_loader/efi_firmware.c | 226 +++++++++++++++++++++++++---------
 6 files changed, 199 insertions(+), 58 deletions(-)

diff --git a/include/efi_api.h b/include/efi_api.h
index 071d0ba866..c7038f863a 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -1853,6 +1853,10 @@ struct efi_signature_list {
 	EFI_GUID(0xae13ff2d, 0x9ad4, 0x4e25, 0x9a, 0xc8, \
 		 0x6d, 0x80, 0xb3, 0xb2, 0x21, 0x47)
 
+#define EFI_FIRMWARE_IMAGE_TYPE_UBOOT_RAW_GUID \
+	EFI_GUID(0xe2bb9c06, 0x70e9, 0x4b14, 0x97, 0xa3, \
+		 0x5a, 0x79, 0x13, 0x17, 0x6e, 0x3f)
+
 #define IMAGE_ATTRIBUTE_IMAGE_UPDATABLE		0x0000000000000001
 #define IMAGE_ATTRIBUTE_RESET_REQUIRED		0x0000000000000002
 #define IMAGE_ATTRIBUTE_AUTHENTICATION_REQUIRED	0x0000000000000004
diff --git a/include/efi_loader.h b/include/efi_loader.h
index de6d353de3..0f85873a72 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -812,6 +812,7 @@ void efi_memcpy_runtime(void *dest, const void *src, size_t n);
 u16 *efi_create_indexed_name(u16 *buffer, const u16 *name, unsigned int index);
 
 extern const struct efi_firmware_management_protocol efi_fmp_fit;
+extern const struct efi_firmware_management_protocol efi_fmp_raw;
 
 /* Capsule update */
 efi_status_t EFIAPI efi_update_capsule(
diff --git a/lib/efi_loader/Kconfig b/lib/efi_loader/Kconfig
index 94c1ad2af0..25b4ef1200 100644
--- a/lib/efi_loader/Kconfig
+++ b/lib/efi_loader/Kconfig
@@ -126,6 +126,10 @@ config EFI_CAPSULE_ON_DISK_EARLY
 	  executed as part of U-Boot initialisation so that they will
 	  surely take place whatever is set to distro_bootcmd.
 
+config EFI_CAPSULE_FIRMWARE
+	bool
+	default n
+
 config EFI_CAPSULE_FIRMWARE_MANAGEMENT
 	bool "Capsule: Firmware Management Protocol"
 	depends on EFI_HAVE_CAPSULE_SUPPORT
@@ -140,11 +144,23 @@ config EFI_CAPSULE_FIRMWARE_FIT
 	depends on FIT
 	select UPDATE_FIT
 	select DFU
+	select EFI_CAPSULE_FIRMWARE
 	default n
 	help
 	  Select this option if you want to enable firmware management protocol
 	  driver for FIT image
 
+config EFI_CAPSULE_FIRMWARE_RAW
+	bool "FMP driver for raw image"
+	depends on EFI_CAPSULE_FIRMWARE_MANAGEMENT
+	select DFU
+	select DFU_WRITE_ALT
+	select EFI_CAPSULE_FIRMWARE
+	default n
+	help
+	  Select this option if you want to enable firmware management protocol
+	  driver for raw image
+
 config EFI_DEVICE_PATH_TO_TEXT
 	bool "Device path to text protocol"
 	default y
diff --git a/lib/efi_loader/Makefile b/lib/efi_loader/Makefile
index 23b1828b0f..a7631d92a3 100644
--- a/lib/efi_loader/Makefile
+++ b/lib/efi_loader/Makefile
@@ -24,7 +24,7 @@ obj-$(CONFIG_CMD_BOOTEFI_HELLO) += helloworld_efi.o
 obj-y += efi_bootmgr.o
 obj-y += efi_boottime.o
 obj-$(CONFIG_EFI_HAVE_CAPSULE_SUPPORT) += efi_capsule.o
-obj-$(CONFIG_EFI_CAPSULE_FIRMWARE_FIT) += efi_firmware.o
+obj-$(CONFIG_EFI_CAPSULE_FIRMWARE) += efi_firmware.o
 obj-y += efi_console.o
 obj-y += efi_device_path.o
 obj-$(CONFIG_EFI_DEVICE_PATH_TO_TEXT) += efi_device_path_to_text.o
diff --git a/lib/efi_loader/efi_capsule.c b/lib/efi_loader/efi_capsule.c
index a44f81daae..af40b4a159 100644
--- a/lib/efi_loader/efi_capsule.c
+++ b/lib/efi_loader/efi_capsule.c
@@ -814,6 +814,14 @@ efi_status_t __weak arch_efi_load_capsule_drivers(void)
 				&efi_fmp_fit, NULL));
 	}
 
+	if (IS_ENABLED(CONFIG_EFI_CAPSULE_FIRMWARE_RAW)) {
+		handle = NULL;
+		ret = EFI_CALL(efi_install_multiple_protocol_interfaces(
+				&efi_root,
+				&efi_guid_firmware_management_protocol,
+				&efi_fmp_raw, NULL));
+	}
+
 	return ret;
 }
 
diff --git a/lib/efi_loader/efi_firmware.c b/lib/efi_loader/efi_firmware.c
index 4c395f4eb5..7e56077383 100644
--- a/lib/efi_loader/efi_firmware.c
+++ b/lib/efi_loader/efi_firmware.c
@@ -13,16 +13,66 @@
 #include <image.h>
 #include <linux/list.h>
 
-/*
- * This FIRMWARE_MANAGEMENT_PROTOCOL driver provides a firmware update
- * method with existing FIT image format, and handles
- *   - multiple regions of firmware via DFU
- * but doesn't support
- *   - versioning of firmware image
- *   - package information
- */
-const efi_guid_t efi_firmware_image_type_uboot_fit =
-	EFI_FIRMWARE_IMAGE_TYPE_UBOOT_FIT_GUID;
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_get_image_unsupported(
+	struct efi_firmware_management_protocol *this,
+	u8 image_index,
+	void *image,
+	efi_uintn_t *image_size)
+{
+	EFI_ENTRY("%p %d %p %p\n", this, image_index, image, image_size);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
+
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_check_image_unsupported(
+	struct efi_firmware_management_protocol *this,
+	u8 image_index,
+	const void *image,
+	efi_uintn_t *image_size,
+	u32 *image_updatable)
+{
+	EFI_ENTRY("%p %d %p %p %p\n", this, image_index, image, image_size,
+		  image_updatable);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
+
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_get_package_info_unsupported(
+	struct efi_firmware_management_protocol *this,
+	u32 *package_version,
+	u16 **package_version_name,
+	u32 *package_version_name_maxlen,
+	u64 *attributes_supported,
+	u64 *attributes_setting)
+{
+	EFI_ENTRY("%p %p %p %p %p %p\n", this, package_version,
+		  package_version_name, package_version_name_maxlen,
+		  attributes_supported, attributes_setting);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
+
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_set_package_info_unsupported(
+	struct efi_firmware_management_protocol *this,
+	const void *image,
+	efi_uintn_t *image_size,
+	const void *vendor_code,
+	u32 package_version,
+	const u16 *package_version_name)
+{
+	EFI_ENTRY("%p %p %p %p %x %p\n", this, image, image_size, vendor_code,
+		  package_version, package_version_name);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
 
 /**
  * efi_get_dfu_info - return information about the current firmware image
@@ -129,6 +179,18 @@ static efi_status_t efi_get_dfu_info(
 	return EFI_SUCCESS;
 }
 
+#ifdef CONFIG_EFI_CAPSULE_FIRMWARE_FIT
+/*
+ * This FIRMWARE_MANAGEMENT_PROTOCOL driver provides a firmware update
+ * method with existing FIT image format, and handles
+ *   - multiple regions of firmware via DFU
+ * but doesn't support
+ *   - versioning of firmware image
+ *   - package information
+ */
+const efi_guid_t efi_firmware_image_type_uboot_fit =
+	EFI_FIRMWARE_IMAGE_TYPE_UBOOT_FIT_GUID;
+
 /**
  * efi_firmware_fit_get_image_info - return information about the current
  *				     firmware image
@@ -182,19 +244,6 @@ efi_status_t EFIAPI efi_firmware_fit_get_image_info(
 	return EFI_EXIT(ret);
 }
 
-/* Place holder; not supported */
-static
-efi_status_t EFIAPI efi_firmware_get_image_unsupported(
-	struct efi_firmware_management_protocol *this,
-	u8 image_index,
-	void *image,
-	efi_uintn_t *image_size)
-{
-	EFI_ENTRY("%p %d %p %p\n", this, image_index, image, image_size);
-
-	return EFI_EXIT(EFI_UNSUPPORTED);
-}
-
 /**
  * efi_firmware_fit_set_image - update the firmware image
  * @this:		Protocol instance
@@ -233,59 +282,122 @@ efi_status_t EFIAPI efi_firmware_fit_set_image(
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
-/* Place holder; not supported */
-static
-efi_status_t EFIAPI efi_firmware_check_image_unsupported(
-	struct efi_firmware_management_protocol *this,
-	u8 image_index,
-	const void *image,
-	efi_uintn_t *image_size,
-	u32 *image_updatable)
-{
-	EFI_ENTRY("%p %d %p %p %p\n", this, image_index, image, image_size,
-		  image_updatable);
+const struct efi_firmware_management_protocol efi_fmp_fit = {
+	.get_image_info = efi_firmware_fit_get_image_info,
+	.get_image = efi_firmware_get_image_unsupported,
+	.set_image = efi_firmware_fit_set_image,
+	.check_image = efi_firmware_check_image_unsupported,
+	.get_package_info = efi_firmware_get_package_info_unsupported,
+	.set_package_info = efi_firmware_set_package_info_unsupported,
+};
+#endif /* CONFIG_EFI_CAPSULE_FIRMWARE_FIT */
 
-	return EFI_EXIT(EFI_UNSUPPORTED);
-}
+#ifdef CONFIG_EFI_CAPSULE_FIRMWARE_RAW
+/*
+ * This FIRMWARE_MANAGEMENT_PROTOCOL driver provides a firmware update
+ * method with raw data.
+ */
+const efi_guid_t efi_firmware_image_type_uboot_raw =
+	EFI_FIRMWARE_IMAGE_TYPE_UBOOT_RAW_GUID;
 
-/* Place holder; not supported */
+/**
+ * efi_firmware_raw_get_image_info - return information about the current
+				     firmware image
+ * @this:			Protocol instance
+ * @image_info_size:		Size of @image_info
+ * @image_info:			Image information
+ * @descriptor_version:		Pointer to version number
+ * @descriptor_count:		Pointer to number of descriptors
+ * @descriptor_size:		Pointer to descriptor size
+ * package_version:		Package version
+ * package_version_name:	Package version's name
+ *
+ * Return information bout the current firmware image in @image_info.
+ * @image_info will consist of a number of descriptors.
+ * Each descriptor will be created based on "dfu_alt_info" variable.
+ *
+ * Return		status code
+ */
 static
-efi_status_t EFIAPI efi_firmware_get_package_info_unsupported(
+efi_status_t EFIAPI efi_firmware_raw_get_image_info(
 	struct efi_firmware_management_protocol *this,
+	efi_uintn_t *image_info_size,
+	struct efi_firmware_image_descriptor *image_info,
+	u32 *descriptor_version,
+	u8 *descriptor_count,
+	efi_uintn_t *descriptor_size,
 	u32 *package_version,
-	u16 **package_version_name,
-	u32 *package_version_name_maxlen,
-	u64 *attributes_supported,
-	u64 *attributes_setting)
+	u16 **package_version_name)
 {
-	EFI_ENTRY("%p %p %p %p %p %p\n", this, package_version,
-		  package_version_name, package_version_name_maxlen,
-		  attributes_supported, attributes_setting);
+	efi_status_t ret = EFI_SUCCESS;
 
-	return EFI_EXIT(EFI_UNSUPPORTED);
+	EFI_ENTRY("%p %p %p %p %p %p %p %p\n", this,
+		  image_info_size, image_info,
+		  descriptor_version, descriptor_count, descriptor_size,
+		  package_version, package_version_name);
+
+	if (!image_info_size)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	if (*image_info_size &&
+	    (!image_info || !descriptor_version || !descriptor_count ||
+	     !descriptor_size || !package_version || !package_version_name))
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	ret = efi_get_dfu_info(image_info_size, image_info,
+			       descriptor_version, descriptor_count,
+			       descriptor_size,
+			       package_version, package_version_name,
+			       &efi_firmware_image_type_uboot_raw);
+
+	return EFI_EXIT(ret);
 }
 
-/* Place holder; not supported */
+/**
+ * efi_firmware_raw_set_image - update the firmware image
+ * @this:		Protocol instance
+ * @image_index:	Image index number
+ * @image:		New image
+ * @image_size:		Size of new image
+ * @vendor_code:	Vendor-specific update policy
+ * @progress:		Function to report the progress of update
+ * @abort_reason:	Pointer to string of abort reason
+ *
+ * Update the firmware to new image, using dfu. The new image should
+ * be a single raw image.
+ * @vendor_code, @progress and @abort_reason are not supported.
+ *
+ * Return:		status code
+ */
 static
-efi_status_t EFIAPI efi_firmware_set_package_info_unsupported(
+efi_status_t EFIAPI efi_firmware_raw_set_image(
 	struct efi_firmware_management_protocol *this,
+	u8 image_index,
 	const void *image,
-	efi_uintn_t *image_size,
+	efi_uintn_t image_size,
 	const void *vendor_code,
-	u32 package_version,
-	const u16 *package_version_name)
+	efi_status_t (*progress)(efi_uintn_t completion),
+	u16 **abort_reason)
 {
-	EFI_ENTRY("%p %p %p %p %x %p\n", this, image, image_size, vendor_code,
-		  package_version, package_version_name);
+	EFI_ENTRY("%p %d %p %ld %p %p %p\n", this, image_index, image,
+		  image_size, vendor_code, progress, abort_reason);
 
-	return EFI_EXIT(EFI_UNSUPPORTED);
+	if (!image)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	if (dfu_write_by_alt(image_index - 1, (void *)image, image_size,
+			     NULL, NULL))
+		return EFI_EXIT(EFI_DEVICE_ERROR);
+
+	return EFI_EXIT(EFI_SUCCESS);
 }
 
-const struct efi_firmware_management_protocol efi_fmp_fit = {
-	.get_image_info = efi_firmware_fit_get_image_info,
+const struct efi_firmware_management_protocol efi_fmp_raw = {
+	.get_image_info = efi_firmware_raw_get_image_info,
 	.get_image = efi_firmware_get_image_unsupported,
-	.set_image = efi_firmware_fit_set_image,
+	.set_image = efi_firmware_raw_set_image,
 	.check_image = efi_firmware_check_image_unsupported,
 	.get_package_info = efi_firmware_get_package_info_unsupported,
 	.set_package_info = efi_firmware_set_package_info_unsupported,
 };
+#endif /* CONFIG_EFI_CAPSULE_FIRMWARE_RAW */
-- 
2.28.0

