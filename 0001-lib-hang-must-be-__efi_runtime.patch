From 501b40c124eb94e944589b0f87d8bc7e56db5c8b Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 8 Aug 2020 17:08:01 +0200
Subject: [PATCH 1/1] lib: hang() must be __efi_runtime

On RISC-V we use hang() to stop all harts except the boot hart. The loop in
which these harts run must not be overwritten by the UEFI payload after
BootExit().

Extract the endless loop into a function hang_no_msg() which we define as
__efi_runtime. Use it when preparing to call OpenSBI.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 common/spl/spl_opensbi.c |  2 +-
 include/hang.h           | 10 ++++++++++
 lib/hang.c               | 10 ++++++++--
 3 files changed, 19 insertions(+), 3 deletions(-)

diff --git a/common/spl/spl_opensbi.c b/common/spl/spl_opensbi.c
index 14f335f75f0..dc129c194e6 100644
--- a/common/spl/spl_opensbi.c
+++ b/common/spl/spl_opensbi.c
@@ -93,7 +93,7 @@ void spl_invoke_opensbi(struct spl_image_info *spl_image)
 				(ulong)spl_image->fdt_addr,
 				(ulong)&opensbi_info, 1);
 	if (ret)
-		hang();
+		hang_no_msg();
 #endif
 	opensbi_entry(gd->arch.boot_hart, (ulong)spl_image->fdt_addr,
 		      (ulong)&opensbi_info);
diff --git a/include/hang.h b/include/hang.h
index 27cda493592..7a92f809164 100644
--- a/include/hang.h
+++ b/include/hang.h
@@ -17,6 +17,16 @@
  * This function does not return.
  */
 void hang(void) __attribute__ ((noreturn));
+
+/**
+ * hang_no_msg() - stop executions
+ *
+ * This function provides an infinite loop. It is located in the __efi_runtime
+ * section to allow usage for letting secondary cores/harts wait until the
+ * UEFI payload takes care of them.
+ */
+void hang_no_msg(void) __attribute__ ((noreturn));
+
 #endif
 
 #endif
diff --git a/lib/hang.c b/lib/hang.c
index 578ac78d453..d131ce7cec9 100644
--- a/lib/hang.c
+++ b/lib/hang.c
@@ -9,9 +9,16 @@
 
 #include <common.h>
 #include <bootstage.h>
+#include <efi_loader.h>
 #include <hang.h>
 #include <os.h>
 
+__efi_runtime void hang_no_msg(void)
+{
+	for(;;)
+		;
+}
+
 /**
  * hang - stop processing by staying in an endless loop
  *
@@ -30,6 +37,5 @@ void hang(void)
 	bootstage_error(BOOTSTAGE_ID_NEED_RESET);
 	if (IS_ENABLED(CONFIG_SANDBOX))
 		os_exit(1);
-	for (;;)
-		;
+	hang_no_msg();
 }
-- 
2.20.1

