From 2c9e5efb666462778d5379610730b273b8655c59 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 8 Dec 2019 01:07:01 +0100
Subject: [PATCH 1/1] efi_loader: export efi_install_fdt()

Use a pointer to addressable memory instead of a "physical" address in the
virtual address space of the sandbox to efi_install_fdt().

Export the efi_install_fdt() function.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c        | 24 ++++++++++++++----------
 include/efi_loader.h |  4 +++-
 2 files changed, 17 insertions(+), 11 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 15b4ff9515..78c8b8dbd1 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -212,24 +212,24 @@ static void *get_config_table(const efi_guid_t *guid)
  *		the environment variable fdtcontroladdr
  * Return:	status code
  */
-static efi_status_t efi_install_fdt(uintptr_t fdt_addr)
+efi_status_t efi_install_fdt(void *fdt)
 {
 	/*
 	 * The EBBR spec requires that we have either an FDT or an ACPI table
 	 * but not both.
 	 */
 #if CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE)
-	if (fdt_addr) {
+	if (fdt) {
 		printf("ERROR: can't have ACPI table and device tree.\n");
 		return EFI_LOAD_ERROR;
 	}
 #else
-	void *fdt;
 	bootm_headers_t img = { 0 };
 	efi_status_t ret;
 
-	if (fdt_addr == EFI_FDT_USE_INTERNAL) {
+	if (fdt == EFI_FDT_USE_INTERNAL) {
 		const char *fdt_opt;
+		uintptr_t fdt_addr;
 
 		/* Look for device tree that is already installed */
 		if (get_config_table(&efi_guid_fdt))
@@ -249,10 +249,10 @@ static efi_status_t efi_install_fdt(uintptr_t fdt_addr)
 			printf("ERROR: invalid $fdt_addr or $fdtcontroladdr\n");
 			return EFI_LOAD_ERROR;
 		}
+		fdt = map_sysmem(fdt_addr, 0);
 	}
 
 	/* Install device tree */
-	fdt = map_sysmem(fdt_addr, 0);
 	if (fdt_check_header(fdt)) {
 		printf("ERROR: invalid device tree\n");
 		return EFI_LOAD_ERROR;
@@ -574,7 +574,7 @@ static int do_efi_selftest(void)
 static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	efi_status_t ret;
-	uintptr_t fdt_addr;
+	void *fdt;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
@@ -587,11 +587,15 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		return CMD_RET_FAILURE;
 	}
 
-	if (argc > 2)
+	if (argc > 2) {
+		uintptr_t fdt_addr;
+
 		fdt_addr = simple_strtoul(argv[2], NULL, 16);
-	else
-		fdt_addr = EFI_FDT_USE_INTERNAL;
-	ret = efi_install_fdt(fdt_addr);
+		fdt = map_sysmem(fdt_addr, 0);
+	} else {
+		fdt = EFI_FDT_USE_INTERNAL;
+	}
+	ret = efi_install_fdt(fdt);
 	if (ret == EFI_INVALID_PARAMETER)
 		return CMD_RET_USAGE;
 	else if (ret != EFI_SUCCESS)
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 1e1fe52bc0..4d401f69d7 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -35,7 +35,7 @@ static inline int guidcmp(const void *g1, const void *g2)
 		 0x9a, 0xab, 0x3a, 0x7d, 0xbf, 0x40, 0xc4, 0x82)
 
 /* Use internal device tree when starting UEFI application */
-#define EFI_FDT_USE_INTERNAL 0UL
+#define EFI_FDT_USE_INTERNAL NULL
 
 /* Root node */
 extern efi_handle_t efi_root;
@@ -341,6 +341,8 @@ extern struct list_head efi_register_notify_events;
 
 /* Initialize efi execution environment */
 efi_status_t efi_init_obj_list(void);
+/* Install device tree */
+efi_status_t efi_install_fdt(void *fdt);
 /* Run loaded UEFI image */
 efi_status_t efi_run_image(void *source_buffer, efi_uintn_t source_size);
 /* Initialize variable services */
-- 
2.24.0

