From 20c7d2a27f8895890c1f34cf3476ecf7d031dbea Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 20 Apr 2019 13:33:55 +0200
Subject: [PATCH 1/1] efi_loader: need either ACPI table or device tree

The EBBR specification prescribes that we should have either an ACPI table
or a device tree but not both. Let us enforce this condition in the
`bootefi` command.

If the bootefi command is called without a device tree parameter use a
previously device tree or fall back to the internal device tree.

Make efi_acpi_table_guid a global variable.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c             | 104 +++++++++++++++++++++++++++-----------
 include/efi_loader.h      |   2 +
 lib/efi_loader/efi_acpi.c |   4 +-
 3 files changed, 79 insertions(+), 31 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index c406ac5d81..666392f69a 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -185,6 +185,23 @@ static void efi_carve_out_dt_rsv(void *fdt)
 	}
 }
 
+/**
+ * get_config_table() - get configuration table
+ *
+ * @guid:	GUID of the configuration table
+ * Return:	pointer to configuration table or NULL
+ */
+static void *get_config_table(const efi_guid_t *guid)
+{
+	size_t i;
+
+	for (i = 0; i < systab.nr_tables; i++) {
+		if (!guidcmp(guid, &systab.tables[i].guid))
+			return systab.tables[i].table;
+	}
+	return NULL;
+}
+
 /**
  * efi_install_fdt() - install fdt passed by a command argument
  * @fdt_opt:	pointer to argument
@@ -200,40 +217,69 @@ static efi_status_t efi_install_fdt(const char *fdt_opt)
 	bootm_headers_t img = { 0 };
 	efi_status_t ret;
 
-	if (fdt_opt) {
-		/* Install device tree */
-		fdt_addr = simple_strtoul(fdt_opt, NULL, 16);
-		if (!fdt_addr && *fdt_opt != '0')
-			return EFI_INVALID_PARAMETER;
-
-		fdt = map_sysmem(fdt_addr, 0);
-		if (fdt_check_header(fdt)) {
-			printf("ERROR: invalid device tree\n");
-			return EFI_INVALID_PARAMETER;
+	/*
+	 * The EBBR spec requires that we have either an FDT or an ACPI table
+	 * but not both.
+	 */
+	if (get_config_table(&efi_acpi_table_guid)) {
+		if (fdt_opt) {
+			printf("ERROR: can't have ACPI table and device tree.\n"
+			       );
+			return EFI_LOAD_ERROR;
+		}
+		/* Remove device tree, expected to fail. */
+		efi_install_configuration_table(&efi_guid_fdt, NULL);
+		return EFI_SUCCESS;
+	} else {
+		if (fdt_opt) {
+			fdt_addr = simple_strtoul(fdt_opt, NULL, 16);
+			if (!fdt_addr)
+				return EFI_INVALID_PARAMETER;
+		} else {
+			/* Look for device tree that is already installed */
+			if (get_config_table(&efi_guid_fdt))
+				return EFI_SUCCESS;
+			/* Use our own device tree as default */
+			fdt_opt = env_get("fdtcontroladdr");
+			if (!fdt_opt) {
+				printf("ERROR: need device tree\n");
+				return EFI_NOT_FOUND;
+			}
+			fdt_addr = simple_strtoul(fdt_opt, NULL, 16);
+			if (!fdt_addr) {
+				printf("ERROR: invalid $fdtcontroladdr\n");
+				return EFI_LOAD_ERROR;
+			}
 		}
+	}
 
-		/* Create memory reservation as indicated by the device tree */
-		efi_carve_out_dt_rsv(fdt);
+	/* Install device tree */
+	fdt = map_sysmem(fdt_addr, 0);
+	if (fdt_check_header(fdt)) {
+		printf("ERROR: invalid device tree\n");
+		return EFI_LOAD_ERROR;
+	}
 
-		/* Prepare fdt for payload */
-		ret = copy_fdt(&fdt);
-		if (ret)
-			return ret;
+	/* Create memory reservations as indicated by the device tree */
+	efi_carve_out_dt_rsv(fdt);
 
-		if (image_setup_libfdt(&img, fdt, 0, NULL)) {
-			printf("ERROR: failed to process device tree\n");
-			return EFI_LOAD_ERROR;
-		}
+	/* Prepare device tree for payload */
+	ret = copy_fdt(&fdt);
+	if (ret) {
+		printf("ERROR: out of memory\n");
+		return EFI_OUT_OF_RESOURCES;
+	}
 
-		/* Link to it in the efi tables */
-		ret = efi_install_configuration_table(&efi_guid_fdt, fdt);
-		if (ret != EFI_SUCCESS) {
-			printf("ERROR: failed to install device tree\n");
-			return ret;
-		}
-	} else {
-		/* Remove device tree. EFI_NOT_FOUND can be ignored here */
-		efi_install_configuration_table(&efi_guid_fdt, NULL);
+	if (image_setup_libfdt(&img, fdt, 0, NULL)) {
+		printf("ERROR: failed to process device tree\n");
+		return EFI_LOAD_ERROR;
+	}
+
+	/* Install device tree as UEFI table */
+	ret = efi_install_configuration_table(&efi_guid_fdt, fdt);
+	if (ret != EFI_SUCCESS) {
+		printf("ERROR: failed to install device tree\n");
+		return ret;
 	}
 
 	return EFI_SUCCESS;
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 39ed8a6fa5..63b34c84dc 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -135,6 +135,8 @@ extern const efi_guid_t efi_guid_event_group_memory_map_change;
 extern const efi_guid_t efi_guid_event_group_ready_to_boot;
 /* event group ResetSystem() invoked (before ExitBootServices) */
 extern const efi_guid_t efi_guid_event_group_reset_system;
+/* GUID of the ACPI table */
+extern const efi_guid_t efi_acpi_table_guid;
 /* GUID of the device tree table */
 extern const efi_guid_t efi_guid_fdt;
 extern const efi_guid_t efi_guid_loaded_image;
diff --git a/lib/efi_loader/efi_acpi.c b/lib/efi_loader/efi_acpi.c
index a4e5e53d15..0ccbb22230 100644
--- a/lib/efi_loader/efi_acpi.c
+++ b/lib/efi_loader/efi_acpi.c
@@ -9,7 +9,7 @@
 #include <efi_loader.h>
 #include <asm/acpi_table.h>
 
-static const efi_guid_t acpi_guid = EFI_ACPI_TABLE_GUID;
+const efi_guid_t efi_acpi_table_guid = EFI_ACPI_TABLE_GUID;
 
 /*
  * Install the ACPI table as a configuration table.
@@ -37,6 +37,6 @@ efi_status_t efi_acpi_register(void)
 	write_acpi_tables(acpi);
 
 	/* And expose them to our EFI payload */
-	return efi_install_configuration_table(&acpi_guid,
+	return efi_install_configuration_table(&efi_acpi_table_guid,
 					       (void *)(uintptr_t)acpi);
 }
-- 
2.20.1

