From 6be3e45caa10ebb2f196fb85a32a7b6c385f20e2 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 20 Apr 2019 13:33:55 +0200
Subject: [PATCH v3 1/1] efi_loader: need either ACPI table or device tree

The EBBR specification prescribes that we should have either an ACPI table
or a device tree but not both. Let us enforce this condition in the
`bootefi` command.

If the bootefi command is called without a device tree parameter use a
previously device tree or fall back to the internal device tree.

The fdt unit test should not be run on boards with an ACPI table.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v3
	Adjust unit test.
v2
	Avoid functions defined but no used.
---
 cmd/bootefi.c                       | 98 +++++++++++++++++++++--------
 lib/efi_selftest/Makefile           |  4 ++
 lib/efi_selftest/efi_selftest_fdt.c | 39 +++++++++---
 3 files changed, 105 insertions(+), 36 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index d62e9969ac..6cac37d7dc 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -84,6 +84,8 @@ out:
 							efi_root, NULL));
 }
 
+#if !CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE)
+
 /**
  * copy_fdt() - Copy the device tree to a new location available to EFI
  *
@@ -185,6 +187,25 @@ static void efi_carve_out_dt_rsv(void *fdt)
 	}
 }
 
+/**
+ * get_config_table() - get configuration table
+ *
+ * @guid:	GUID of the configuration table
+ * Return:	pointer to configuration table or NULL
+ */
+static void *get_config_table(const efi_guid_t *guid)
+{
+	size_t i;
+
+	for (i = 0; i < systab.nr_tables; i++) {
+		if (!guidcmp(guid, &systab.tables[i].guid))
+			return systab.tables[i].table;
+	}
+	return NULL;
+}
+
+#endif /* !CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE) */
+
 /**
  * efi_install_fdt() - install fdt passed by a command argument
  * @fdt_opt:	pointer to argument
@@ -195,46 +216,71 @@ static void efi_carve_out_dt_rsv(void *fdt)
  */
 static efi_status_t efi_install_fdt(const char *fdt_opt)
 {
+	/*
+	 * The EBBR spec requires that we have either an FDT or an ACPI table
+	 * but not both.
+	 */
+#if CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE)
+	if (fdt_opt) {
+		printf("ERROR: can't have ACPI table and device tree.\n");
+		return EFI_LOAD_ERROR;
+	}
+#else
 	unsigned long fdt_addr;
 	void *fdt;
 	bootm_headers_t img = { 0 };
 	efi_status_t ret;
 
 	if (fdt_opt) {
-		/* Install device tree */
 		fdt_addr = simple_strtoul(fdt_opt, NULL, 16);
-		if (!fdt_addr && *fdt_opt != '0')
-			return EFI_INVALID_PARAMETER;
-
-		fdt = map_sysmem(fdt_addr, 0);
-		if (fdt_check_header(fdt)) {
-			printf("ERROR: invalid device tree\n");
+		if (!fdt_addr)
 			return EFI_INVALID_PARAMETER;
+	} else {
+		/* Look for device tree that is already installed */
+		if (get_config_table(&efi_guid_fdt))
+			return EFI_SUCCESS;
+		/* Use our own device tree as default */
+		fdt_opt = env_get("fdtcontroladdr");
+		if (!fdt_opt) {
+			printf("ERROR: need device tree\n");
+			return EFI_NOT_FOUND;
 		}
+		fdt_addr = simple_strtoul(fdt_opt, NULL, 16);
+		if (!fdt_addr) {
+			printf("ERROR: invalid $fdtcontroladdr\n");
+			return EFI_LOAD_ERROR;
+		}
+	}
 
-		/* Create memory reservation as indicated by the device tree */
-		efi_carve_out_dt_rsv(fdt);
+	/* Install device tree */
+	fdt = map_sysmem(fdt_addr, 0);
+	if (fdt_check_header(fdt)) {
+		printf("ERROR: invalid device tree\n");
+		return EFI_LOAD_ERROR;
+	}
 
-		/* Prepare fdt for payload */
-		ret = copy_fdt(&fdt);
-		if (ret)
-			return ret;
+	/* Create memory reservations as indicated by the device tree */
+	efi_carve_out_dt_rsv(fdt);
 
-		if (image_setup_libfdt(&img, fdt, 0, NULL)) {
-			printf("ERROR: failed to process device tree\n");
-			return EFI_LOAD_ERROR;
-		}
+	/* Prepare device tree for payload */
+	ret = copy_fdt(&fdt);
+	if (ret) {
+		printf("ERROR: out of memory\n");
+		return EFI_OUT_OF_RESOURCES;
+	}
 
-		/* Link to it in the efi tables */
-		ret = efi_install_configuration_table(&efi_guid_fdt, fdt);
-		if (ret != EFI_SUCCESS) {
-			printf("ERROR: failed to install device tree\n");
-			return ret;
-		}
-	} else {
-		/* Remove device tree. EFI_NOT_FOUND can be ignored here */
-		efi_install_configuration_table(&efi_guid_fdt, NULL);
+	if (image_setup_libfdt(&img, fdt, 0, NULL)) {
+		printf("ERROR: failed to process device tree\n");
+		return EFI_LOAD_ERROR;
+	}
+
+	/* Install device tree as UEFI table */
+	ret = efi_install_configuration_table(&efi_guid_fdt, fdt);
+	if (ret != EFI_SUCCESS) {
+		printf("ERROR: failed to install device tree\n");
+		return ret;
 	}
+#endif /* GENERATE_ACPI_TABLE */
 
 	return EFI_SUCCESS;
 }
diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index c9720c9da8..fb82e71976 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -42,6 +42,10 @@ efi_selftest_watchdog.o
 obj-$(CONFIG_CPU_V7) += efi_selftest_unaligned.o
 obj-$(CONFIG_EFI_LOADER_HII) += efi_selftest_hii.o
 
+ifeq ($(CONFIG_GENERATE_ACPI_TABLE),)
+obj-y += efi_selftest_fdt.o
+endif
+
 ifeq ($(CONFIG_BLK)$(CONFIG_PARTITIONS),yy)
 obj-y += efi_selftest_block_device.o
 endif
diff --git a/lib/efi_selftest/efi_selftest_fdt.c b/lib/efi_selftest/efi_selftest_fdt.c
index d545d51812..be0d7d34a0 100644
--- a/lib/efi_selftest/efi_selftest_fdt.c
+++ b/lib/efi_selftest/efi_selftest_fdt.c
@@ -13,13 +13,15 @@
 #include <efi_selftest.h>
 #include <linux/libfdt.h>
 
-static struct efi_boot_services *boottime;
+static const struct efi_system_table *systemtab;
+static const struct efi_boot_services *boottime;
 static const char *fdt;
 
 /* This should be sufficient for */
 #define BUFFERSIZE 0x100000
 
-static efi_guid_t fdt_guid = EFI_FDT_GUID;
+static const efi_guid_t fdt_guid = EFI_FDT_GUID;
+static const efi_guid_t acpi_guid = EFI_ACPI_TABLE_GUID;
 
 /*
  * Convert FDT value to host endianness.
@@ -115,6 +117,23 @@ static char *get_property(const u16 *property)
 	}
 }
 
+/**
+ * efi_st_get_config_table() - get configuration table
+ *
+ * @guid:	GUID of the configuration table
+ * Return:	pointer to configuration table or NULL
+ */
+static void *efi_st_get_config_table(const efi_guid_t *guid)
+{
+	size_t i;
+
+	for (i = 0; i < systab.nr_tables; i++) {
+		if (!guidcmp(guid, &systemtab->tables[i].guid))
+			return systemtab->tables[i].table;
+	}
+	return NULL;
+}
+
 /*
  * Setup unit test.
  *
@@ -125,21 +144,21 @@ static char *get_property(const u16 *property)
 static int setup(const efi_handle_t img_handle,
 		 const struct efi_system_table *systable)
 {
-	efi_uintn_t i;
+	void *acpi = efi_st_get_config_table(&acpi_guid);
+
+	fdt = efi_st_get_config_table(&fdt_guid);
 
+	systemtab = systable;
 	boottime = systable->boottime;
 
-	/* Find configuration tables */
-	for (i = 0; i < systable->nr_tables; ++i) {
-		if (!efi_st_memcmp(&systable->tables[i].guid, &fdt_guid,
-				   sizeof(efi_guid_t)))
-			fdt = systable->tables[i].table;
-	}
 	if (!fdt) {
 		efi_st_error("Missing device tree\n");
 		return EFI_ST_FAILURE;
 	}
-
+	if (acpi) {
+		efi_st_error("Found ACPI table and device tree\n");
+		return EFI_ST_FAILURE;
+	}
 	return EFI_ST_SUCCESS;
 }
 
-- 
2.20.1

