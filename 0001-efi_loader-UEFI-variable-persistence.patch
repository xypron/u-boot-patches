From 70c8dd91824b7723209526a0382b65f499759bed Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 19 Mar 2020 18:21:58 +0000
Subject: [PATCH 1/1] efi_loader: UEFI variable persistence

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h                |   2 +
 lib/efi_loader/Makefile             |   1 +
 lib/efi_loader/efi_boottime.c       |   3 +
 lib/efi_loader/efi_variables_file.c | 180 ++++++++++++++++++++++++++++
 4 files changed, 186 insertions(+)
 create mode 100644 lib/efi_loader/efi_variables_file.c

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 029a5ec2b8..4c7a43f214 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -647,6 +647,8 @@ efi_status_t EFIAPI efi_selftest(efi_handle_t image_handle,
 				 struct efi_system_table *systab);
 #endif
 
+efi_status_t efi_var_to_file(void);
+efi_status_t efi_var_from_file(void);
 efi_status_t EFIAPI efi_get_variable(u16 *variable_name,
 				     const efi_guid_t *vendor, u32 *attributes,
 				     efi_uintn_t *data_size, void *data);
diff --git a/lib/efi_loader/Makefile b/lib/efi_loader/Makefile
index 9b3b704473..621a767ab3 100644
--- a/lib/efi_loader/Makefile
+++ b/lib/efi_loader/Makefile
@@ -35,6 +35,7 @@ obj-y += efi_runtime.o
 obj-y += efi_setup.o
 obj-$(CONFIG_EFI_UNICODE_COLLATION_PROTOCOL2) += efi_unicode_collation.o
 obj-y += efi_variable.o
+obj-y += efi_variables_file.o
 obj-y += efi_watchdog.o
 obj-$(CONFIG_LCD) += efi_gop.o
 obj-$(CONFIG_DM_VIDEO) += efi_gop.o
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 3b79a88a48..cf940ea392 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -1992,6 +1992,9 @@ static efi_status_t EFIAPI efi_exit_boot_services(efi_handle_t image_handle,
 	/* Patch out unsupported runtime function */
 	efi_runtime_detach();
 
+	/* Write non-volatile EFI variables to file */
+	efi_var_to_file();
+
 	/* Fix up caches for EFI payloads if necessary */
 	efi_exit_caches();
 
diff --git a/lib/efi_loader/efi_variables_file.c b/lib/efi_loader/efi_variables_file.c
new file mode 100644
index 0000000000..3534c81e1b
--- /dev/null
+++ b/lib/efi_loader/efi_variables_file.c
@@ -0,0 +1,180 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * File interface for UEFI variables
+ *
+ * Copyright (c) 2020, Heinrich Schuchardt
+ */
+
+#include <common.h>
+#include <charset.h>
+#include <fs.h>
+#include <malloc.h>
+#include <mapmem.h>
+#include <efi_loader.h>
+#include <u-boot/crc.h>
+
+struct efi_var_entry {
+	u32 len;
+	u32 attr;
+	efi_guid_t guid;
+	u16 var_name[0];
+};
+
+struct efi_var_file {
+	u64 reserved; /* May be overwritten by memory probing */
+	u64 magic;
+	u32 length;
+	u32 crc32;
+	struct efi_var_entry var[0];
+};
+
+#define EFI_VAR_FILE_MAGIC 0x7261566966456255
+
+#define PART_STR_LEN 10
+
+static efi_status_t efi_set_blk_dev_to_system_partition(void)
+{
+	char part_str[PART_STR_LEN];
+	int r;
+
+	if (!efi_system_partition.if_type)
+		return EFI_NOT_FOUND;
+	snprintf(part_str, PART_STR_LEN, "%u:%u",
+		 efi_system_partition.devnum, efi_system_partition.part);
+	r = fs_set_blk_dev(blk_get_if_type_name(efi_system_partition.if_type),
+			   part_str, FS_TYPE_ANY);
+	if (r) {
+		printf("Cannot read EFI system partition\n");
+		return EFI_DEVICE_ERROR;
+	}
+	return EFI_SUCCESS;
+}
+
+static efi_status_t efi_var_collect(struct efi_var_file **bufp, loff_t *lenp)
+{
+	size_t len = 0x32;
+	struct efi_var_file *buf, *old_buf;
+	struct efi_var_entry *var, *old_var;;
+
+	*bufp = NULL; /* Avoid double free() */
+	buf = malloc(len);
+	if (!buf)
+		return EFI_OUT_OF_RESOURCES;
+	buf->magic = EFI_VAR_FILE_MAGIC;
+	buf->length = len;
+	var = buf->var;
+	old_var = var;
+	for (;;) {
+		efi_uintn_t nlen, vlen;
+		u16 *data;
+		efi_status_t ret;
+		size_t offset;
+
+		vlen = (u8 *)buf + len - (u8 *)var->var_name;
+		memset(var->var_name, 0, vlen);
+		nlen = 2 + 2 * u16_strlen(old_var->var_name);
+		if (vlen >= nlen) {
+			memcpy(var->var_name, old_var->var_name, nlen);
+			guidcpy(&var->guid, &old_var->guid);
+			ret = efi_get_next_variable_name_int(
+					&vlen, var->var_name, &var->guid);
+			if (ret == EFI_NOT_FOUND) {
+				memset(var, 0, sizeof(var));
+				len = (u8 *)&var->len - (u8 *)buf + sizeof(var);
+				break;
+			}
+		} else {
+			vlen = nlen;
+			ret = EFI_BUFFER_TOO_SMALL;
+		}
+		if (ret == EFI_BUFFER_TOO_SMALL) {
+			len = (u8 *)var->var_name + vlen - (u8 *)buf + 0x1a;
+			len = ALIGN(len, 0x8);
+			old_buf = buf;
+			buf = realloc(buf, len);
+			if (!buf) {
+				free(old_buf);
+				return EFI_OUT_OF_RESOURCES;
+			}
+			offset = (u8 *)var - (u8 *)old_buf;
+			*(u8 *)&var += offset;
+			*(u8 *)&old_var += offset;
+			continue;
+		} else if (ret != EFI_SUCCESS) {
+			free(buf);
+			return ret;
+		}
+retry:
+		data = var->var_name + u16_strlen(var->var_name) + 1;
+		vlen = (u8 *)buf + len - (u8 *)data;
+		ret = efi_get_variable_int(var->var_name, &var->guid,
+					   &var->attr, &vlen, data);
+		if (ret == EFI_BUFFER_TOO_SMALL) {
+			len = (u8 *)data + vlen - (u8 *)buf + 0x8;
+			len = ALIGN(len, 0x8);
+			old_buf = buf;
+			buf = realloc(buf, len);
+			if (!buf) {
+				free(old_buf);
+				return EFI_OUT_OF_RESOURCES;
+			}
+			var = (struct efi_var_entry *)
+			      ((u8 *)buf + ((u8 *)var - (u8 *)old_buf));
+			goto retry;
+		} else if (ret != EFI_SUCCESS) {
+			free(buf);
+			return ret;
+		}
+		var->len = vlen;
+		old_var = var;
+		var = (struct efi_var_entry *)ALIGN((uintptr_t)data + vlen, 8);
+	}
+
+	buf->crc32 = crc32(0, (u8 *)buf->var,
+			   len - sizeof(struct efi_var_file));
+	buf->length = len;
+	*bufp = buf;
+	*lenp = len;
+
+	return EFI_SUCCESS;
+}
+
+efi_status_t efi_var_to_file(void)
+{
+	efi_status_t ret;
+	struct efi_var_file *buf;
+	loff_t len;
+	loff_t actlen;
+	int r;
+
+	ret = efi_var_collect(&buf, &len);
+	if (ret != EFI_SUCCESS)
+		goto error;
+
+	ret = efi_set_blk_dev_to_system_partition();
+	if (ret != EFI_SUCCESS)
+		goto error;
+
+	r = fs_write("efi.var", map_to_sysmem(buf), 0, len, &actlen);
+	if (r || len != actlen) {
+		ret =  EFI_DEVICE_ERROR;
+	}
+
+error:
+	if (ret != EFI_SUCCESS)
+		printf("Failed to persist EFI variables\n");
+	free(buf);
+	return ret;
+}
+
+efi_status_t efi_var_from_file(void)
+{
+	efi_status_t ret;
+
+	ret = efi_set_blk_dev_to_system_partition();
+	if (ret != EFI_SUCCESS) {
+		return ret;
+	}
+
+	return EFI_SUCCESS;
+}
-- 
2.25.1

