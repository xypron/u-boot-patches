From a1470c8672d4fbaccdcec46c8a3e50a8aa5161c2 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 27 Jun 2018 20:03:24 +0200
Subject: [PATCH 5/7] efi_loader: calculate crc32 for EFI tables

For the boot and runtime services tables and for the system table the
crc32 has to be set in the header.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                 |  5 +++++
 include/efi_loader.h          |  2 ++
 lib/efi_loader/efi_boottime.c | 32 ++++++++++++++++++++++++++++----
 3 files changed, 35 insertions(+), 4 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 91277106a2..07c61ac542 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -44,6 +44,11 @@ efi_status_t efi_init_obj_list(void)
 	if (efi_obj_list_initialized != OBJ_LIST_NOT_INITIALIZED)
 		return efi_obj_list_initialized;
 
+	/* Initialize system table */
+	ret = efi_initialize_system_table();
+	if (ret != EFI_SUCCESS)
+		goto out;
+
 	/* Initialize EFI driver uclass */
 	ret = efi_driver_init();
 	if (ret != EFI_SUCCESS)
diff --git a/include/efi_loader.h b/include/efi_loader.h
index d6e1f50e22..8c9c36556b 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -199,6 +199,8 @@ extern struct list_head efi_obj_list;
 /* List of all events */
 extern struct list_head efi_events;
 
+/* Called by bootefi to initialize runtime */
+efi_status_t efi_initialize_system_table(void);
 /* Called by bootefi to make console interface available */
 int efi_console_register(void);
 /* Called by bootefi to make all disk storage accessible as EFI objects */
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 7c619c652c..904056dbfd 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -163,6 +163,18 @@ const char *__efi_nesting_dec(void)
 	return indent_string(--nesting_level);
 }
 
+/**
+ * efi_update_table_header_crc32() - Update CRC32 in table header
+ *
+ * @table:	EFI table
+ */
+static void efi_update_table_header_crc32(struct efi_table_hdr *table)
+{
+	table->crc32 = 0;
+	table->crc32 = crc32(0, (const unsigned char *)table,
+			     table->headersize);
+}
+
 /**
  * efi_queue_event - queue an EFI event
  *
@@ -1848,9 +1860,7 @@ static efi_status_t EFIAPI efi_exit_boot_services(efi_handle_t image_handle,
 	systab.boottime = NULL;
 
 	/* Recalculate CRC32 */
-	systab.hdr.crc32 = 0;
-	systab.hdr.crc32 = crc32(0, (const unsigned char *)&systab,
-				 sizeof(struct efi_system_table));
+	efi_update_table_header_crc32(&systab.hdr);
 
 	/* Give the payload some time to boot */
 	efi_set_watchdog(0);
@@ -2988,7 +2998,7 @@ out:
 	return EFI_EXIT(r);
 }
 
-static const struct efi_boot_services efi_boot_services = {
+static struct efi_boot_services efi_boot_services = {
 	.hdr = {
 		.signature = EFI_BOOT_SERVICES_SIGNATURE,
 		.revision = EFI_SPECIFICATION_VERSION,
@@ -3060,3 +3070,17 @@ struct efi_system_table __efi_runtime_data systab = {
 	.nr_tables = 0,
 	.tables = (void *)efi_conf_table,
 };
+
+/**
+ * efi_initialize_system_table() - Initialize system table
+ *
+ * Return Value:        status code
+ */
+efi_status_t efi_initialize_system_table(void)
+{
+	/* Set crc32 field in table headers */
+	efi_update_table_header_crc32(&systab.hdr);
+	efi_update_table_header_crc32(&efi_runtime_services.hdr);
+	efi_update_table_header_crc32(&efi_boot_services.hdr);
+	return EFI_SUCCESS;
+}
-- 
2.18.0

