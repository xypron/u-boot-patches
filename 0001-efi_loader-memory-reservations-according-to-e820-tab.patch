From 533a9ac9f767f1e367c825a0078131df997d4d37 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 14 Jan 2018 00:33:30 +0100
Subject: [PATCH 1/1] efi_loader: memory reservations according to e820 table

On the x86 architecture the e820 BIOS table defines reserved memory.
Mark it as EFI reserved memory.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_memory.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/lib/efi_loader/efi_memory.c b/lib/efi_loader/efi_memory.c
index 95f9ff0a140..952f9a8624c 100644
--- a/lib/efi_loader/efi_memory.c
+++ b/lib/efi_loader/efi_memory.c
@@ -12,6 +12,9 @@
 #include <malloc.h>
 #include <watchdog.h>
 #include <asm/global_data.h>
+#ifdef CONFIG_X86
+#include <asm/e820.h>
+#endif
 #include <linux/list_sort.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -492,6 +495,30 @@ __weak void efi_add_known_memory(void)
 	}
 }
 
+/*
+ * Create reservations according to the BIOS e820 table.
+ */
+static void e820_memory_reservation(void)
+{
+#ifdef CONFIG_X86
+	struct e820entry e820[32];
+	unsigned int i, num;
+	unsigned long start, pages;
+
+	num = install_e820_map(ARRAY_SIZE(e820), e820);
+
+	for (i = 0; i < num; ++i) {
+		if (e820[i].type == E820_RESERVED) {
+			start = e820[i].addr;
+			pages = ALIGN(e820[i].size, EFI_PAGE_SIZE) >>
+				EFI_PAGE_SHIFT;
+			efi_add_memory_map(start, pages,
+					   EFI_RESERVED_MEMORY_TYPE, false);
+		}
+	}
+#endif
+}
+
 int efi_memory_init(void)
 {
 	unsigned long runtime_start, runtime_end, runtime_pages;
@@ -524,6 +551,7 @@ int efi_memory_init(void)
 
 	efi_bounce_buffer = (void*)(uintptr_t)efi_bounce_buffer_addr;
 #endif
+	e820_memory_reservation();
 
 	return 0;
 }
-- 
2.14.2

