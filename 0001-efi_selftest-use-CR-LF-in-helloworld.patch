From bd248771f9bfb9689e47411dca2c781ed9d60d10 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 24 Sep 2018 23:16:45 +0200
Subject: [PATCH v2 1/1] efi_selftest: use CR LF in helloworld

The UEFI spec defines that a line feed moves the cursor to the next line
and (only) a carriage return moves the cursor to the beginning of the line.

So we should issue CR LF when we want to get to the start of the next line.

Add some comments.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v2
	correct Sphinx comments %s/Result/Return/
---
 lib/efi_loader/helloworld.c | 40 +++++++++++++++++++++++++------------
 1 file changed, 27 insertions(+), 13 deletions(-)

diff --git a/lib/efi_loader/helloworld.c b/lib/efi_loader/helloworld.c
index 3b8de5b4ea..93d4cec1f4 100644
--- a/lib/efi_loader/helloworld.c
+++ b/lib/efi_loader/helloworld.c
@@ -17,6 +17,16 @@ static const efi_guid_t fdt_guid = EFI_FDT_GUID;
 static const efi_guid_t acpi_guid = EFI_ACPI_TABLE_GUID;
 static const efi_guid_t smbios_guid = SMBIOS_TABLE_GUID;
 
+/**
+ * hw_memcmp() - compare memory areas
+ *
+ * @buf1:	pointer to first area
+ * @buf2:	pointer to second area
+ * @length:	number of bytes to compare
+ * Return:	0 if both memory areas are the same, otherwise the sign of the
+ *		result value is the same as the sign of ghe difference between
+ *		the first differing pair of bytes taken as u8.
+ */
 static int hw_memcmp(const void *buf1, const void *buf2, size_t length)
 {
 	const u8 *pos1 = buf1;
@@ -31,12 +41,12 @@ static int hw_memcmp(const void *buf1, const void *buf2, size_t length)
 	return 0;
 }
 
-/*
- * Entry point of the EFI application.
+/**
+ * efi_main() - entry point of the EFI application.
  *
- * @handle	handle of the loaded image
- * @systable	system table
- * @return	status code
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	status code
  */
 efi_status_t EFIAPI efi_main(efi_handle_t handle,
 			     struct efi_system_table *systable)
@@ -48,7 +58,8 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 	efi_uintn_t i;
 	u16 rev[] = L"0.0.0";
 
-	con_out->output_string(con_out, L"Hello, world!\n");
+	/* UEFI requires CR LF */
+	con_out->output_string(con_out, L"Hello, world!\r\n");
 
 	/* Print the revision number */
 	rev[0] = (systable->hdr.revision >> 16) + '0';
@@ -65,27 +76,30 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 
 	con_out->output_string(con_out, L"Running on UEFI ");
 	con_out->output_string(con_out, rev);
-	con_out->output_string(con_out, L"\n");
+	con_out->output_string(con_out, L"\r\n");
 
 	/* Get the loaded image protocol */
 	ret = boottime->handle_protocol(handle, &loaded_image_guid,
 					(void **)&loaded_image);
 	if (ret != EFI_SUCCESS) {
-		con_out->output_string(con_out,
-				       L"Cannot open loaded image protocol\n");
+		con_out->output_string
+			(con_out, L"Cannot open loaded image protocol\r\n");
 		goto out;
 	}
 	/* Find configuration tables */
 	for (i = 0; i < systable->nr_tables; ++i) {
 		if (!hw_memcmp(&systable->tables[i].guid, &fdt_guid,
 			       sizeof(efi_guid_t)))
-			con_out->output_string(con_out, L"Have device tree\n");
+			con_out->output_string
+					(con_out, L"Have device tree\r\n");
 		if (!hw_memcmp(&systable->tables[i].guid, &acpi_guid,
 			       sizeof(efi_guid_t)))
-			con_out->output_string(con_out, L"Have ACPI 2.0 table\n");
+			con_out->output_string
+					(con_out, L"Have ACPI 2.0 table\r\n");
 		if (!hw_memcmp(&systable->tables[i].guid, &smbios_guid,
 			       sizeof(efi_guid_t)))
-			con_out->output_string(con_out, L"Have SMBIOS table\n");
+			con_out->output_string
+					(con_out, L"Have SMBIOS table\r\n");
 	}
 	/* Output the load options */
 	con_out->output_string(con_out, L"Load options: ");
@@ -94,7 +108,7 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 				       (u16 *)loaded_image->load_options);
 	else
 		con_out->output_string(con_out, L"<none>");
-	con_out->output_string(con_out, L"\n");
+	con_out->output_string(con_out, L"\r\n");
 
 out:
 	boottime->exit(handle, ret, 0, NULL);
-- 
2.19.0

