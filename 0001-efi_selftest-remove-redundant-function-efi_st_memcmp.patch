From 7ddc12a29e8e1c7c3cf5aefb13aec560390e7dc0 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 4 May 2019 19:48:38 +0200
Subject: [PATCH 1/1] efi_selftest: remove redundant function efi_st_memcmp()

Function memcmp() is available in efi_freestanding.c. So we do not remove a
further implementation.

Replace all usages of efi_st_memcmp() by memcmp().

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_selftest.h                          | 11 -----------
 lib/efi_selftest/efi_selftest_block_device.c    |  6 +++---
 lib/efi_selftest/efi_selftest_config_table.c    | 12 ++++++------
 lib/efi_selftest/efi_selftest_loaded_image.c    |  5 ++---
 lib/efi_selftest/efi_selftest_loadimage.c       |  7 +++----
 lib/efi_selftest/efi_selftest_manageprotocols.c |  8 ++++----
 lib/efi_selftest/efi_selftest_memory.c          |  4 ++--
 lib/efi_selftest/efi_selftest_snp.c             |  7 +++----
 lib/efi_selftest/efi_selftest_startimage_exit.c |  2 +-
 lib/efi_selftest/efi_selftest_util.c            | 14 --------------
 lib/efi_selftest/efi_selftest_variables.c       | 10 +++++-----
 11 files changed, 29 insertions(+), 57 deletions(-)

diff --git a/include/efi_selftest.h b/include/efi_selftest.h
index dd42e49023..eaee188de7 100644
--- a/include/efi_selftest.h
+++ b/include/efi_selftest.h
@@ -92,17 +92,6 @@ u16 *efi_st_translate_char(u16 code);
  */
 u16 *efi_st_translate_code(u16 code);
 
-/*
- * Compare memory.
- * We cannot use lib/string.c due to different CFLAGS values.
- *
- * @buf1:	first buffer
- * @buf2:	second buffer
- * @length:	number of bytes to compare
- * @return:	0 if both buffers contain the same bytes
- */
-int efi_st_memcmp(const void *buf1, const void *buf2, size_t length);
-
 /*
  * Compare an u16 string to a char string.
  *
diff --git a/lib/efi_selftest/efi_selftest_block_device.c b/lib/efi_selftest/efi_selftest_block_device.c
index 29ac0ce651..644c5ade21 100644
--- a/lib/efi_selftest/efi_selftest_block_device.c
+++ b/lib/efi_selftest/efi_selftest_block_device.c
@@ -337,7 +337,7 @@ static int execute(void)
 		}
 		if (len >= dp_size(dp_partition))
 			continue;
-		if (efi_st_memcmp(dp, dp_partition, len))
+		if (memcmp(dp, dp_partition, len))
 			continue;
 		handle_partition = handles[i];
 		break;
@@ -409,7 +409,7 @@ static int execute(void)
 			     (unsigned int)buf_size);
 		return EFI_ST_FAILURE;
 	}
-	if (efi_st_memcmp(buf, "ello world!", 11)) {
+	if (memcmp(buf, "ello world!", 11)) {
 		efi_st_error("Unexpected file content\n");
 		return EFI_ST_FAILURE;
 	}
@@ -480,7 +480,7 @@ static int execute(void)
 			     (unsigned int)buf_size);
 		return EFI_ST_FAILURE;
 	}
-	if (efi_st_memcmp(buf, "U-Boot", 7)) {
+	if (memcmp(buf, "U-Boot", 7)) {
 		efi_st_error("Unexpected file content %s\n", buf);
 		return EFI_ST_FAILURE;
 	}
diff --git a/lib/efi_selftest/efi_selftest_config_table.c b/lib/efi_selftest/efi_selftest_config_table.c
index 0bc5da6b0c..4467f492ac 100644
--- a/lib/efi_selftest/efi_selftest_config_table.c
+++ b/lib/efi_selftest/efi_selftest_config_table.c
@@ -153,8 +153,8 @@ static int execute(void)
 	}
 	table = NULL;
 	for (i = 0; i < sys_table->nr_tables; ++i) {
-		if (!efi_st_memcmp(&sys_table->tables[i].guid, &table_guid,
-				   sizeof(efi_guid_t)))
+		if (!memcmp(&sys_table->tables[i].guid, &table_guid,
+			    sizeof(efi_guid_t)))
 			table = sys_table->tables[i].table;
 	}
 	if (!table) {
@@ -192,8 +192,8 @@ static int execute(void)
 	table = NULL;
 	tabcnt = 0;
 	for (i = 0; i < sys_table->nr_tables; ++i) {
-		if (!efi_st_memcmp(&sys_table->tables[i].guid, &table_guid,
-				   sizeof(efi_guid_t))) {
+		if (!memcmp(&sys_table->tables[i].guid, &table_guid,
+			    sizeof(efi_guid_t))) {
 			table = sys_table->tables[i].table;
 			++tabcnt;
 		}
@@ -235,8 +235,8 @@ static int execute(void)
 	}
 	table = NULL;
 	for (i = 0; i < sys_table->nr_tables; ++i) {
-		if (!efi_st_memcmp(&sys_table->tables[i].guid, &table_guid,
-				   sizeof(efi_guid_t))) {
+		if (!memcmp(&sys_table->tables[i].guid, &table_guid,
+			    sizeof(efi_guid_t))) {
 			table = sys_table->tables[i].table;
 		}
 	}
diff --git a/lib/efi_selftest/efi_selftest_loaded_image.c b/lib/efi_selftest/efi_selftest_loaded_image.c
index ea2b380a77..5889ab1261 100644
--- a/lib/efi_selftest/efi_selftest_loaded_image.c
+++ b/lib/efi_selftest/efi_selftest_loaded_image.c
@@ -60,9 +60,8 @@ static int execute(void)
 	efi_st_printf("%u protocols installed on image handle\n",
 		      (unsigned int)protocol_buffer_count);
 	for (i = 0; i < protocol_buffer_count; ++i) {
-		if (efi_st_memcmp(protocol_buffer[i],
-				  &loaded_image_protocol_guid,
-				  sizeof(efi_guid_t)))
+		if (memcmp(protocol_buffer[i], &loaded_image_protocol_guid,
+			   sizeof(efi_guid_t)))
 			found = true;
 	}
 	if (!found) {
diff --git a/lib/efi_selftest/efi_selftest_loadimage.c b/lib/efi_selftest/efi_selftest_loadimage.c
index 449b6bfcac..06a87df862 100644
--- a/lib/efi_selftest/efi_selftest_loadimage.c
+++ b/lib/efi_selftest/efi_selftest_loadimage.c
@@ -322,8 +322,7 @@ static efi_status_t EFIAPI getinfo
 	 efi_uintn_t *buffer_size, void *buffer)
 {
 	if (this == &file) {
-		if (efi_st_memcmp(info_type, &guid_file_info,
-				  sizeof(efi_guid_t)))
+		if (memcmp(info_type, &guid_file_info, sizeof(efi_guid_t)))
 			return EFI_INVALID_PARAMETER;
 		if (*buffer_size >= sizeof(struct file_info)) {
 			boottime->copy_mem(buffer, file_info,
@@ -333,8 +332,8 @@ static efi_status_t EFIAPI getinfo
 			return EFI_BUFFER_TOO_SMALL;
 		}
 	} else if (this == &volume) {
-		if (efi_st_memcmp(info_type, &guid_file_system_info,
-				  sizeof(efi_guid_t)))
+		if (memcmp(info_type, &guid_file_system_info,
+			   sizeof(efi_guid_t)))
 			return EFI_INVALID_PARAMETER;
 		if (*buffer_size >= sizeof(struct file_system_info)) {
 			boottime->copy_mem(buffer, file_system_info,
diff --git a/lib/efi_selftest/efi_selftest_manageprotocols.c b/lib/efi_selftest/efi_selftest_manageprotocols.c
index 0ff35cec8a..8edb1e4d46 100644
--- a/lib/efi_selftest/efi_selftest_manageprotocols.c
+++ b/lib/efi_selftest/efi_selftest_manageprotocols.c
@@ -332,13 +332,13 @@ static int execute(void)
 		efi_st_error("Failed to get protocols per handle\n");
 		return EFI_ST_FAILURE;
 	}
-	if (efi_st_memcmp(prot_buffer[0], &guid1, 16) &&
-	    efi_st_memcmp(prot_buffer[1], &guid1, 16)) {
+	if (memcmp(prot_buffer[0], &guid1, 16) &&
+	    memcmp(prot_buffer[1], &guid1, 16)) {
 		efi_st_error("Failed to get protocols per handle\n");
 		return EFI_ST_FAILURE;
 	}
-	if (efi_st_memcmp(prot_buffer[0], &guid3, 16) &&
-	    efi_st_memcmp(prot_buffer[1], &guid3, 16)) {
+	if (memcmp(prot_buffer[0], &guid3, 16) &&
+	    memcmp(prot_buffer[1], &guid3, 16)) {
 		efi_st_error("Failed to get protocols per handle\n");
 		return EFI_ST_FAILURE;
 	}
diff --git a/lib/efi_selftest/efi_selftest_memory.c b/lib/efi_selftest/efi_selftest_memory.c
index 5eeb42a9be..e71732dc6d 100644
--- a/lib/efi_selftest/efi_selftest_memory.c
+++ b/lib/efi_selftest/efi_selftest_memory.c
@@ -33,8 +33,8 @@ static int setup(const efi_handle_t handle,
 	boottime = systable->boottime;
 
 	for (i = 0; i < systable->nr_tables; ++i) {
-		if (!efi_st_memcmp(&systable->tables[i].guid, &fdt_guid,
-				   sizeof(efi_guid_t))) {
+		if (!memcmp(&systable->tables[i].guid, &fdt_guid,
+			    sizeof(efi_guid_t))) {
 			if (fdt_addr) {
 				efi_st_error("Duplicate device tree\n");
 				return EFI_ST_FAILURE;
diff --git a/lib/efi_selftest/efi_selftest_snp.c b/lib/efi_selftest/efi_selftest_snp.c
index d7350e2158..4c26619001 100644
--- a/lib/efi_selftest/efi_selftest_snp.c
+++ b/lib/efi_selftest/efi_selftest_snp.c
@@ -334,9 +334,8 @@ static int execute(void)
 		 * Unfortunately QEMU ignores the broadcast flag.
 		 * So we have to check for broadcasts too.
 		 */
-		if (efi_st_memcmp(&destaddr, &net->mode->current_address,
-				  ARP_HLEN) &&
-		    efi_st_memcmp(&destaddr, BROADCAST_MAC, ARP_HLEN))
+		if (memcmp(&destaddr, &net->mode->current_address, ARP_HLEN) &&
+		    memcmp(&destaddr, BROADCAST_MAC, ARP_HLEN))
 			continue;
 		/*
 		 * Check this is a DHCP reply
@@ -360,7 +359,7 @@ static int execute(void)
 	addr = (u8 *)&buffer.p.ip_udp.ip_src;
 	efi_st_printf("DHCP reply received from %u.%u.%u.%u (%pm) ",
 		      addr[0], addr[1], addr[2], addr[3], &srcaddr);
-	if (!efi_st_memcmp(&destaddr, BROADCAST_MAC, ARP_HLEN))
+	if (!memcmp(&destaddr, BROADCAST_MAC, ARP_HLEN))
 		efi_st_printf("as broadcast message.\n");
 	else
 		efi_st_printf("as unicast message.\n");
diff --git a/lib/efi_selftest/efi_selftest_startimage_exit.c b/lib/efi_selftest/efi_selftest_startimage_exit.c
index 96049dea86..11207b8162 100644
--- a/lib/efi_selftest/efi_selftest_startimage_exit.c
+++ b/lib/efi_selftest/efi_selftest_startimage_exit.c
@@ -139,7 +139,7 @@ static int execute(void)
 		return EFI_ST_FAILURE;
 	}
 	if (!exit_data || exit_data_size != sizeof(expected_text) ||
-	    efi_st_memcmp(exit_data, expected_text, sizeof(expected_text))) {
+	    memcmp(exit_data, expected_text, sizeof(expected_text))) {
 		efi_st_error("Incorrect exit data\n");
 		return EFI_ST_FAILURE;
 	}
diff --git a/lib/efi_selftest/efi_selftest_util.c b/lib/efi_selftest/efi_selftest_util.c
index 96a964c863..ea73c25220 100644
--- a/lib/efi_selftest/efi_selftest_util.c
+++ b/lib/efi_selftest/efi_selftest_util.c
@@ -102,20 +102,6 @@ u16 *efi_st_translate_code(u16 code)
 	return efi_st_unknown;
 }
 
-int efi_st_memcmp(const void *buf1, const void *buf2, size_t length)
-{
-	const u8 *pos1 = buf1;
-	const u8 *pos2 = buf2;
-
-	for (; length; --length) {
-		if (*pos1 != *pos2)
-			return *pos1 - *pos2;
-		++pos1;
-		++pos2;
-	}
-	return 0;
-}
-
 int efi_st_strcmp_16_8(const u16 *buf1, const char *buf2)
 {
 	for (; *buf1 || *buf2; ++buf1, ++buf2) {
diff --git a/lib/efi_selftest/efi_selftest_variables.c b/lib/efi_selftest/efi_selftest_variables.c
index 47a8e7fb95..b028c64bbc 100644
--- a/lib/efi_selftest/efi_selftest_variables.c
+++ b/lib/efi_selftest/efi_selftest_variables.c
@@ -78,7 +78,7 @@ static int execute(void)
 		efi_st_error("GetVariable failed\n");
 		return EFI_ST_FAILURE;
 	}
-	if (efi_st_memcmp(data, v + 4, 3)) {
+	if (memcmp(data, v + 4, 3)) {
 		efi_st_error("GetVariable returned wrong value\n");
 		return EFI_ST_FAILURE;
 	}
@@ -106,7 +106,7 @@ static int execute(void)
 			     (unsigned int)len);
 		return EFI_ST_FAILURE;
 	}
-	if (efi_st_memcmp(data, v, 8)) {
+	if (memcmp(data, v, 8)) {
 		efi_st_error("GetVariable returned wrong value\n");
 		return EFI_ST_FAILURE;
 	}
@@ -129,7 +129,7 @@ static int execute(void)
 	if (len != 15)
 		efi_st_todo("GetVariable returned wrong length %u\n",
 			    (unsigned int)len);
-	if (efi_st_memcmp(data, v, len))
+	if (memcmp(data, v, len))
 		efi_st_todo("GetVariable returned wrong value\n");
 	/* Enumerate variables */
 	boottime->set_mem(&guid, 16, 0);
@@ -145,10 +145,10 @@ static int execute(void)
 				     (unsigned int)ret);
 			return EFI_ST_FAILURE;
 		}
-		if (!efi_st_memcmp(&guid, &guid_vendor0, sizeof(efi_guid_t)) &&
+		if (!memcmp(&guid, &guid_vendor0, sizeof(efi_guid_t)) &&
 		    !efi_st_strcmp_16_8(varname, "efi_st_var0"))
 			flag |= 1;
-		if (!efi_st_memcmp(&guid, &guid_vendor1, sizeof(efi_guid_t)) &&
+		if (!memcmp(&guid, &guid_vendor1, sizeof(efi_guid_t)) &&
 		    !efi_st_strcmp_16_8(varname, "efi_st_var1"))
 			flag |= 2;
 	}
-- 
2.20.1

