From bc01b37082917c02f4c9b1ee26fc49f4af822982 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Fri, 10 Jan 2020 12:36:01 +0100
Subject: [PATCH 1/1] efi_loader: link partition to block device

We provide a UEFI driver for block devices. When ConnectController() is
called for a handle with the EFI_BLOCK_IO_PROTOCOL this driver creates the
partitions. When DisconnectController() is called the handles for the
partitions have to be deleted. This requires that the child controllers
(partitions) open the EFI_BLOCK_IO_PROTOCOL of the controller (block IO
device) with attribute EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_disk.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/lib/efi_loader/efi_disk.c b/lib/efi_loader/efi_disk.c
index ed7fb3f7d3..e77f4cbe84 100644
--- a/lib/efi_loader/efi_disk.c
+++ b/lib/efi_loader/efi_disk.c
@@ -307,6 +307,8 @@ static efi_status_t efi_disk_add_dev(
 {
 	struct efi_disk_obj *diskobj;
 	efi_status_t ret;
+	struct efi_handler *handler;
+	void *protocol_interface;
 
 	/* Don't add empty devices */
 	if (!desc->lba)
@@ -316,9 +318,24 @@ static efi_status_t efi_disk_add_dev(
 	if (!diskobj)
 		return EFI_OUT_OF_RESOURCES;
 
+	/* Parent must expose EFI_BLOCK_IO_PROTOCOL */
+	ret = efi_search_protocol(parent, &efi_block_io_guid, &handler);
+	if (ret != EFI_SUCCESS)
+		return ret;
+
 	/* Hook up to the device list */
 	efi_add_handle(&diskobj->header);
 
+	/*
+	 * Link the partition (child controller) to the block device
+	 * (controller).
+	 */
+	ret = efi_protocol_open(handler, &protocol_interface, NULL,
+				&diskobj->header,
+				EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER);
+	if (ret != EFI_SUCCESS)
+		return ret;
+
 	/* Fill in object data */
 	if (part) {
 		struct efi_device_path *node = efi_dp_part_node(desc, part);
-- 
2.24.1

