From 3f41fa4144f4c00f2e1a4cc7a339e18e396c965b Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 22 Sep 2018 10:48:24 +0200
Subject: [PATCH 1/1] efi_loader: provide PEI services table

The EFI shell calls functions in the PEI services table. Provide a stub.

Add a dummy HUB table.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c            |   7 +-
 include/efi_dxe.h        | 140 ++++++++++++++++++++++
 lib/efi_loader/Makefile  |   1 +
 lib/efi_loader/efi_dxe.c | 250 +++++++++++++++++++++++++++++++++++++++
 4 files changed, 397 insertions(+), 1 deletion(-)
 create mode 100644 include/efi_dxe.h
 create mode 100644 lib/efi_loader/efi_dxe.c

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 5fc054c9da..8bc6fa49f5 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -9,7 +9,7 @@
 #include <common.h>
 #include <command.h>
 #include <dm.h>
-#include <efi_loader.h>
+#include <efi_dxe.h>
 #include <efi_selftest.h>
 #include <errno.h>
 #include <linux/libfdt.h>
@@ -96,6 +96,11 @@ efi_status_t efi_init_obj_list(void)
 	if (ret != EFI_SUCCESS)
 		goto out;
 
+	/* Install PI services */
+	ret = register_pi_services();
+	if (ret != EFI_SUCCESS)
+		goto out;
+
 out:
 	efi_obj_list_initialized = ret;
 	return ret;
diff --git a/include/efi_dxe.h b/include/efi_dxe.h
new file mode 100644
index 0000000000..6f4b211840
--- /dev/null
+++ b/include/efi_dxe.h
@@ -0,0 +1,140 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include <efi_api.h>
+
+#define DXE_SERVICES_TABLE_GUID \
+	((efi_guid_t)EFI_GUID(0x05AD34BA, 0x6F02, 0x4214, \
+		0x95, 0x2E, 0x4D, 0xA0, 0x39, 0x8E, 0x2B, 0xB9))
+
+#define EFI_HOB_LIST_GUID \
+	((efi_guid_t)EFI_GUID(0x7739F24C, 0x93D7, 0x11D4, \
+		0x9A, 0x3A, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D))
+
+#define DXE_ERROR_MASK (5UL << (EFI_BITS_PER_LONG - 3))
+
+#define EFI_NOT_AVAILABLE_YET (DXE_ERROR_MASK | 2)
+
+#define PEI_SERVICES_SIGNATURE 0x565245532049455
+#define PEI_SERVICES_REVISION (1 << 16 | 60)
+
+#define EFI_HOB_TYPE_END_OF_HOB_LIST 0xFFFF
+
+struct efi_hob_header {
+	u16 hob_type;
+	u16 hob_length;
+	u32 reserved;
+};
+
+struct efi_pi_services {
+	struct efi_table_hdr hdr;
+
+	/* PPI functions */
+	efi_status_t (EFIAPI *install_ppi)
+		(struct efi_pi_services **pei_services, void *ppi_list);
+
+	efi_status_t (EFIAPI *reinstall_ppi)
+		(struct efi_pi_services **pei_services,
+		 void *old_ppi, void *new_ppi);
+
+	efi_status_t (EFIAPI *locate_ppi)
+		(struct efi_pi_services **pei_services, efi_guid_t *guid,
+		 efi_uintn_t instance, void *ppi_descriptor, void *ppi);
+
+	efi_status_t (EFIAPI *notify_ppi)
+		(struct efi_pi_services **pei_services, void *notify_list);
+
+	/* Boot mode functions */
+	efi_status_t (EFIAPI *get_boot_mode)
+		(struct efi_pi_services **pei_services, u32 *boot_mode);
+
+	efi_status_t (EFIAPI *set_boot_mode)
+		(struct efi_pi_services **pei_services, u32 boot_mode);
+
+	/* HOB functions */
+	efi_status_t (EFIAPI *get_hob_list)
+		(struct efi_pi_services **pei_services, void **hob_list);
+
+	efi_status_t (EFIAPI *create_hob)
+		(struct efi_pi_services **pei_services,
+		 u16 type, u16 length, void **hob);
+
+	/* Firmware volume functions */
+	efi_status_t (EFIAPI *ffs_find_next_volume2)
+		(struct efi_pi_services **pei_services, efi_uintn_t instance,
+		 void *volume_handle);
+
+	efi_status_t (EFIAPI *ffs_find_next_file2)
+		(struct efi_pi_services **pei_services, u8 search_type,
+		 void *fv_handle, void *file_handle);
+
+	efi_status_t (EFIAPI *ffs_find_section_data)
+		(struct efi_pi_services **pei_services, u8 section_type,
+		 void *file_handle, void *section_data);
+
+	/* PEI memory functions */
+	efi_status_t (EFIAPI *install_pei_memory)
+		(struct efi_pi_services **pei_services,
+		 u64 memory_begin, u64 memory_length);
+
+	efi_status_t (EFIAPI *allocate_pages)
+		(struct efi_pi_services **pei_services, int memory_type,
+		 efi_uintn_t pages, u64 *memory);
+
+	efi_status_t (EFIAPI *allocate_pool)
+		(struct efi_pi_services **pei_services,
+		 efi_uintn_t size, void **buffer);
+
+	efi_status_t (EFIAPI *copy_mem)
+		(void *destination, void *source, efi_uintn_t length);
+
+	efi_status_t (EFIAPI *set_mem)
+		(void *buffer, efi_uintn_t size, u8 value);
+
+	/* Status code */
+	efi_status_t (EFIAPI *report_status_code)
+		(struct efi_pi_services **pei_services, u32 type, u32 value,
+		 u32 instance, efi_guid_t *caller_id, void *data);
+
+	/* Reset */
+	efi_status_t (EFIAPI *reset_system)
+		(struct efi_pi_services **pei_services);
+
+	/* I/O abstractions */
+
+	/* TODO: missing prototype */
+	void *cpu_io;
+
+	/* TODO: missing prototype */
+	void *pci_cfg;
+
+	/* Additional file system related services */
+	efi_status_t (EFIAPI *ffs_find_file_by_name)
+		(void *file_name, void *volume_handle, void *file_handle);
+
+	efi_status_t (EFIAPI *ffd_get_file_info)
+		(void *file_handle, void *file_info);
+
+	efi_status_t (EFIAPI *ffs_get_volume_info)
+		(void *volume_handle, void *volume_info);
+
+	efi_status_t (EFIAPI *ffs_register_for_shadow)
+		(void *file_handle);
+
+	efi_status_t (EFIAPI *ffs_find_section_data3)
+		(struct efi_pi_services **pei_services, u8 section_type,
+		 efi_uintn_t section_instance, void *file_handle,
+		 void **section_data, u32 *authentication_status);
+
+	efi_status_t (EFIAPI *ffs_get_file_info2)
+		(void *file_handle, void *file_info);
+
+	efi_status_t (EFIAPI *reset_system2)
+		(int reset_type, efi_status_t reset_status,
+		 efi_uintn_t data_size, void *reset_data);
+
+	efi_status_t (EFIAPI *free_pages)
+		(struct efi_pi_services **pei_services,
+		 u64 memory, efi_uintn_t pages);
+};
+
+efi_status_t register_pi_services(void);
diff --git a/lib/efi_loader/Makefile b/lib/efi_loader/Makefile
index 6703435947..f342541278 100644
--- a/lib/efi_loader/Makefile
+++ b/lib/efi_loader/Makefile
@@ -23,6 +23,7 @@ obj-y += efi_console.o
 obj-y += efi_device_path.o
 obj-y += efi_device_path_to_text.o
 obj-y += efi_device_path_utilities.o
+obj-y += efi_dxe.o
 obj-y += efi_file.o
 obj-y += efi_hii.o
 obj-y += efi_image_loader.o
diff --git a/lib/efi_loader/efi_dxe.c b/lib/efi_loader/efi_dxe.c
new file mode 100644
index 0000000000..b0d55169f3
--- /dev/null
+++ b/lib/efi_loader/efi_dxe.c
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#define DEBUG 1
+
+#include <common.h>
+#include <efi_dxe.h>
+#include <efi_loader.h>
+
+/* PPI functions */
+static efi_status_t EFIAPI dxe_install_ppi
+	(struct efi_pi_services **pei_services, void *ppi_list)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_reinstall_ppi
+	(struct efi_pi_services **pei_services,
+	 void *old_ppi, void *new_ppi)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_locate_ppi
+	(struct efi_pi_services **pei_services, efi_guid_t *guid,
+	 efi_uintn_t instance, void *ppi_descriptor, void *ppi)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_notify_ppi
+	(struct efi_pi_services **pei_services, void *notify_list)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+/* Boot mode functions */
+static efi_status_t EFIAPI dxe_get_boot_mode
+	(struct efi_pi_services **pei_services, u32 *boot_mode)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_set_boot_mode
+	(struct efi_pi_services **pei_services, u32 boot_mode)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+/* HOB functions */
+static efi_status_t EFIAPI dxe_get_hob_list
+	(struct efi_pi_services **pei_services, void **hob_list)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_create_hob
+	(struct efi_pi_services **pei_services,
+	 u16 type, u16 length, void **hob)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+/* Firmware volume functions */
+static efi_status_t EFIAPI dxe_ffs_find_next_volume2
+	(struct efi_pi_services **pei_services, efi_uintn_t instance,
+	 void *volume_handle)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_ffs_find_next_file2
+	(struct efi_pi_services **pei_services, u8 search_type,
+	 void *fv_handle, void *file_handle)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_ffs_find_section_data
+	(struct efi_pi_services **pei_services, u8 section_type,
+	 void *file_handle, void *section_data)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+/* PEI memory functions */
+static efi_status_t EFIAPI dxe_install_pei_memory
+	(struct efi_pi_services **pei_services,
+	 u64 memory_begin, u64 memory_length)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_allocate_pages
+	(struct efi_pi_services **pei_services, int memory_type,
+	 efi_uintn_t pages, u64 *memory)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_allocate_pool
+	(struct efi_pi_services **pei_services,
+	 efi_uintn_t size, void **buffer)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_copy_mem
+	(void *destination, void *source, efi_uintn_t length)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_set_mem
+	(void *buffer, efi_uintn_t size, u8 value)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+/* Status code */
+static efi_status_t EFIAPI dxe_report_status_code
+	(struct efi_pi_services **pei_services, u32 type, u32 value,
+	 u32 instance, efi_guid_t *caller_id, void *data)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+/* Reset */
+static efi_status_t EFIAPI dxe_reset_system
+	(struct efi_pi_services **pei_services)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+/* I/O abstractions */
+
+/* TODO: missing prototype */
+void *cpu_io;
+
+/* TODO: missing prototype */
+void *pci_cfg;
+
+/* Additional file system related services */
+static efi_status_t EFIAPI dxe_ffs_find_file_by_name
+	(void *file_name, void *volume_handle, void *file_handle)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_ffd_get_file_info
+	(void *file_handle, void *file_info)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_ffs_get_volume_info
+	(void *volume_handle, void *volume_info)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_ffs_register_for_shadow
+	(void *file_handle)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_ffs_find_section_data3
+	(struct efi_pi_services **pei_services, u8 section_type,
+	 efi_uintn_t section_instance, void *file_handle,
+	 void **section_data, u32 *authentication_status)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_ffs_get_file_info2
+		(void *file_handle, void *file_info)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_reset_system2
+		(int reset_type, efi_status_t reset_status,
+		 efi_uintn_t data_size, void *reset_data)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static efi_status_t EFIAPI dxe_free_pages
+		(struct efi_pi_services **pei_services,
+		 u64 memory, efi_uintn_t pages)
+{
+	return EFI_NOT_AVAILABLE_YET;
+}
+
+static struct efi_pi_services pi_services = {
+	.hdr = {
+		.signature = PEI_SERVICES_SIGNATURE,
+		.revision = PEI_SERVICES_REVISION,
+		.headersize = sizeof(struct efi_pi_services),
+	},
+	.install_ppi = dxe_install_ppi,
+	.reinstall_ppi = dxe_reinstall_ppi,
+	.locate_ppi = dxe_locate_ppi,
+	.notify_ppi = dxe_notify_ppi,
+	.get_boot_mode = dxe_get_boot_mode,
+	.set_boot_mode = dxe_set_boot_mode,
+	.get_hob_list = dxe_get_hob_list,
+	.create_hob = dxe_create_hob,
+	.ffs_find_next_volume2 = dxe_ffs_find_next_volume2,
+	.ffs_find_next_file2 = dxe_ffs_find_next_file2,
+	.ffs_find_section_data = dxe_ffs_find_section_data,
+	.install_pei_memory = dxe_install_pei_memory,
+	.allocate_pages = dxe_allocate_pages,
+	.allocate_pool = dxe_allocate_pool,
+	.copy_mem = dxe_copy_mem,
+	.set_mem = dxe_set_mem,
+	.report_status_code = dxe_report_status_code,
+	.reset_system = dxe_reset_system,
+	.ffs_find_file_by_name = dxe_ffs_find_file_by_name,
+	.ffd_get_file_info = dxe_ffd_get_file_info,
+	.ffs_get_volume_info = dxe_ffs_get_volume_info,
+	.ffs_register_for_shadow = dxe_ffs_register_for_shadow,
+	.ffs_find_section_data3 = dxe_ffs_find_section_data3,
+	.ffs_get_file_info2 = dxe_ffs_get_file_info2,
+	.reset_system2 = dxe_reset_system2,
+	.free_pages = dxe_free_pages,
+};
+
+static struct efi_hob_header hob_list = {
+	.hob_type = EFI_HOB_TYPE_END_OF_HOB_LIST,
+	.hob_length = sizeof(struct efi_hob_header),
+};
+
+efi_status_t register_pi_services(void)
+{
+	efi_guid_t guid = DXE_SERVICES_TABLE_GUID;
+	efi_status_t ret;
+
+	/* Set CRC32 field in table header */
+	efi_update_table_header_crc32(&pi_services.hdr);
+
+	ret = efi_install_configuration_table(&guid, &pi_services);
+	if (ret != EFI_SUCCESS)
+		return ret;
+
+	guid = EFI_HOB_LIST_GUID;
+	ret = efi_install_configuration_table(&guid, &hob_list);
+
+	return ret;
+}
-- 
2.19.0

