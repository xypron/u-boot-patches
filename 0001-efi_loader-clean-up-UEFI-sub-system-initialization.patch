From 93ac427177a094d5fd6d862c5d388e2c5daa45ba Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 4 May 2019 11:47:48 +0200
Subject: [PATCH 1/1] efi_loader: clean up UEFI sub-system initialization

allow_unaligned(), switch_to_non_secure_mode(), and efi_init_obj_list() are
called in sequence in multiple places.

Move calls to allow_unaligned() and switch_to_non_secure_mode() to
efi_init_obj_list().

Remove unused includes.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c              | 26 --------------------------
 lib/efi_loader/efi_setup.c | 15 +++++++++++++++
 2 files changed, 15 insertions(+), 26 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index f1d7d8bc66..67929f5874 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -17,9 +17,7 @@
 #include <linux/libfdt_env.h>
 #include <mapmem.h>
 #include <memalign.h>
-#include <asm/global_data.h>
 #include <asm-generic/sections.h>
-#include <asm-generic/unaligned.h>
 #include <linux/linkage.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -27,15 +25,6 @@ DECLARE_GLOBAL_DATA_PTR;
 static struct efi_device_path *bootefi_image_path;
 static struct efi_device_path *bootefi_device_path;
 
-/*
- * Allow unaligned memory access.
- *
- * This routine is overridden by architectures providing this feature.
- */
-void __weak allow_unaligned(void)
-{
-}
-
 /*
  * Set the load options of an image from an environment variable.
  *
@@ -338,11 +327,6 @@ static int do_efibootmgr(const char *fdt_opt)
 	efi_handle_t handle;
 	efi_status_t ret;
 
-	/* Allow unaligned memory access */
-	allow_unaligned();
-
-	switch_to_non_secure_mode();
-
 	/* Initialize EFI drivers */
 	ret = efi_init_obj_list();
 	if (ret != EFI_SUCCESS) {
@@ -391,11 +375,6 @@ static int do_bootefi_image(const char *image_opt, const char *fdt_opt)
 	efi_handle_t mem_handle = NULL, handle;
 	efi_status_t ret;
 
-	/* Allow unaligned memory access */
-	allow_unaligned();
-
-	switch_to_non_secure_mode();
-
 	/* Initialize EFI drivers */
 	ret = efi_init_obj_list();
 	if (ret != EFI_SUCCESS) {
@@ -582,11 +561,6 @@ static int do_efi_selftest(const char *fdt_opt)
 	struct efi_loaded_image *loaded_image_info;
 	efi_status_t ret;
 
-	/* Allow unaligned memory access */
-	allow_unaligned();
-
-	switch_to_non_secure_mode();
-
 	/* Initialize EFI drivers */
 	ret = efi_init_obj_list();
 	if (ret != EFI_SUCCESS) {
diff --git a/lib/efi_loader/efi_setup.c b/lib/efi_loader/efi_setup.c
index 87db51cbb7..6791b69bf3 100644
--- a/lib/efi_loader/efi_setup.c
+++ b/lib/efi_loader/efi_setup.c
@@ -12,6 +12,15 @@
 
 static efi_status_t efi_obj_list_initialized = OBJ_LIST_NOT_INITIALIZED;
 
+/*
+ * Allow unaligned memory access.
+ *
+ * This routine is overridden by architectures providing this feature.
+ */
+void __weak allow_unaligned(void)
+{
+}
+
 /**
  * efi_init_platform_lang() - define supported languages
  *
@@ -86,6 +95,12 @@ efi_status_t efi_init_obj_list(void)
 	if (efi_obj_list_initialized != OBJ_LIST_NOT_INITIALIZED)
 		return efi_obj_list_initialized;
 
+	/* Allow unaligned memory access */
+	allow_unaligned();
+
+	/* Do not continue in EL3 */
+	switch_to_non_secure_mode();
+
 	/* Define supported languages */
 	ret = efi_init_platform_lang();
 	if (ret != EFI_SUCCESS)
-- 
2.20.1

