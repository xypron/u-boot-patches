From 54a321a7e32719505591c9e7a1f18096961bbc5a Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 4 May 2019 11:47:48 +0200
Subject: [PATCH 1/1] efi_loader: clean up UEFI sub-system initialization

allow_unaligned(), switch_to_non_secure_mode(), and efi_init_obj_list() are
called in sequence in multiple places.

Move calls to allow_unaligned() and switch_to_non_secure_mode() to
efi_init_obj_list().

Remove unused includes.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c              | 27 ---------------------------
 lib/efi_loader/efi_setup.c | 16 ++++++++++++++++
 2 files changed, 16 insertions(+), 27 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index f1d7d8bc66..52116b308c 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -6,7 +6,6 @@
  */
 
 #include <common.h>
-#include <bootm.h>
 #include <charset.h>
 #include <command.h>
 #include <dm.h>
@@ -17,9 +16,7 @@
 #include <linux/libfdt_env.h>
 #include <mapmem.h>
 #include <memalign.h>
-#include <asm/global_data.h>
 #include <asm-generic/sections.h>
-#include <asm-generic/unaligned.h>
 #include <linux/linkage.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -27,15 +24,6 @@ DECLARE_GLOBAL_DATA_PTR;
 static struct efi_device_path *bootefi_image_path;
 static struct efi_device_path *bootefi_device_path;
 
-/*
- * Allow unaligned memory access.
- *
- * This routine is overridden by architectures providing this feature.
- */
-void __weak allow_unaligned(void)
-{
-}
-
 /*
  * Set the load options of an image from an environment variable.
  *
@@ -338,11 +326,6 @@ static int do_efibootmgr(const char *fdt_opt)
 	efi_handle_t handle;
 	efi_status_t ret;
 
-	/* Allow unaligned memory access */
-	allow_unaligned();
-
-	switch_to_non_secure_mode();
-
 	/* Initialize EFI drivers */
 	ret = efi_init_obj_list();
 	if (ret != EFI_SUCCESS) {
@@ -391,11 +374,6 @@ static int do_bootefi_image(const char *image_opt, const char *fdt_opt)
 	efi_handle_t mem_handle = NULL, handle;
 	efi_status_t ret;
 
-	/* Allow unaligned memory access */
-	allow_unaligned();
-
-	switch_to_non_secure_mode();
-
 	/* Initialize EFI drivers */
 	ret = efi_init_obj_list();
 	if (ret != EFI_SUCCESS) {
@@ -582,11 +560,6 @@ static int do_efi_selftest(const char *fdt_opt)
 	struct efi_loaded_image *loaded_image_info;
 	efi_status_t ret;
 
-	/* Allow unaligned memory access */
-	allow_unaligned();
-
-	switch_to_non_secure_mode();
-
 	/* Initialize EFI drivers */
 	ret = efi_init_obj_list();
 	if (ret != EFI_SUCCESS) {
diff --git a/lib/efi_loader/efi_setup.c b/lib/efi_loader/efi_setup.c
index 87db51cbb7..8691d686d2 100644
--- a/lib/efi_loader/efi_setup.c
+++ b/lib/efi_loader/efi_setup.c
@@ -6,12 +6,22 @@
  */
 
 #include <common.h>
+#include <bootm.h>
 #include <efi_loader.h>
 
 #define OBJ_LIST_NOT_INITIALIZED 1
 
 static efi_status_t efi_obj_list_initialized = OBJ_LIST_NOT_INITIALIZED;
 
+/*
+ * Allow unaligned memory access.
+ *
+ * This routine is overridden by architectures providing this feature.
+ */
+void __weak allow_unaligned(void)
+{
+}
+
 /**
  * efi_init_platform_lang() - define supported languages
  *
@@ -86,6 +96,12 @@ efi_status_t efi_init_obj_list(void)
 	if (efi_obj_list_initialized != OBJ_LIST_NOT_INITIALIZED)
 		return efi_obj_list_initialized;
 
+	/* Allow unaligned memory access */
+	allow_unaligned();
+
+	/* On ARM switch from EL3 or secure mode to EL2 or non-secure mode */
+	switch_to_non_secure_mode();
+
 	/* Define supported languages */
 	ret = efi_init_platform_lang();
 	if (ret != EFI_SUCCESS)
-- 
2.20.1

