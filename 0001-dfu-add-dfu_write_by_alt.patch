From 9c1936c00a476381da6ab8498ebdaac3123c9b17 Mon Sep 17 00:00:00 2001
From: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date: Thu, 29 Oct 2020 13:47:52 +0900
Subject: [PATCH] dfu: add dfu_write_by_alt()

This function is a variant of dfu_write_by_name() and takes a DFU alt
setting number for dfu configuration.

It will be utilised to implement UEFI capsule management protocol for
raw image in a later commit.

Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
Reviewed-by: Tom Rini <trini@konsulko.com>
---
 drivers/dfu/dfu_alt.c | 47 +++++++++++++++++++++++++++++++++++++++++++
 include/dfu.h         | 26 +++++++++++++++++++++++-
 2 files changed, 72 insertions(+), 1 deletion(-)

diff --git a/drivers/dfu/dfu_alt.c b/drivers/dfu/dfu_alt.c
index 7528806cd1..d582781207 100644
--- a/drivers/dfu/dfu_alt.c
+++ b/drivers/dfu/dfu_alt.c
@@ -76,3 +76,50 @@ done:
 
 	return ret;
 }
+
+/**
+ * dfu_write_by_alt() - write data to DFU medium
+ * @dfu_alt_num:        DFU alt setting number
+ * @addr:               Address of data buffer to write
+ * @len:                Number of bytes
+ * @interface:          Destination DFU medium (e.g. "mmc")
+ * @devstring:          Instance number of destination DFU medium (e.g. "1")
+ *
+ * This function is storing data received on DFU supported medium which
+ * is specified by @dfu_alt_name.
+ *
+ * Return:              0 - on success, error code - otherwise
+ */
+int dfu_write_by_alt(int dfu_alt_num, void *addr, unsigned int len,
+		     char *interface, char *devstring)
+{
+	struct dfu_entity *dfu;
+	int ret;
+
+	debug("%s: alt: %d addr: 0x%p len: %d device: %s:%s\n", __func__,
+	      dfu_alt_num, addr, len, interface, devstring);
+
+	ret = dfu_init_env_entities(interface, devstring);
+	if (ret)
+		goto done;
+
+	if (dfu_alt_num < 0) {
+		pr_err("Invalid alt number: %d", dfu_alt_num);
+		ret = -ENODEV;
+		goto done;
+	}
+
+	dfu = dfu_get_entity(dfu_alt_num);
+	if (!dfu) {
+		pr_err("DFU entity for alt: %d not found!", dfu_alt_num);
+		ret = -ENODEV;
+		goto done;
+	}
+
+	ret = dfu_write_from_mem_addr(dfu, (void *)(uintptr_t)addr, len);
+
+done:
+	dfu_free_entities();
+
+	return ret;
+}
diff --git a/include/dfu.h b/include/dfu.h
index eaf4bfc0d5..a767adee41 100644
--- a/include/dfu.h
+++ b/include/dfu.h
@@ -496,6 +496,7 @@ static inline int dfu_fill_entity_virt(struct dfu_entity *dfu, char *devstr,
 }
 #endif
 
+#if CONFIG_IS_ENABLED(DFU_WRITE_ALT)
 /**
  * dfu_write_by_name() - write data to DFU medium
  * @dfu_entity_name:	Name of DFU entity to write
@@ -509,9 +510,24 @@ static inline int dfu_fill_entity_virt(struct dfu_entity *dfu, char *devstr,
  *
  * Return:		0 - on success, error code - otherwise
  */
-#if CONFIG_IS_ENABLED(DFU_WRITE_ALT)
 int dfu_write_by_name(char *dfu_entity_name, void *addr,
 		      unsigned int len, char *interface, char *devstring);
+
+/**
+ * dfu_write_by_alt() - write data to DFU medium
+ * @dfu_alt_num:	DFU alt setting number
+ * @addr:		Address of data buffer to write
+ * @len:		Number of bytes
+ * @interface:		Destination DFU medium (e.g. "mmc")
+ * @devstring:		Instance number of destination DFU medium (e.g. "1")
+ *
+ * This function is storing data received on DFU supported medium which
+ * is specified by @dfu_alt_name.
+ *
+ * Return:		0 - on success, error code - otherwise
+ */
+int dfu_write_by_alt(int dfu_alt_num, void *addr, unsigned int len,
+		     char *interface, char *devstring);
 #else
 static inline int dfu_write_by_name(char *dfu_entity_name, void *addr,
 				    unsigned int len, char *interface,
@@ -520,6 +536,14 @@ static inline int dfu_write_by_name(char *dfu_entity_name, void *addr,
 	puts("write support for DFU not available!\n");
 	return -ENOSYS;
 }
+
+static inline int dfu_write_by_alt(int dfu_alt_num, void *addr,
+				   unsigned int len, char *interface,
+				   char *devstring)
+{
+	puts("write support for DFU not available!\n");
+	return -ENOSYS;
+}
 #endif
 
 int dfu_add(struct usb_configuration *c);
-- 
2.28.0

