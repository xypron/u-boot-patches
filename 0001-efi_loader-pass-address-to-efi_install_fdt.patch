From 2cd34531f97394a21840325b2fade20eea332688 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 28 Nov 2019 06:46:09 +0100
Subject: [PATCH v2 1/1] efi_loader: pass address to efi_install_fdt()

As part of moving the parsing of command line arguments to do_bootefi()
call efi_install_fdt() with the address of the device tree instead of a
string.

If the address is EFI_FDT_USE_INTERNAL (= 0), the internal device tree
is used.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v2
	provide constant EFI_FDT_USE_INTERNAL
---
 cmd/bootefi.c        | 32 ++++++++++++++++++--------------
 include/efi_loader.h |  3 +++
 2 files changed, 21 insertions(+), 14 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index f613cce7e2..2b190a3edd 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -196,40 +196,39 @@ static void *get_config_table(const efi_guid_t *guid)
 #endif /* !CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE) */
 
 /**
- * efi_install_fdt() - install fdt passed by a command argument
+ * efi_install_fdt() - install device tree
  *
- * If fdt_opt is available, the device tree located at that memory address will
+ * If fdt_addr is available, the device tree located at that memory address will
  * will be installed as configuration table, otherwise the device tree located
  * at the address indicated by environment variable fdtcontroladdr will be used.
  *
- * On architectures (x86) using ACPI tables device trees shall not be installed
- * as configuration table.
+ * On architectures using ACPI tables device trees shall not be installed as
+ * configuration table.
  *
- * @fdt_opt:	pointer to argument
+ * @fdt_addr:	address of device tree or EFI_FDT_USE_INTERNAL to use the
+ *		internal device tree as indicated by environment variable
+ *		fdtcontroladdr
  * Return:	status code
  */
-static efi_status_t efi_install_fdt(const char *fdt_opt)
+static efi_status_t efi_install_fdt(uintptr_t fdt_addr)
 {
 	/*
 	 * The EBBR spec requires that we have either an FDT or an ACPI table
 	 * but not both.
 	 */
 #if CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE)
-	if (fdt_opt) {
+	if (fdt_addr) {
 		printf("ERROR: can't have ACPI table and device tree.\n");
 		return EFI_LOAD_ERROR;
 	}
 #else
-	unsigned long fdt_addr;
 	void *fdt;
 	bootm_headers_t img = { 0 };
 	efi_status_t ret;
 
-	if (fdt_opt) {
-		fdt_addr = simple_strtoul(fdt_opt, NULL, 16);
-		if (!fdt_addr)
-			return EFI_INVALID_PARAMETER;
-	} else {
+	if (fdt_addr == EFI_FDT_USE_INTERNAL) {
+		const char *fdt_opt;
+
 		/* Look for device tree that is already installed */
 		if (get_config_table(&efi_guid_fdt))
 			return EFI_SUCCESS;
@@ -556,6 +555,7 @@ static int do_efi_selftest(void)
 static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	efi_status_t ret;
+	uintptr_t fdt_addr;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
@@ -568,7 +568,11 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		return CMD_RET_FAILURE;
 	}
 
-	ret = efi_install_fdt(argc > 2 ? argv[2] : NULL);
+	if (argc > 2)
+		fdt_addr = simple_strtoul(argv[2], NULL, 16);
+	else
+		fdt_addr = EFI_FDT_USE_INTERNAL;
+	ret = efi_install_fdt(fdt_addr);
 	if (ret == EFI_INVALID_PARAMETER)
 		return CMD_RET_USAGE;
 	else if (ret != EFI_SUCCESS)
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 16a1b258b1..3a22089329 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -34,6 +34,9 @@ static inline int guidcmp(const void *g1, const void *g2)
 	EFI_GUID(0xbbe4e671, 0x5773, 0x4ea1, \
 		 0x9a, 0xab, 0x3a, 0x7d, 0xbf, 0x40, 0xc4, 0x82)
 
+/* Use internal device tree when starting UEFI application */
+#define EFI_FDT_USE_INTERNAL 0UL
+
 /* Root node */
 extern efi_handle_t efi_root;
 
-- 
2.24.0

