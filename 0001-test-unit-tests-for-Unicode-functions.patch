From e715d6ab8bcfe3b268ed05579cea8ee22b3b5629 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Tue, 10 Jul 2018 18:47:25 +0200
Subject: [PATCH 1/1] test: unit tests for Unicode functions

Provide unit tests for Unicode functions.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 MAINTAINERS           |   1 +
 include/test/suites.h |   3 +-
 lib/Makefile          |   4 +-
 test/Kconfig          |   8 +
 test/Makefile         |   1 +
 test/cmd_ut.c         |  13 +-
 test/unicode_ut.c     | 388 ++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 413 insertions(+), 5 deletions(-)
 create mode 100644 test/unicode_ut.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 8f237128b2..46f826a0fe 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -387,6 +387,7 @@ F:	include/asm-generic/pe.h
 F:	lib/charset.c
 F:	lib/efi*/
 F:	test/py/tests/test_efi*
+F:	test/unicode_ut.c
 F:	cmd/bootefi.c
 F:	tools/file2include.c
 
diff --git a/include/test/suites.h b/include/test/suites.h
index 071ab4063e..abb3a4b816 100644
--- a/include/test/suites.h
+++ b/include/test/suites.h
@@ -23,10 +23,11 @@ struct unit_test;
 int cmd_ut_category(const char *name, struct unit_test *tests, int n_ents,
 		    int argc, char * const argv[]);
 
+int do_ut_compression(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[]);
 int do_ut_dm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 int do_ut_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 int do_ut_overlay(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 int do_ut_time(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
-int do_ut_compression(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[]);
+int do_ut_unicode(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 
 #endif /* __TEST_SUITES_H__ */
diff --git a/lib/Makefile b/lib/Makefile
index 2fd32798a0..f169644850 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -21,7 +21,9 @@ obj-$(CONFIG_OPTEE) += optee/
 obj-$(CONFIG_AES) += aes.o
 
 ifndef API_BUILD
-obj-$(CONFIG_EFI_LOADER) += charset.o
+ifneq ($(CONFIG_UT_UNICODE)$(CONFIG_EFI_LOADER),)
+obj-y += charset.o
+endif
 endif
 obj-$(CONFIG_USB_TTY) += circbuf.o
 obj-y += crc7.o
diff --git a/test/Kconfig b/test/Kconfig
index 3643761bc6..de16d179d0 100644
--- a/test/Kconfig
+++ b/test/Kconfig
@@ -15,6 +15,14 @@ config UT_TIME
 	  problems. But if you are having problems with udelay() and the like,
 	  this is a good place to start.
 
+config UT_UNICODE
+	bool "Unit tests for Unicode functions"
+	depends on UNIT_TEST
+	default y
+	help
+	  Enables the 'ut unicode' command which tests that the functions for
+	  manipulating Unicode strings work correctly.
+
 source "test/dm/Kconfig"
 source "test/env/Kconfig"
 source "test/overlay/Kconfig"
diff --git a/test/Makefile b/test/Makefile
index 1092011fdb..a5f52fd5ad 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -8,4 +8,5 @@ obj-$(CONFIG_SANDBOX) += command_ut.o
 obj-$(CONFIG_SANDBOX) += compression.o
 obj-$(CONFIG_SANDBOX) += print_ut.o
 obj-$(CONFIG_UT_TIME) += time_ut.o
+obj-$(CONFIG_UT_UNICODE) += unicode_ut.o
 obj-$(CONFIG_$(SPL_)LOG) += log/
diff --git a/test/cmd_ut.c b/test/cmd_ut.c
index 934a5a931b..f5a5b034b7 100644
--- a/test/cmd_ut.c
+++ b/test/cmd_ut.c
@@ -49,6 +49,9 @@ static cmd_tbl_t cmd_ut_sub[] = {
 #ifdef CONFIG_UT_TIME
 	U_BOOT_CMD_MKENT(time, CONFIG_SYS_MAXARGS, 1, do_ut_time, "", ""),
 #endif
+#if CONFIG_IS_ENABLED(UT_UNICODE) && !defined(API_BUILD)
+	U_BOOT_CMD_MKENT(unicode, CONFIG_SYS_MAXARGS, 1, do_ut_unicode, "", ""),
+#endif
 #ifdef CONFIG_SANDBOX
 	U_BOOT_CMD_MKENT(compression, CONFIG_SYS_MAXARGS, 1, do_ut_compression,
 			 "", ""),
@@ -93,6 +96,9 @@ static int do_ut(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 #ifdef CONFIG_SYS_LONGHELP
 static char ut_help_text[] =
 	"all - execute all enabled tests\n"
+#ifdef CONFIG_SANDBOX
+	"ut compression - Test compressors and bootm decompression\n"
+#endif
 #ifdef CONFIG_UT_DM
 	"ut dm [test-name]\n"
 #endif
@@ -105,11 +111,12 @@ static char ut_help_text[] =
 #ifdef CONFIG_UT_TIME
 	"ut time - Very basic test of time functions\n"
 #endif
-#ifdef CONFIG_SANDBOX
-	"ut compression - Test compressors and bootm decompression\n"
+#if defined(CONFIG_UT_UNICODE) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+	"ut unicode - test Unicode functions\n"
 #endif
 	;
-#endif
+#endif /* CONFIG_SYS_LONGHELP */
 
 U_BOOT_CMD(
 	ut, CONFIG_SYS_MAXARGS, 1, do_ut,
diff --git a/test/unicode_ut.c b/test/unicode_ut.c
new file mode 100644
index 0000000000..4672a44af2
--- /dev/null
+++ b/test/unicode_ut.c
@@ -0,0 +1,388 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Unit tests for Unicode functions
+ *
+ * Copyright (c) 2018 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ */
+
+#include <common.h>
+#include <charset.h>
+#include <command.h>
+#include <errno.h>
+#include <test/test.h>
+#include <test/ut.h>
+
+/* Constants c1-c4 and d1-d4 encode the same letters */
+
+/* Six characters translating to one utf-8 byte each. */
+static const u16 c1[] = {0x55, 0x2d, 0x42, 0x6f, 0x6f, 0x74, 0x00};
+/* One character translating to two utf-8 bytes */
+static const u16 c2[] = {0x6b, 0x61, 0x66, 0x62, 0xe1, 0x74, 0x75, 0x72, 0x00};
+/* Three characters translating to three utf-8 bytes each */
+static const u16 c3[] = {0x6f5c, 0x6c34, 0x8266, 0x00};
+/* Three letters translating to four utf-8 bytes each */
+static const u16 c4[] = {0xd801, 0xdc8d, 0xd801, 0xdc96, 0xd801, 0xdc87,
+			 0x0000};
+
+/* Six characters translating to one utf-16 word each. */
+static const char d1[] = {0x55, 0x2d, 0x42, 0x6f, 0x6f, 0x74, 0x00};
+/* Eight characters translating to one utf-16 word each */
+static const char d2[] = {0x6b, 0x61, 0x66, 0x62, 0xc3, 0xa1, 0x74, 0x75,
+			  0x72, 0x00};
+/* Three characters translating to one utf-16 word each */
+static const char d3[] = {0xe6, 0xbd, 0x9c, 0xe6, 0xb0, 0xb4, 0xe8, 0x89,
+			  0xa6, 0x00};
+/* Three letters translating to two utf-16 word each */
+static const char d4[] = {0xf0, 0x90, 0x92, 0x8d, 0xf0, 0x90, 0x92, 0x96,
+			  0xf0, 0x90, 0x92, 0x87, 0x00};
+
+static struct unit_test_state uts;
+
+static int ut_utf8_get(struct unit_test_state *uts)
+{
+	const char *s;
+	s32 code;
+	int i;
+
+	/* Check characters less than 0x800 */
+	s = d2;
+	for (i = 0; i < 8; ++i) {
+		code = utf8_get((const char **)&s);
+		/* c2 is the utf-8 encoding of d2 */
+		ut_asserteq(c2[i], code);
+		if (!code)
+			break;
+	}
+	ut_asserteq_ptr(s, d2 + 9)
+
+	/* Check characters less than 0x10000 */
+	s = d3;
+	for (i = 0; i < 4; ++i) {
+		code = utf8_get((const char **)&s);
+		/* c3 is the utf-8 encoding of d3 */
+		ut_asserteq(c3[i], code);
+		if (!code)
+			break;
+	}
+	ut_asserteq_ptr(s, d3 + 9)
+
+	/* Check character greater 0xffff */
+	s = d4;
+	code = utf8_get((const char **)&s);
+	ut_asserteq(0x0001048d, code);
+	ut_asserteq_ptr(s, d4 + 4);
+
+	return 0;
+}
+
+static int ut_utf8_put(struct unit_test_state *uts)
+{
+	char buffer[8] = { 0, };
+	char *pos;
+
+	/* Commercial at, translates to one character */
+	pos = buffer;
+	ut_assert(!utf8_put('@', &pos))
+	ut_asserteq(1, pos - buffer);
+	ut_asserteq('@', buffer[0]);
+	ut_assert(!buffer[1]);
+
+	/* Latin letter G with acute, translates to two charactes */
+	pos = buffer;
+	ut_assert(!utf8_put(0x1f4, &pos));
+	ut_asserteq(2, pos - buffer);
+	ut_asserteq_str("\xc7\xb4", buffer);
+
+	/* Tagalog letter i, translates to three characters */
+	pos = buffer;
+	ut_assert(!utf8_put(0x1701, &pos));
+	ut_asserteq(3, pos - buffer);
+	ut_asserteq_str("\xe1\x9c\x81", buffer);
+
+	/* Hamster face, translates to four characters */
+	pos = buffer;
+	ut_assert(!utf8_put(0x1f439, &pos));
+	ut_asserteq(4, pos - buffer);
+	ut_asserteq_str("\xf0\x9f\x90\xb9", buffer);
+
+	/* Illegal code */
+	pos = buffer;
+	ut_asserteq(-1, utf8_put(0xd888, &pos));
+
+	return 0;
+}
+
+static int ut_utf8_utf16_strlen(struct unit_test_state *uts)
+{
+	ut_asserteq(6, utf8_utf16_strlen(d1));
+	ut_asserteq(8, utf8_utf16_strlen(d2));
+	ut_asserteq(3, utf8_utf16_strlen(d3));
+	ut_asserteq(6, utf8_utf16_strlen(d4));
+	return 0;
+}
+
+static int ut_utf8_utf16_strnlen(struct unit_test_state *uts)
+{
+	ut_asserteq(3, utf8_utf16_strnlen(d1, 3));
+	ut_asserteq(6, utf8_utf16_strnlen(d1, 13));
+	ut_asserteq(6, utf8_utf16_strnlen(d2, 6));
+	ut_asserteq(2, utf8_utf16_strnlen(d3, 2));
+	ut_asserteq(4, utf8_utf16_strnlen(d4, 2));
+	ut_asserteq(6, utf8_utf16_strnlen(d4, 3));
+	return 0;
+}
+
+/**
+ * ut_u16_strcmp() - Compare to u16 strings.
+ *
+ * @a1:		first string
+ * @a2:		second string
+ * @count:	number of u16 to compare
+ * Return:	-1 if a1 < a2, 0 if a1 == a2, 1 if a1 > a2
+ */
+static int ut_u16_strcmp(const u16 *a1, const u16 *a2, size_t count)
+{
+	for (; (*a1 || *a2) && count; ++a1, ++a2, --count) {
+		if (*a1 < *a2)
+			return -1;
+		if (*a1 > *a2)
+			return 1;
+	}
+	return 0;
+}
+
+static int ut_utf8_utf16_strcpy(struct unit_test_state *uts)
+{
+	u16 buf[16];
+	u16 *pos;
+
+	pos = buf;
+	utf8_utf16_strcpy(&pos, d1);
+	ut_asserteq(6, pos - buf);
+	ut_assert(!ut_u16_strcmp(buf, c1, 16));
+
+	pos = buf;
+	utf8_utf16_strcpy(&pos, d2);
+	ut_asserteq(8, pos - buf);
+	ut_assert(!ut_u16_strcmp(buf, c2, 16));
+
+	pos = buf;
+	utf8_utf16_strcpy(&pos, d3);
+	ut_asserteq(3, pos - buf);
+	ut_assert(!ut_u16_strcmp(buf, c3, 16));
+
+	pos = buf;
+	utf8_utf16_strcpy(&pos, d4);
+	ut_asserteq(6, pos - buf);
+	ut_assert(!ut_u16_strcmp(buf, c4, 16));
+
+	return 0;
+}
+
+int ut_utf8_utf16_strncpy(struct unit_test_state *uts)
+{
+	u16 buf[16];
+	u16 *pos;
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf8_utf16_strncpy(&pos, d1, 4);
+	ut_asserteq(4, pos - buf);
+	ut_assert(!buf[4]);
+	ut_assert(!ut_u16_strcmp(buf, c1, 4))
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf8_utf16_strncpy(&pos, d2, 10);
+	ut_asserteq(8, pos - buf);
+	ut_assert(buf[4]);
+	ut_assert(!ut_u16_strcmp(buf, c2, SIZE_MAX))
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf8_utf16_strncpy(&pos, d3, 2);
+	ut_asserteq(2, pos - buf);
+	ut_assert(!buf[2]);
+	ut_assert(!ut_u16_strcmp(buf, c3, 2));
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf8_utf16_strncpy(&pos, d4, 2);
+	ut_asserteq(4, pos - buf);
+	ut_assert(!buf[4]);
+	ut_assert(!ut_u16_strcmp(buf, c4, 4));
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf8_utf16_strncpy(&pos, d4, 10);
+	ut_asserteq(6, pos - buf);
+	ut_assert(buf[5]);
+	ut_assert(!ut_u16_strcmp(buf, c4, SIZE_MAX));
+
+	return 0;
+}
+
+static int ut_utf16_get(struct unit_test_state *uts)
+{
+	const u16 *s;
+	s32 code;
+	int i;
+
+	/* Check characters less than 0x10000 */
+	s = c2;
+	for (i = 0; i < 9; ++i) {
+		code = utf16_get((const u16 **)&s);
+		ut_asserteq(c2[i], code);
+		if (!code)
+			break;
+	}
+	ut_asserteq_ptr(c2 + 8, s);
+
+	/* Check character greater 0xffff */
+	s = c4;
+	code = utf16_get((const u16 **)&s);
+	ut_asserteq(0x0001048d, code);
+	ut_asserteq_ptr(c4 + 2, s);
+
+	return 0;
+}
+
+static int ut_utf16_put(struct unit_test_state *uts)
+{
+	u16 buffer[4] = { 0, };
+	u16 *pos;
+
+	/* Commercial at, translates to one word */
+	pos = buffer;
+	ut_assert(!utf16_put('@', &pos));
+	ut_asserteq(1, pos - buffer);
+	ut_asserteq((u16)'@', buffer[0]);
+	ut_assert(!buffer[1]);
+
+	/* Hamster face, translates to two words */
+	pos = buffer;
+	ut_assert(!utf16_put(0x1f439, &pos));
+	ut_asserteq(2, pos - buffer);
+	ut_asserteq((u16)0xd83d, buffer[0]);
+	ut_asserteq((u16)0xdc39, buffer[1]);
+	ut_assert(!buffer[2]);
+
+	/* Illegal code */
+	pos = buffer;
+	ut_asserteq(-1, utf16_put(0xd888, &pos));
+
+	return 0;
+}
+
+int ut_utf16_utf8_strlen(struct unit_test_state *uts)
+{
+	ut_asserteq(6, utf16_utf8_strlen(c1));
+	ut_asserteq(9, utf16_utf8_strlen(c2));
+	ut_asserteq(9, utf16_utf8_strlen(c3));
+	ut_asserteq(12, utf16_utf8_strlen(c4));
+	return 0;
+}
+
+int ut_utf16_utf8_strnlen(struct unit_test_state *uts)
+{
+	ut_asserteq(3, utf16_utf8_strnlen(c1, 3));
+	ut_asserteq(6, utf16_utf8_strnlen(c1, 13));
+	ut_asserteq(7, utf16_utf8_strnlen(c2, 6));
+	ut_asserteq(6, utf16_utf8_strnlen(c3, 2));
+	ut_asserteq(8, utf16_utf8_strnlen(c4, 2));
+	ut_asserteq(12, utf16_utf8_strnlen(c4, 3));
+	return 0;
+}
+
+int ut_utf16_utf8_strcpy(struct unit_test_state *uts)
+{
+	char buf[16];
+	char *pos;
+
+	pos = buf;
+	utf16_utf8_strcpy(&pos, c1);
+	ut_asserteq(6, pos - buf);
+	ut_asserteq_str(d1, buf);
+
+	pos = buf;
+	utf16_utf8_strcpy(&pos, c2);
+	ut_asserteq(9, pos - buf);
+	ut_asserteq_str(d2, buf);
+
+	pos = buf;
+	utf16_utf8_strcpy(&pos, c3);
+	ut_asserteq(9, pos - buf);
+	ut_asserteq_str(d3, buf);
+
+	pos = buf;
+	utf16_utf8_strcpy(&pos, c4);
+	ut_asserteq(12, pos - buf);
+	ut_asserteq_str(d4, buf);
+
+	return 0;
+}
+
+int ut_utf16_utf8_strncpy(struct unit_test_state *uts)
+{
+	char buf[16];
+	char *pos;
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf16_utf8_strncpy(&pos, c1, 4);
+	ut_asserteq(4, pos - buf);
+	ut_assert(!buf[4]);
+	ut_assert(!strncmp(buf, d1, 4));
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf16_utf8_strncpy(&pos, c2, 10);
+	ut_asserteq(9, pos - buf);
+	ut_assert(buf[4]);
+	ut_assert(!strncmp(buf, d2, SIZE_MAX));
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf16_utf8_strncpy(&pos, c3, 2);
+	ut_asserteq(6, pos - buf);
+	ut_assert(!buf[6]);
+	ut_assert(!strncmp(buf, d3, 6));
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf16_utf8_strncpy(&pos, c4, 2);
+	ut_asserteq(8, pos - buf);
+	ut_assert(!buf[8]);
+	ut_assert(!strncmp(buf, d4, 8));
+
+	pos = buf;
+	memset(buf, 0, sizeof(buf));
+	utf16_utf8_strncpy(&pos, c4, 10);
+	ut_asserteq(12, pos - buf);
+	ut_assert(buf[5]);
+	ut_assert(!strncmp(buf, d4, SIZE_MAX));
+
+	return 0;
+}
+
+int do_ut_unicode(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+
+	ret |= ut_utf8_get(&uts);
+	ret |= ut_utf8_put(&uts);
+	ret |= ut_utf8_utf16_strlen(&uts);
+	ret |= ut_utf8_utf16_strnlen(&uts);
+	ret |= ut_utf8_utf16_strcpy(&uts);
+	ret |= ut_utf8_utf16_strncpy(&uts);
+	ret |= ut_utf16_get(&uts);
+	ret |= ut_utf16_put(&uts);
+	ret |= ut_utf16_utf8_strlen(&uts);
+	ret |= ut_utf16_utf8_strnlen(&uts);
+	ret |= ut_utf16_utf8_strcpy(&uts);
+	ret |= ut_utf16_utf8_strncpy(&uts);
+
+	printf("Test %s\n", ret ? "failed" : "passed");
+
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
+}
-- 
2.18.0

