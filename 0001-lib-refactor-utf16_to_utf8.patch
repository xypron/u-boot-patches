From 9729220d4a44d9b984883495d9724d0b6ab46e8f Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 5 Jul 2018 12:42:09 +0200
Subject: [PATCH 1/1] lib: refactor utf16_to_utf8()

Extract function utf16_next() from utf16_to_utf8().

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/charset.c | 96 ++++++++++++++++++++++++++++-----------------------
 1 file changed, 53 insertions(+), 43 deletions(-)

diff --git a/lib/charset.c b/lib/charset.c
index cd186a5a5a..39cf37f6bb 100644
--- a/lib/charset.c
+++ b/lib/charset.c
@@ -8,6 +8,37 @@
 #include <charset.h>
 #include <malloc.h>
 
+/**
+ * utf16_next - get next UTF-16 code point
+ *
+ * @src:		pointer to current word, updated to point to next word
+ * ReturnValue:		code point, or 0 for end of string, or -1 if no legal
+ *			code point is found. In case of an error src points to
+ *			the incorrect word.
+ */
+static s32 utf16_next(const u16 **src) {
+	u32 code, code2;
+
+	if (!**src)
+		return 0;
+	code = **src;
+	++*src;
+	if (code >= 0xD800 && code <= 0xDBFF) {
+		if (!**src)
+			return -1;
+		code &= 0x3ff;
+		code <<= 10;
+		code += 0x10000;
+		code2 = **src;
+		if (code2 <= 0xDC00 || code2 >= 0xDFFF)
+			return -1;
+		++*src;
+		code2 &= 0x3ff;
+		code += code2;
+	}
+	return code;
+}
+
 /*
  * utf8/utf16 conversion mostly lifted from grub
  */
@@ -48,50 +79,29 @@ uint16_t *utf16_strdup(const uint16_t *s)
 /* Convert UTF-16 to UTF-8.  */
 uint8_t *utf16_to_utf8(uint8_t *dest, const uint16_t *src, size_t size)
 {
-	uint32_t code_high = 0;
-
-	while (size--) {
-		uint32_t code = *src++;
-
-		if (code_high) {
-			if (code >= 0xDC00 && code <= 0xDFFF) {
-				/* Surrogate pair.  */
-				code = ((code_high - 0xD800) << 10) + (code - 0xDC00) + 0x10000;
-
-				*dest++ = (code >> 18) | 0xF0;
-				*dest++ = ((code >> 12) & 0x3F) | 0x80;
-				*dest++ = ((code >> 6) & 0x3F) | 0x80;
-				*dest++ = (code & 0x3F) | 0x80;
-			} else {
-				/* Error...  */
-				*dest++ = '?';
-				/* *src may be valid. Don't eat it.  */
-				src--;
-			}
-
-			code_high = 0;
+	s32 code;
+
+	for (;;) {
+		code = utf16_next(&src);
+		if (!code)
+			break;
+		if (code < 0) {
+			*dest++ = '?';
+		} else if (code <= 0x007F) {
+			*dest++ = code;
+		} else if (code <= 0x07FF) {
+			*dest++ = (code >> 6) | 0xC0;
+			*dest++ = (code & 0x3F) | 0x80;
+			*dest++ = '?';
+		} else if (code < 0x10000) {
+			*dest++ = (code >> 12) | 0xE0;
+			*dest++ = ((code >> 6) & 0x3F) | 0x80;
+			*dest++ = (code & 0x3F) | 0x80;
 		} else {
-			if (code <= 0x007F) {
-				*dest++ = code;
-			} else if (code <= 0x07FF) {
-				*dest++ = (code >> 6) | 0xC0;
-				*dest++ = (code & 0x3F) | 0x80;
-			} else if (code >= 0xD800 && code <= 0xDBFF) {
-				code_high = code;
-				continue;
-			} else if (code >= 0xDC00 && code <= 0xDFFF) {
-				/* Error... */
-				*dest++ = '?';
-			} else if (code < 0x10000) {
-				*dest++ = (code >> 12) | 0xE0;
-				*dest++ = ((code >> 6) & 0x3F) | 0x80;
-				*dest++ = (code & 0x3F) | 0x80;
-			} else {
-				*dest++ = (code >> 18) | 0xF0;
-				*dest++ = ((code >> 12) & 0x3F) | 0x80;
-				*dest++ = ((code >> 6) & 0x3F) | 0x80;
-				*dest++ = (code & 0x3F) | 0x80;
-			}
+			*dest++ = (code >> 18) | 0xF0;
+			*dest++ = ((code >> 12) & 0x3F) | 0x80;
+			*dest++ = ((code >> 6) & 0x3F) | 0x80;
+			*dest++ = (code & 0x3F) | 0x80;
 		}
 	}
 
-- 
2.18.0

