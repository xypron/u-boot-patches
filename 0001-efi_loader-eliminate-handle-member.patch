From f523dcf4b7cb10ff014f5b7286c0b4053feedeb8 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 24 Sep 2018 19:46:35 +0200
Subject: [PATCH 1/1] efi_loader: eliminate handle member

A pointer to a struct efi_object is a handle. We do not need any handle
member in this structure. Let's eliminate it.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h             | 26 +++++++++-----
 lib/efi_loader/efi_boottime.c    | 59 ++++++++++++++++----------------
 lib/efi_loader/efi_console.c     | 20 +++++------
 lib/efi_loader/efi_device_path.c |  2 +-
 lib/efi_loader/efi_disk.c        |  8 ++---
 lib/efi_loader/efi_gop.c         |  2 +-
 lib/efi_loader/efi_net.c         |  6 ++--
 7 files changed, 65 insertions(+), 58 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 74df070316..6846bb03f3 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -173,20 +173,28 @@ struct efi_handler {
 	struct list_head open_infos;
 };
 
-/*
- * UEFI has a poor man's OO model where one "object" can be polymorphic and have
- * multiple different protocols (classes) attached to it.
+/**
+ * struct efi_object - dereferenced EFI handle
+ *
+ * @link:	pointers to put the handle into a linked list
+ * @protocols:	linked list with the protocol interfaces installed on this
+ *		handle
+ *
+ * UEFI offers a flexible and expandable object model. The objects in the UEFI
+ * API are devices, drivers, and loaded images. struct efi_object is our storage
+ * structure for these objects.
+ *
+ * When including this structure into a larger structure always put it first so
+ * that when deleting a handle the whole encompassing structure can be freed.
  *
- * This struct is the parent struct for all of our actual implementation objects
- * that can include it to make themselves an EFI object
+ * A pointer to this structure is referred to as a handle. Typedef efi_handle_t
+ * has been created for such pointers.
  */
 struct efi_object {
 	/* Every UEFI object is part of a global object list */
 	struct list_head link;
 	/* The list of protocols */
 	struct list_head protocols;
-	/* The object spawner can either use this for data or as identifier */
-	void *handle;
 };
 
 /**
@@ -296,11 +304,11 @@ void efi_runtime_relocate(ulong offset, struct efi_mem_desc *map);
 /* Call this to set the current device name */
 void efi_set_bootdev(const char *dev, const char *devnr, const char *path);
 /* Add a new object to the object list. */
-void efi_add_handle(struct efi_object *obj);
+void efi_add_handle(efi_handle_t obj);
 /* Create handle */
 efi_status_t efi_create_handle(efi_handle_t *handle);
 /* Delete handle */
-void efi_delete_handle(struct efi_object *obj);
+void efi_delete_handle(efi_handle_t obj);
 /* Call this to validate a handle and find the EFI object for it */
 struct efi_object *efi_search_obj(const efi_handle_t handle);
 /* Find a protocol on a handle */
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 20974f98f6..d1c4b26297 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -416,13 +416,12 @@ static efi_status_t EFIAPI efi_free_pool_ext(void *buffer)
  *
  * The protocols list is initialized. The object handle is set.
  */
-void efi_add_handle(struct efi_object *obj)
+void efi_add_handle(efi_handle_t handle)
 {
-	if (!obj)
+	if (!handle)
 		return;
-	INIT_LIST_HEAD(&obj->protocols);
-	obj->handle = obj;
-	list_add_tail(&obj->link, &efi_obj_list);
+	INIT_LIST_HEAD(&handle->protocols);
+	list_add_tail(&handle->link, &efi_obj_list);
 }
 
 /**
@@ -440,7 +439,7 @@ efi_status_t efi_create_handle(efi_handle_t *handle)
 		return EFI_OUT_OF_RESOURCES;
 
 	efi_add_handle(obj);
-	*handle = obj->handle;
+	*handle = obj;
 
 	return EFI_SUCCESS;
 }
@@ -536,13 +535,13 @@ efi_status_t efi_remove_all_protocols(const efi_handle_t handle)
  *
  * @obj: handle to delete
  */
-void efi_delete_handle(struct efi_object *obj)
+void efi_delete_handle(efi_handle_t handle)
 {
-	if (!obj)
+	if (!handle)
 		return;
-	efi_remove_all_protocols(obj->handle);
-	list_del(&obj->link);
-	free(obj);
+	efi_remove_all_protocols(handle);
+	list_del(&handle->link);
+	free(handle);
 }
 
 /**
@@ -927,7 +926,7 @@ struct efi_object *efi_search_obj(const efi_handle_t handle)
 	struct efi_object *efiobj;
 
 	list_for_each_entry(efiobj, &efi_obj_list, link) {
-		if (efiobj->handle == handle)
+		if (efiobj == handle)
 			return efiobj;
 	}
 
@@ -1052,7 +1051,7 @@ out:
 
 /**
  * efi_get_drivers() - get all drivers associated to a controller
- * @efiobj:               handle of the controller
+ * @handle:               handle of the controller
  * @protocol:             protocol GUID (optional)
  * @number_of_drivers:    number of child controllers
  * @driver_handle_buffer: handles of the the drivers
@@ -1061,7 +1060,7 @@ out:
  *
  * Return: status code
  */
-static efi_status_t efi_get_drivers(struct efi_object *efiobj,
+static efi_status_t efi_get_drivers(efi_handle_t handle,
 				    const efi_guid_t *protocol,
 				    efi_uintn_t *number_of_drivers,
 				    efi_handle_t **driver_handle_buffer)
@@ -1072,7 +1071,7 @@ static efi_status_t efi_get_drivers(struct efi_object *efiobj,
 	bool duplicate;
 
 	/* Count all driver associations */
-	list_for_each_entry(handler, &efiobj->protocols, link) {
+	list_for_each_entry(handler, &handle->protocols, link) {
 		if (protocol && guidcmp(handler->guid, protocol))
 			continue;
 		list_for_each_entry(item, &handler->open_infos, link) {
@@ -1090,7 +1089,7 @@ static efi_status_t efi_get_drivers(struct efi_object *efiobj,
 	if (!*driver_handle_buffer)
 		return EFI_OUT_OF_RESOURCES;
 	/* Collect unique driver handles */
-	list_for_each_entry(handler, &efiobj->protocols, link) {
+	list_for_each_entry(handler, &handle->protocols, link) {
 		if (protocol && guidcmp(handler->guid, protocol))
 			continue;
 		list_for_each_entry(item, &handler->open_infos, link) {
@@ -1117,7 +1116,7 @@ static efi_status_t efi_get_drivers(struct efi_object *efiobj,
 
 /**
  * efi_disconnect_all_drivers() - disconnect all drivers from a controller
- * @efiobj:       handle of the controller
+ * @handle:       handle of the controller
  * @protocol:     protocol GUID (optional)
  * @child_handle: handle of the child to destroy
  *
@@ -1128,16 +1127,16 @@ static efi_status_t efi_get_drivers(struct efi_object *efiobj,
  *
  * Return: status code
  */
-static efi_status_t efi_disconnect_all_drivers(
-				struct efi_object *efiobj,
-				const efi_guid_t *protocol,
-				efi_handle_t child_handle)
+static efi_status_t efi_disconnect_all_drivers
+				(efi_handle_t handle,
+				 const efi_guid_t *protocol,
+				 efi_handle_t child_handle)
 {
 	efi_uintn_t number_of_drivers;
 	efi_handle_t *driver_handle_buffer;
 	efi_status_t r, ret;
 
-	ret = efi_get_drivers(efiobj, protocol, &number_of_drivers,
+	ret = efi_get_drivers(handle, protocol, &number_of_drivers,
 			      &driver_handle_buffer);
 	if (ret != EFI_SUCCESS)
 		return ret;
@@ -1145,7 +1144,7 @@ static efi_status_t efi_disconnect_all_drivers(
 	ret = EFI_NOT_FOUND;
 	while (number_of_drivers) {
 		r = EFI_CALL(efi_disconnect_controller(
-				efiobj->handle,
+				handle,
 				driver_handle_buffer[--number_of_drivers],
 				child_handle));
 		if (r == EFI_SUCCESS)
@@ -1240,7 +1239,7 @@ static efi_status_t EFIAPI efi_register_protocol_notify(
  * @search_type: selection criterion
  * @protocol:    GUID of the protocol
  * @search_key:  registration key
- * @efiobj:      handle
+ * @handle:      handle
  *
  * See the documentation of the LocateHandle service in the UEFI specification.
  *
@@ -1248,7 +1247,7 @@ static efi_status_t EFIAPI efi_register_protocol_notify(
  */
 static int efi_search(enum efi_locate_search_type search_type,
 		      const efi_guid_t *protocol, void *search_key,
-		      struct efi_object *efiobj)
+		      efi_handle_t handle)
 {
 	efi_status_t ret;
 
@@ -1259,7 +1258,7 @@ static int efi_search(enum efi_locate_search_type search_type,
 		/* TODO: RegisterProtocolNotify is not implemented yet */
 		return -1;
 	case BY_PROTOCOL:
-		ret = efi_search_protocol(efiobj->handle, protocol, NULL);
+		ret = efi_search_protocol(handle, protocol, NULL);
 		return (ret != EFI_SUCCESS);
 	default:
 		/* Invalid search type */
@@ -1331,7 +1330,7 @@ static efi_status_t efi_locate_handle(
 	/* Then fill the array */
 	list_for_each_entry(efiobj, &efi_obj_list, link) {
 		if (!efi_search(search_type, protocol, search_key, efiobj))
-			*buffer++ = efiobj->handle;
+			*buffer++ = efiobj;
 	}
 
 	return EFI_SUCCESS;
@@ -1506,7 +1505,7 @@ efi_status_t efi_setup_loaded_image(struct efi_device_path *device_path,
 		 * When asking for the device path interface, return
 		 * bootefi_device_path
 		 */
-		ret = efi_add_protocol(obj->parent.handle,
+		ret = efi_add_protocol(&obj->parent,
 				       &efi_guid_device_path, device_path);
 		if (ret != EFI_SUCCESS)
 			goto failure;
@@ -1516,7 +1515,7 @@ efi_status_t efi_setup_loaded_image(struct efi_device_path *device_path,
 	 * When asking for the loaded_image interface, just
 	 * return handle which points to loaded_image_info
 	 */
-	ret = efi_add_protocol(obj->parent.handle,
+	ret = efi_add_protocol(&obj->parent,
 			       &efi_guid_loaded_image, info);
 	if (ret != EFI_SUCCESS)
 		goto failure;
@@ -2176,7 +2175,7 @@ static efi_status_t EFIAPI efi_locate_protocol(const efi_guid_t *protocol,
 
 		efiobj = list_entry(lhandle, struct efi_object, link);
 
-		ret = efi_search_protocol(efiobj->handle, protocol, &handler);
+		ret = efi_search_protocol(efiobj, protocol, &handler);
 		if (ret == EFI_SUCCESS) {
 			*protocol_interface = handler->protocol_interface;
 			return EFI_EXIT(EFI_SUCCESS);
diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index 7ecdbb1666..eb086bc219 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -1049,34 +1049,34 @@ static void EFIAPI efi_key_notify(struct efi_event *event, void *context)
 int efi_console_register(void)
 {
 	efi_status_t r;
-	struct efi_object *efi_console_output_obj;
-	struct efi_object *efi_console_input_obj;
+	efi_handle_t console_output_handle;
+	efi_handle_t console_input_handle;
 
 	/* Set up mode information */
 	query_console_size();
 
 	/* Create handles */
-	r = efi_create_handle((efi_handle_t *)&efi_console_output_obj);
+	r = efi_create_handle(&console_output_handle);
 	if (r != EFI_SUCCESS)
 		goto out_of_memory;
 
-	r = efi_add_protocol(efi_console_output_obj->handle,
+	r = efi_add_protocol(console_output_handle,
 			     &efi_guid_text_output_protocol, &efi_con_out);
 	if (r != EFI_SUCCESS)
 		goto out_of_memory;
-	systab.con_out_handle = efi_console_output_obj->handle;
-	systab.stderr_handle = efi_console_output_obj->handle;
+	systab.con_out_handle = console_output_handle;
+	systab.stderr_handle = console_output_handle;
 
-	r = efi_create_handle((efi_handle_t *)&efi_console_input_obj);
+	r = efi_create_handle(&console_input_handle);
 	if (r != EFI_SUCCESS)
 		goto out_of_memory;
 
-	r = efi_add_protocol(efi_console_input_obj->handle,
+	r = efi_add_protocol(console_input_handle,
 			     &efi_guid_text_input_protocol, &efi_con_in);
 	if (r != EFI_SUCCESS)
 		goto out_of_memory;
-	systab.con_in_handle = efi_console_input_obj->handle;
-	r = efi_add_protocol(efi_console_input_obj->handle,
+	systab.con_in_handle = console_input_handle;
+	r = efi_add_protocol(console_input_handle,
 			     &efi_guid_text_input_ex_protocol, &efi_con_in_ex);
 	if (r != EFI_SUCCESS)
 		goto out_of_memory;
diff --git a/lib/efi_loader/efi_device_path.c b/lib/efi_loader/efi_device_path.c
index 46a24f7882..2b5d067104 100644
--- a/lib/efi_loader/efi_device_path.c
+++ b/lib/efi_loader/efi_device_path.c
@@ -150,7 +150,7 @@ static struct efi_object *find_obj(struct efi_device_path *dp, bool short_path,
 		struct efi_device_path *obj_dp;
 		efi_status_t ret;
 
-		ret = efi_search_protocol(efiobj->handle,
+		ret = efi_search_protocol(efiobj,
 					  &efi_guid_device_path, &handler);
 		if (ret != EFI_SUCCESS)
 			continue;
diff --git a/lib/efi_loader/efi_disk.c b/lib/efi_loader/efi_disk.c
index 13fcc1b471..e62c2f3ccb 100644
--- a/lib/efi_loader/efi_disk.c
+++ b/lib/efi_loader/efi_disk.c
@@ -258,18 +258,18 @@ static efi_status_t efi_disk_add_dev(
 		diskobj->dp = efi_dp_from_part(desc, part);
 	}
 	diskobj->part = part;
-	ret = efi_add_protocol(diskobj->parent.handle, &efi_block_io_guid,
+	ret = efi_add_protocol(&diskobj->parent, &efi_block_io_guid,
 			       &diskobj->ops);
 	if (ret != EFI_SUCCESS)
 		return ret;
-	ret = efi_add_protocol(diskobj->parent.handle, &efi_guid_device_path,
+	ret = efi_add_protocol(&diskobj->parent, &efi_guid_device_path,
 			       diskobj->dp);
 	if (ret != EFI_SUCCESS)
 		return ret;
 	if (part >= 1) {
 		diskobj->volume = efi_simple_file_system(desc, part,
 							 diskobj->dp);
-		ret = efi_add_protocol(diskobj->parent.handle,
+		ret = efi_add_protocol(&diskobj->parent,
 				       &efi_simple_file_system_protocol_guid,
 				       diskobj->volume);
 		if (ret != EFI_SUCCESS)
@@ -381,7 +381,7 @@ efi_status_t efi_disk_register(void)
 
 		/* Partitions show up as block devices in EFI */
 		disks += efi_disk_create_partitions(
-					disk->parent.handle, desc, if_typename,
+					&disk->parent, desc, if_typename,
 					desc->devnum, dev->name);
 	}
 #else
diff --git a/lib/efi_loader/efi_gop.c b/lib/efi_loader/efi_gop.c
index a4aa9bcf61..a13c626f6f 100644
--- a/lib/efi_loader/efi_gop.c
+++ b/lib/efi_loader/efi_gop.c
@@ -442,7 +442,7 @@ efi_status_t efi_gop_register(void)
 	efi_add_handle(&gopobj->parent);
 
 	/* Fill in object data */
-	ret = efi_add_protocol(gopobj->parent.handle, &efi_gop_guid,
+	ret = efi_add_protocol(&gopobj->parent, &efi_gop_guid,
 			       &gopobj->ops);
 	if (ret != EFI_SUCCESS) {
 		printf("ERROR: Failure adding gop protocol\n");
diff --git a/lib/efi_loader/efi_net.c b/lib/efi_loader/efi_net.c
index 034d0d2ed0..d4b39b9e76 100644
--- a/lib/efi_loader/efi_net.c
+++ b/lib/efi_loader/efi_net.c
@@ -329,15 +329,15 @@ efi_status_t efi_net_register(void)
 	efi_add_handle(&netobj->parent);
 
 	/* Fill in object data */
-	r = efi_add_protocol(netobj->parent.handle, &efi_net_guid,
+	r = efi_add_protocol(&netobj->parent, &efi_net_guid,
 			     &netobj->net);
 	if (r != EFI_SUCCESS)
 		goto failure_to_add_protocol;
-	r = efi_add_protocol(netobj->parent.handle, &efi_guid_device_path,
+	r = efi_add_protocol(&netobj->parent, &efi_guid_device_path,
 			     efi_dp_from_eth());
 	if (r != EFI_SUCCESS)
 		goto failure_to_add_protocol;
-	r = efi_add_protocol(netobj->parent.handle, &efi_pxe_guid,
+	r = efi_add_protocol(&netobj->parent, &efi_pxe_guid,
 			     &netobj->pxe);
 	if (r != EFI_SUCCESS)
 		goto failure_to_add_protocol;
-- 
2.19.0

