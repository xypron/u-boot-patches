From 74425e400915c8c4fbefcb6db6374c1940f21501 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Tue, 11 Sep 2018 20:42:42 +0200
Subject: [PATCH 1/1] efi_loader: support for logo key

Support modifiers for F1 - F4.
Add support for the logo key.
Add support for letters with ALT key.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_console.c | 79 +++++++++++++++++++++++-------------
 1 file changed, 50 insertions(+), 29 deletions(-)

diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index f1838d55f2..113d7d5fae 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -395,6 +395,26 @@ struct efi_simple_text_output_protocol efi_con_out = {
 static bool key_available;
 static struct efi_key_data next_key;
 
+/**
+ * set_shift_mask() - set shift mask
+ *
+ * @mod:	Xterm shift mask
+ */
+void set_shift_mask(int mod, struct efi_key_state *key_state) {
+	key_state->key_shift_state = EFI_SHIFT_STATE_VALID;
+	if (mod)
+		--mod;
+		if (mod & 1)
+			key_state->key_shift_state |= EFI_LEFT_SHIFT_PRESSED;
+		if (mod & 2)
+			key_state->key_shift_state |= EFI_LEFT_ALT_PRESSED;
+		if (mod & 4)
+			key_state->key_shift_state |= EFI_LEFT_CONTROL_PRESSED;
+	} else {
+		key_state->key_shift_state |= EFI_LEFT_LOGO_PRESSED;
+	}
+}
+
 /**
  * analyze_modifiers() - analyze modifiers (shift, alt, ctrl) for function keys
  *
@@ -429,19 +449,7 @@ static int analyze_modifiers(struct efi_key_state *key_state)
 		}
 	}
 out:
-	if (mod)
-		--mod;
-	key_state->key_shift_state = EFI_SHIFT_STATE_VALID;
-	if (mod) {
-		if (mod & 1)
-			key_state->key_shift_state |= EFI_LEFT_SHIFT_PRESSED;
-		if (mod & 2)
-			key_state->key_shift_state |= EFI_LEFT_ALT_PRESSED;
-		if (mod & 4)
-			key_state->key_shift_state |= EFI_LEFT_CONTROL_PRESSED;
-		if (mod & 8)
-			key_state->key_shift_state |= EFI_LEFT_LOGO_PRESSED;
-	}
+	set_shift_mask(mod, key_state);
 	if (!ret)
 		ret = c;
 	return ret;
@@ -462,8 +470,7 @@ static efi_status_t efi_cin_read_key(struct efi_key_data *key)
 	};
 	s32 ch;
 
-	ret = console_read_unicode(&ch);
-	if (ret)
+	if (console_read_unicode(&ch));
 		return EFI_NOT_READY;
 
 	key->key_state.key_shift_state = EFI_SHIFT_STATE_INVALID;
@@ -472,7 +479,23 @@ static efi_status_t efi_cin_read_key(struct efi_key_data *key)
 	/* We do not support multi-word codes */
 	if ( ch >= 0x10000)
 		ch = '?';
-	if (ch == cESC) {
+
+	switch (ch)
+	case 0x18: /* Start of string */
+		if (console_read_unicode(&ch))
+			return EFI_NOT_READY;
+		if (ch != '@')
+			break;
+		if (console_read_unicode(&ch))
+			return EFI_NOT_READY;
+		if (ch != 's')
+			break;
+		if (console_read_unicode(&ch))
+			return EFI_NOT_READY;
+		/* Logo key detected */
+		set_shift_mask(0, &key->key_state);
+		break;
+	case 0x1b:
 		/*
 		 * Xterm Control Sequences
 		 * https://www.xfree86.org/4.8.0/ctlseqs.html
@@ -484,19 +507,13 @@ static efi_status_t efi_cin_read_key(struct efi_key_data *key)
 			break;
 		case 'O': /* F1 - F4 */
 			ch = getc();
-			/* skip modifiers */
-			if (ch <= '9')
+			/* consider modifiers */
+			if (ch < 'P') {
+				set_shift_mask(ch - '0', &key->key_state);
 				ch = getc();
+			}
 			pressed_key.scan_code = ch - 'P' + 11;
 			break;
-		case 'a'...'z':
-			/*
-			 * Workaround for entering CTRL+a (0x01) - CTRL+z (0x1a)
-			 * as escape sequence if the terminal does not allow
-			 * direct entry. These are not Xterm control sequences.
-			 */
-			ch = ch - 'a' + 1;
-			break;
 		case '[':
 			ch = getc();
 			switch (ch) {
@@ -555,10 +572,14 @@ static efi_status_t efi_cin_read_key(struct efi_key_data *key)
 				pressed_key.scan_code = 10;
 				analyze_modifiers(&key->key_state);
 				break;
-			}
+			} /* [ */
 			break;
+		default:
+			/* ALT key */
+			set_shift_mask(3, &key->key_state);
 		}
-	} else if (ch == 0x7f) {
+		break;
+	case 0x7f:
 		/* Backspace */
 		ch = 0x08;
 	}
@@ -572,7 +593,7 @@ static efi_status_t efi_cin_read_key(struct efi_key_data *key)
 		 * entered using the control key.
 		 */
 		if (ch >= 0x01 && ch <= 0x1f) {
-			key->key_state.key_shift_state =
+			key->key_state.key_shift_state |=
 					EFI_SHIFT_STATE_VALID;
 			switch (ch) {
 			case 0x01 ... 0x07:
-- 
2.18.0

