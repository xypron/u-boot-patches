From 22ae48c3a105016ea2463b92774d326ed334b166 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 9 Sep 2018 13:15:44 +0200
Subject: [PATCH 1/1] efi_loader: implement key notify functions

Implement registering and unregistreing key notify functions in the
EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_console.c | 101 +++++++++++++++++++++++++++++++++--
 1 file changed, 98 insertions(+), 3 deletions(-)

diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index 6fc02b210f..9c144808be 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -398,8 +398,23 @@ struct efi_simple_text_output_protocol efi_con_out = {
 	.mode = (void*)&efi_con_mode,
 };
 
+/**
+ * struct efi_cin_notify_function - registered console input notify function
+ *
+ * @link:	link to list
+ * @data:	key to notify
+ * @function:	function to call
+ */
+struct efi_cin_notify_function {
+	struct list_head link;
+	struct efi_key_data key;
+	efi_status_t (EFIAPI *function)
+		(struct efi_key_data *key_data);
+};
+
 static bool key_available;
 static struct efi_key_data next_key;
+static LIST_HEAD(cin_notify_functions);
 
 /**
  * analyze_modifiers() - analyze modifiers (shift, alt, ctrl) for function keys
@@ -641,6 +656,34 @@ error:
 	return EFI_NOT_READY;
 }
 
+/**
+ * efi_cin_notify() - notify registered functions
+ */
+static void efi_cin_notify(void)
+{
+	struct efi_cin_notify_function *item;
+
+	list_for_each_entry(item, &cin_notify_functions, link) {
+		bool match = true;
+
+		/* We do not support toggle states */
+		if (item->key.key.unicode_char || item->key.key.scan_code) {
+			if (item->key.key.unicode_char !=
+			    next_key.key.unicode_char ||
+			    item->key.key.scan_code != next_key.key.scan_code)
+			match = false;
+		}
+		if (item->key.key_state.key_shift_state &&
+		    item->key.key_state.key_shift_state !=
+		    next_key.key_state.key_shift_state)
+			match = false;
+
+		if (match)
+			/* We don't bother about the return code */
+			EFI_CALL(item->function(&next_key));
+	}
+}
+
 /**
  * efi_cin_check() - check if keyboard input is available
  */
@@ -658,8 +701,12 @@ static void efi_cin_check(void)
 		if (ret == EFI_SUCCESS) {
 			key_available = true;
 
+			/* Notify registered functions */
+			efi_cin_notify();
+
 			/* Queue the wait for key event */
-			efi_signal_event(efi_con_in.wait_for_key, true);
+			if (key_available)
+				efi_signal_event(efi_con_in.wait_for_key, true);
 		}
 	}
 }
@@ -817,9 +864,35 @@ static efi_status_t EFIAPI efi_cin_register_key_notify(
 			struct efi_key_data *key_data),
 		void **notify_handle)
 {
+	efi_status_t ret = EFI_SUCCESS;
+	struct efi_cin_notify_function *notify_function;
+
 	EFI_ENTRY("%p, %p, %p, %p",
 		  this, key_data, key_notify_function, notify_handle);
-	return EFI_EXIT(EFI_OUT_OF_RESOURCES);
+
+	/* Check parameters */
+	if (!this || !key_data || !key_notify_function || !notify_handle) {
+		ret = EFI_INVALID_PARAMETER;
+		goto out;
+	}
+
+	EFI_PRINT("u+%04x, sc %04x, sh %08x, tg %02x\n",
+		  key_data->key.unicode_char,
+	       key_data->key.scan_code,
+	       key_data->key_state.key_shift_state,
+	       key_data->key_state.key_toggle_state);
+
+	notify_function = calloc(1, sizeof(struct efi_cin_notify_function));
+	if (!notify_function) {
+		ret = EFI_OUT_OF_RESOURCES;
+		goto out;
+	}
+	notify_function->key = *key_data;
+	notify_function->function = key_notify_function;
+	list_add_tail(&notify_function->link, &cin_notify_functions);
+	*notify_handle = notify_function;
+out:
+	return EFI_EXIT(ret);
 }
 
 /**
@@ -839,8 +912,30 @@ static efi_status_t EFIAPI efi_cin_unregister_key_notify(
 		struct efi_simple_text_input_ex_protocol *this,
 		void *notification_handle)
 {
+	efi_status_t ret = EFI_INVALID_PARAMETER;
+	struct efi_cin_notify_function *item, *notify_function =
+			notification_handle;
+
 	EFI_ENTRY("%p, %p", this, notification_handle);
-	return EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	/* Check parameters */
+	if (!this || !notification_handle)
+		goto out;
+
+	list_for_each_entry(item, &cin_notify_functions, link) {
+		if (item == notify_function) {
+			ret = EFI_SUCCESS;
+			break;
+		}
+	}
+	if (ret != EFI_SUCCESS)
+		goto out;
+
+	/* Remove the notify function */
+	list_del(&notify_function->link);
+	free(notify_function);
+out:
+	return EFI_EXIT(ret);
 }
 
 
-- 
2.18.0

