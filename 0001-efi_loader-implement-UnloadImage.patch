From 13de2cd294b11c9fd7c2c09ca0fbe7a75e13360d Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 30 Sep 2018 10:38:17 +0200
Subject: [PATCH 1/1] efi_loader: implement UnloadImage

Correct the implementation of UnloadImage(). Call the unload function here
and actually unload the image.

Unload application images when Exit() is called.

Pass exit_data when Exit() is called.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_api.h                 |   8 +-
 include/efi_loader.h              |  23 +++++
 lib/efi_loader/efi_boottime.c     | 137 +++++++++++++++++++++++++-----
 lib/efi_loader/efi_image_loader.c |   8 +-
 4 files changed, 146 insertions(+), 30 deletions(-)

diff --git a/include/efi_api.h b/include/efi_api.h
index e6566bb358..7110de7ed7 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -116,11 +116,11 @@ struct efi_boot_services {
 			struct efi_device_path *file_path, void *source_buffer,
 			efi_uintn_t source_size, efi_handle_t *image);
 	efi_status_t (EFIAPI *start_image)(efi_handle_t handle,
-					   unsigned long *exitdata_size,
-					   s16 **exitdata);
+					   efi_uintn_t *exitdata_size,
+					   u16 **exitdata);
 	efi_status_t (EFIAPI *exit)(efi_handle_t handle,
 				    efi_status_t exit_status,
-				    unsigned long exitdata_size, s16 *exitdata);
+				    efi_uintn_t exitdata_size, u16 *exitdata);
 	efi_status_t (EFIAPI *unload_image)(efi_handle_t image_handle);
 	efi_status_t (EFIAPI *exit_boot_services)(efi_handle_t, unsigned long);
 
@@ -339,7 +339,7 @@ struct efi_loaded_image {
 	aligned_u64 image_size;
 	unsigned int image_code_type;
 	unsigned int image_data_type;
-	unsigned long unload;
+	efi_status_t (EFIAPI *unload)(efi_handle_t image_handle);
 };
 
 #define DEVICE_PATH_GUID \
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 04899a137b..316d2ed176 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -173,12 +173,25 @@ struct efi_handler {
 	struct list_head open_infos;
 };
 
+/**
+ * enum efi_object_type - type of EFI object
+ *
+ * In UnloadImage we must be able to identify if the handle relates to a
+ * started image.
+ */
+enum efi_object_type {
+	EFI_OBJECT_TYPE_UNDEFINED = 0,
+	EFI_OBJECT_TYPE_LOADED_IMAGE,
+	EFI_OBJECT_TYPE_STARTED_IMAGE,
+};
+
 /**
  * struct efi_object - dereferenced EFI handle
  *
  * @link:	pointers to put the handle into a linked list
  * @protocols:	linked list with the protocol interfaces installed on this
  *		handle
+ * @type:	type of handle
  *
  * UEFI offers a flexible and expandable object model. The objects in the UEFI
  * API are devices, drivers, and loaded images. struct efi_object is our storage
@@ -195,6 +208,7 @@ struct efi_object {
 	struct list_head link;
 	/* The list of protocols */
 	struct list_head protocols;
+	enum efi_object_type type;
 };
 
 /**
@@ -203,17 +217,26 @@ struct efi_object {
  * @header:		EFI object header
  * @reloc_base:		base address for the relocated image
  * @reloc_size:		size of the relocated image
+ * @parent:		parent loaded image
+ * @exit_status:	status code passed to Exit()
+ * @exit_data_size:	pointer to receive exit data size in Exit()
+ * @exit_data:		pointer to receive exit data in Exit()
  * @exit_jmp:		long jump buffer for returning form started image
  * @entry:		entry address of the relocated image
+ * @image_type:		application, bootime driver, or runtime driver
  */
 struct efi_loaded_image_obj {
 	struct efi_object header;
 	void *reloc_base;
 	aligned_u64 reloc_size;
+	efi_handle_t parent;
 	efi_status_t exit_status;
+	efi_uintn_t *exit_data_size;
+	u16 **exit_data;
 	struct jmp_buf_data exit_jmp;
 	EFIAPI efi_status_t (*entry)(efi_handle_t image_handle,
 				     struct efi_system_table *st);
+	u16 image_type;
 };
 
 /**
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index b716498fba..03c7245920 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -6,14 +6,15 @@
  */
 
 #include <common.h>
+#include <bootm.h>
 #include <div64.h>
 #include <efi_loader.h>
 #include <environment.h>
 #include <malloc.h>
-#include <linux/libfdt_env.h>
+#include <pe.h>
 #include <u-boot/crc.h>
-#include <bootm.h>
 #include <watchdog.h>
+#include <linux/libfdt_env.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -23,6 +24,9 @@ static efi_uintn_t efi_tpl = TPL_APPLICATION;
 /* This list contains all the EFI objects our payload has access to */
 LIST_HEAD(efi_obj_list);
 
+/* Handle of the currently executing image */
+efi_handle_t current_image;
+
 /* List of all events */
 LIST_HEAD(efi_events);
 
@@ -1516,6 +1520,7 @@ efi_status_t efi_setup_loaded_image(struct efi_device_path *device_path,
 		free(info);
 		return EFI_OUT_OF_RESOURCES;
 	}
+	obj->header.type = EFI_OBJECT_TYPE_LOADED_IMAGE;
 
 	/* Add internal object to object list */
 	efi_add_handle(&obj->header);
@@ -1698,15 +1703,20 @@ error:
  * Return: status code
  */
 static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
-					   unsigned long *exit_data_size,
-					   s16 **exit_data)
+					   efi_uintn_t *exit_data_size,
+					   u16 **exit_data)
 {
-	struct efi_loaded_image_obj *image_obj =
-		(struct efi_loaded_image_obj *)image_handle;
+	struct efi_loaded_image_obj *image_obj;
 	efi_status_t ret;
 
 	EFI_ENTRY("%p, %p, %p", image_handle, exit_data_size, exit_data);
 
+	/* Check parameters */
+	if (image_handle->type != EFI_OBJECT_TYPE_LOADED_IMAGE)
+		ret = EFI_INVALID_PARAMETER;
+
+	image_obj = (struct efi_loaded_image_obj *)image_handle;
+
 	/* call the image! */
 	if (setjmp(&image_obj->exit_jmp)) {
 		/*
@@ -1733,16 +1743,27 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
 		      __efi_nesting_dec(),
 		      (unsigned long)((uintptr_t)image_obj->exit_status &
 				      ~EFI_ERROR_MASK));
+		current_image = image_obj->parent;
+
+		/* Unload application image */
+		if (image_obj->image_type == IMAGE_SUBSYSTEM_EFI_APPLICATION) {
+			free(image_obj->reloc_base);
+			efi_delete_handle(&image_obj->header);
+		}
 		return EFI_EXIT(image_obj->exit_status);
 	}
 
+	image_obj->parent = current_image;
+	current_image = image_handle;
+	image_obj->header.type = EFI_OBJECT_TYPE_STARTED_IMAGE;
+	image_obj->exit_data_size = exit_data_size;
+	image_obj->exit_data = exit_data;
 	ret = EFI_CALL(image_obj->entry(image_handle, &systab));
 
 	/*
-	 * Usually UEFI applications call Exit() instead of returning.
-	 * But because the world doesn't consist of ponies and unicorns,
-	 * we're happy to emulate that behavior on behalf of a payload
-	 * that forgot.
+	 * UEFI application may call Exit() to pass exit data or simply
+	 * return. As in both cases the same logic is needed call Exit()
+	 * here.
 	 */
 	return EFI_CALL(systab.boottime->exit(image_handle, ret, 0, NULL));
 }
@@ -1763,19 +1784,44 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
  */
 static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 				    efi_status_t exit_status,
-				    unsigned long exit_data_size,
-				    int16_t *exit_data)
+				    efi_uintn_t exit_data_size,
+				    u16 *exit_data)
 {
-	/*
-	 * TODO: We should call the unload procedure of the loaded
-	 *	 image protocol.
-	 */
-	struct efi_loaded_image_obj *image_obj =
-		(struct efi_loaded_image_obj *)image_handle;
+	efi_status_t ret;
+	struct efi_object *efiobj;
+	struct efi_loaded_image_obj *image_obj;
 
-	EFI_ENTRY("%p, %ld, %ld, %p", image_handle, exit_status,
+	EFI_ENTRY("%p, %ld, %zu, %p", image_handle, exit_status,
 		  exit_data_size, exit_data);
 
+	/* Check parameters */
+	if (image_handle != current_image) {
+		ret = EFI_INVALID_PARAMETER;
+		goto out;
+	}
+	efiobj = efi_search_obj(image_handle);
+	if (!efiobj) {
+		ret = EFI_INVALID_PARAMETER;
+		goto out;
+	}
+
+	image_obj = (struct efi_loaded_image_obj *)efiobj;
+	switch (image_obj->header.type) {
+	case EFI_OBJECT_TYPE_STARTED_IMAGE:
+		/* TODO: Check that child images have exited */
+		break;
+	case EFI_OBJECT_TYPE_LOADED_IMAGE:
+		/*  Unload image that was not yet started */
+		free(image_obj->reloc_base);
+		efi_delete_handle(&image_obj->header);
+		ret = EFI_SUCCESS;
+		goto out;
+	default:
+		/* Handle does not refer to loaded image */
+		ret = EFI_INVALID_PARAMETER;
+		goto out;
+	}
+
 	/* Make sure entry/exit counts for EFI world cross-overs match */
 	EFI_EXIT(exit_status);
 
@@ -1786,9 +1832,18 @@ static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 	efi_restore_gd();
 
 	image_obj->exit_status = exit_status;
+	if (image_obj->exit_data) {
+		*image_obj->exit_data = exit_data;
+		if (image_obj->exit_data_size)
+			*image_obj->exit_data_size = exit_data_size;
+	}
+
 	longjmp(&image_obj->exit_jmp, 1);
 
 	panic("EFI application exited");
+
+out:
+	return EFI_EXIT(ret);
 }
 
 /**
@@ -1804,14 +1859,50 @@ static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
  */
 static efi_status_t EFIAPI efi_unload_image(efi_handle_t image_handle)
 {
+	efi_status_t ret = EFI_SUCCESS;
 	struct efi_object *efiobj;
+	struct efi_loaded_image_obj *image_obj;
+	struct efi_handler *handler;
+	struct efi_loaded_image *loaded_image_protocol;
 
 	EFI_ENTRY("%p", image_handle);
-	efiobj = efi_search_obj(image_handle);
-	if (efiobj)
-		list_del(&efiobj->link);
 
-	return EFI_EXIT(EFI_SUCCESS);
+	efiobj = efi_search_obj(image_handle);
+	if (!efiobj) {
+		ret = EFI_INVALID_PARAMETER;
+		goto out;
+	}
+	switch (efiobj->type) {
+	case EFI_OBJECT_TYPE_STARTED_IMAGE:
+		/* Find the loaded image protocol */
+		ret = efi_search_protocol(efiobj, &efi_guid_loaded_image,
+					  &handler);
+		if (ret != EFI_SUCCESS) {
+			ret = EFI_INVALID_PARAMETER;
+			goto out;
+		}
+		loaded_image_protocol = handler->protocol_interface;
+		/* Call the unload function */
+		if (!loaded_image_protocol->unload) {
+			ret = EFI_UNSUPPORTED;
+			goto out;
+		}
+		ret = loaded_image_protocol->unload(image_handle);
+		if (ret != EFI_SUCCESS)
+			goto out;
+		break;
+	case EFI_OBJECT_TYPE_LOADED_IMAGE:
+		break;
+	default:
+		ret = EFI_INVALID_PARAMETER;
+		goto out;
+	}
+	/* Delete the loaded image */
+	image_obj = (struct efi_loaded_image_obj *)efiobj;
+	free(image_obj->reloc_base);
+	efi_delete_handle(&image_obj->header);
+out:
+	return EFI_EXIT(ret);
 }
 
 /**
diff --git a/lib/efi_loader/efi_image_loader.c b/lib/efi_loader/efi_image_loader.c
index 39902152f3..b6ed936a86 100644
--- a/lib/efi_loader/efi_image_loader.c
+++ b/lib/efi_loader/efi_image_loader.c
@@ -198,7 +198,7 @@ static void efi_set_code_and_data_type(
  * piece of memory. On successful load it then returns the entry point for
  * the binary. Otherwise NULL.
  */
-void *efi_load_pe(struct efi_loaded_image_obj *handle, void *efi,
+void *efi_load_pe(struct efi_loaded_image_obj *image_obj, void *efi,
 		  struct efi_loaded_image *loaded_image_info)
 {
 	IMAGE_NT_HEADERS32 *nt;
@@ -256,6 +256,7 @@ void *efi_load_pe(struct efi_loaded_image_obj *handle, void *efi,
 		IMAGE_OPTIONAL_HEADER64 *opt = &nt64->OptionalHeader;
 		image_base = opt->ImageBase;
 		efi_set_code_and_data_type(loaded_image_info, opt->Subsystem);
+		image_obj->image_type = opt->Subsystem;
 		efi_reloc = efi_alloc(virt_size,
 				      loaded_image_info->image_code_type);
 		if (!efi_reloc) {
@@ -271,6 +272,7 @@ void *efi_load_pe(struct efi_loaded_image_obj *handle, void *efi,
 		IMAGE_OPTIONAL_HEADER32 *opt = &nt->OptionalHeader;
 		image_base = opt->ImageBase;
 		efi_set_code_and_data_type(loaded_image_info, opt->Subsystem);
+		image_obj->image_type = opt->Subsystem;
 		efi_reloc = efi_alloc(virt_size,
 				      loaded_image_info->image_code_type);
 		if (!efi_reloc) {
@@ -312,8 +314,8 @@ void *efi_load_pe(struct efi_loaded_image_obj *handle, void *efi,
 	invalidate_icache_all();
 
 	/* Populate the loaded image interface bits */
-	handle->reloc_base = efi_reloc;
-	handle->reloc_size = virt_size;
+	image_obj->reloc_base = efi_reloc;
+	image_obj->reloc_size = virt_size;
 	loaded_image_info->image_base = efi_reloc;
 	loaded_image_info->image_size = virt_size;
 
-- 
2.19.0

