From df3bbfa6397ecd557ef36874637943667e553072 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 30 Dec 2018 17:01:02 +0100
Subject: [PATCH 1/1] efi_loader: bootmgr load options

Provide field descriptions for struct efi_load_option.

The optional data field is passed as load option in the
EFI_LOADED_IMAGE_PROTOCOL. It is used as command line parameters by the
Linux kernel. So we should consider it to be an UTF-16 string.

The description field should have the same name as in the UEFI
specification to avoid confusion.

Let's be consistent the data type used to reference a serialized load
option and use void * in all cases.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h         | 30 +++++++++++++++---------------
 lib/efi_loader/efi_bootmgr.c | 20 ++++++++++----------
 2 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 53f08161ab..b091afbaa7 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -518,29 +518,29 @@ efi_status_t EFIAPI efi_set_variable(u16 *variable_name, efi_guid_t *vendor,
 				     u32 attributes, efi_uintn_t data_size,
 				     void *data);
 
-/*
- * See section 3.1.3 in the v2.7 UEFI spec for more details on
- * the layout of EFI_LOAD_OPTION.  In short it is:
+/**
+ * struct efi_load_option - EFI load option
+ *
+ * This structure holds the components of the  EFI_LOAD_OPTION structure of the
+ * UEFI specification.
  *
- *    typedef struct _EFI_LOAD_OPTION {
- *        UINT32 Attributes;
- *        UINT16 FilePathListLength;
- *        // CHAR16 Description[];   <-- variable length, NULL terminated
- *        // EFI_DEVICE_PATH_PROTOCOL FilePathList[];
- *						 <-- FilePathListLength bytes
- *        // UINT8 OptionalData[];
- *    } EFI_LOAD_OPTION;
+ * @attributes:		bit mask with the attributes of the load option
+ * @file_path_length:	length in bytes of the file paths list
+ * @file_path:		packed array of file paths
+ * @description:	description of the load option
+ * @optional_data:	data passed as LoadOption in the
+ *			EFI_LOADED_IMAGE_PROTOCOL
  */
 struct efi_load_option {
 	u32 attributes;
 	u16 file_path_length;
-	u16 *label;
+	u16 *description;
 	struct efi_device_path *file_path;
-	u8 *optional_data;
+	u16 *optional_data;
 };
 
-void efi_deserialize_load_option(struct efi_load_option *lo, u8 *data);
-unsigned long efi_serialize_load_option(struct efi_load_option *lo, u8 **data);
+void efi_deserialize_load_option(struct efi_load_option *lo, void *data);
+unsigned long efi_serialize_load_option(struct efi_load_option *lo, void **data);
 void *efi_bootmgr_load(struct efi_device_path **device_path,
 		       struct efi_device_path **file_path);
 
diff --git a/lib/efi_loader/efi_bootmgr.c b/lib/efi_loader/efi_bootmgr.c
index a095df3f54..e6680249ec 100644
--- a/lib/efi_loader/efi_bootmgr.c
+++ b/lib/efi_loader/efi_bootmgr.c
@@ -32,7 +32,7 @@ static const struct efi_runtime_services *rs;
 
 
 /* Parse serialized data and transform it into efi_load_option structure */
-void efi_deserialize_load_option(struct efi_load_option *lo, u8 *data)
+void efi_deserialize_load_option(struct efi_load_option *lo, void *data)
 {
 	lo->attributes = get_unaligned_le32(data);
 	data += sizeof(u32);
@@ -41,8 +41,8 @@ void efi_deserialize_load_option(struct efi_load_option *lo, u8 *data)
 	data += sizeof(u16);
 
 	/* FIXME */
-	lo->label = (u16 *)data;
-	data += (u16_strlen(lo->label) + 1) * sizeof(u16);
+	lo->description = (u16 *)data;
+	data += (u16_strlen(lo->description) + 1) * sizeof(u16);
 
 	/* FIXME */
 	lo->file_path = (struct efi_device_path *)data;
@@ -55,21 +55,21 @@ void efi_deserialize_load_option(struct efi_load_option *lo, u8 *data)
  * Serialize efi_load_option structure into byte stream for BootXXXX.
  * Return a size of allocated data.
  */
-unsigned long efi_serialize_load_option(struct efi_load_option *lo, u8 **data)
+unsigned long efi_serialize_load_option(struct efi_load_option *lo, void **data)
 {
 	unsigned long label_len, option_len;
 	unsigned long size;
 	u8 *p;
 
-	label_len = (u16_strlen(lo->label) + 1) * sizeof(u16);
-	option_len = strlen((char *)lo->optional_data);
+	label_len = (u16_strlen(lo->description) + 1) * sizeof(u16);
+	option_len = (u16_strlen(lo->optional_data) + 1) * sizeof(u16);
 
 	/* total size */
 	size = sizeof(lo->attributes);
 	size += sizeof(lo->file_path_length);
 	size += label_len;
 	size += lo->file_path_length;
-	size += option_len + 1;
+	size += option_len;
 	p = malloc(size);
 	if (!p)
 		return 0;
@@ -82,7 +82,7 @@ unsigned long efi_serialize_load_option(struct efi_load_option *lo, u8 **data)
 	memcpy(p, &lo->file_path_length, sizeof(lo->file_path_length));
 	p += sizeof(lo->file_path_length);
 
-	memcpy(p, lo->label, label_len);
+	memcpy(p, lo->description, label_len);
 	p += label_len;
 
 	memcpy(p, lo->file_path, lo->file_path_length);
@@ -148,14 +148,14 @@ static void *try_load_entry(uint16_t n, struct efi_device_path **device_path,
 		efi_status_t ret;
 
 		debug("%s: trying to load \"%ls\" from %pD\n",
-		      __func__, lo.label, lo.file_path);
+		      __func__, lo.description, lo.file_path);
 
 		ret = efi_load_image_from_path(lo.file_path, &image);
 
 		if (ret != EFI_SUCCESS)
 			goto error;
 
-		printf("Booting: %ls\n", lo.label);
+		printf("Booting: %ls\n", lo.description);
 		efi_dp_split_file_path(lo.file_path, device_path, file_path);
 	}
 
-- 
2.19.2

