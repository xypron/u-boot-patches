From 3ac66279d89e805911951c0af4dd57f30ba3fde9 Mon Sep 17 00:00:00 2001
From: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date: Tue, 17 Nov 2020 09:27:59 +0900
Subject: [PATCH] efi_loader: add firmware management protocol for FIT image

In this commit, a very simple firmware management protocol driver
is implemented. It will take a common FIT image firmware in a capsule
file and apply the data using dfu backend storage drivers via
update_fit() interface.

So "dfu_alt_info" variable should be properly set to specify a device
and location to be updated. Please read README.dfu.

Fit image is a common file format for firmware update on U-Boot, and
this protocol works neatly just as a wrapper for one.

Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
---
 include/efi_api.h             |   4 +
 include/efi_loader.h          |   2 +
 lib/efi_loader/Kconfig        |  11 ++
 lib/efi_loader/Makefile       |   1 +
 lib/efi_loader/efi_capsule.c  |  12 +-
 lib/efi_loader/efi_firmware.c | 291 ++++++++++++++++++++++++++++++++++
 6 files changed, 320 insertions(+), 1 deletion(-)
 create mode 100644 lib/efi_loader/efi_firmware.c

diff --git a/include/efi_api.h b/include/efi_api.h
index 966bc6e590..071d0ba866 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -1849,6 +1849,10 @@ struct efi_signature_list {
 	EFI_GUID(0x86c77a67, 0x0b97, 0x4633, 0xa1, 0x87, \
 		 0x49, 0x10, 0x4d, 0x06, 0x85, 0xc7)
 
+#define EFI_FIRMWARE_IMAGE_TYPE_UBOOT_FIT_GUID \
+	EFI_GUID(0xae13ff2d, 0x9ad4, 0x4e25, 0x9a, 0xc8, \
+		 0x6d, 0x80, 0xb3, 0xb2, 0x21, 0x47)
+
 #define IMAGE_ATTRIBUTE_IMAGE_UPDATABLE		0x0000000000000001
 #define IMAGE_ATTRIBUTE_RESET_REQUIRED		0x0000000000000002
 #define IMAGE_ATTRIBUTE_AUTHENTICATION_REQUIRED	0x0000000000000004
diff --git a/include/efi_loader.h b/include/efi_loader.h
index ed5a49b520..d592a0e680 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -816,6 +816,8 @@ void efi_memcpy_runtime(void *dest, const void *src, size_t n);
 /* commonly used helper function */
 u16 *efi_create_indexed_name(u16 *buffer, const char *name, unsigned int index);
 
+extern const struct efi_firmware_management_protocol efi_fmp_fit;
+
 /* Capsule update */
 efi_status_t EFIAPI efi_update_capsule(
 		struct efi_capsule_header **capsule_header_array,
diff --git a/lib/efi_loader/Kconfig b/lib/efi_loader/Kconfig
index ba0392b641..bb0c030cc3 100644
--- a/lib/efi_loader/Kconfig
+++ b/lib/efi_loader/Kconfig
@@ -135,6 +135,17 @@ config EFI_CAPSULE_FIRMWARE_MANAGEMENT
 	  Select this option if you want to enable capsule-based
 	  firmware update using Firmware Management Protocol.
 
+config EFI_CAPSULE_FIRMWARE_FIT
+	bool "FMP driver for FIT image"
+	depends on EFI_CAPSULE_FIRMWARE_MANAGEMENT
+	depends on FIT
+	select UPDATE_FIT
+	select DFU
+	default n
+	help
+	  Select this option if you want to enable firmware management protocol
+	  driver for FIT image
+
 config EFI_DEVICE_PATH_TO_TEXT
 	bool "Device path to text protocol"
 	default y
diff --git a/lib/efi_loader/Makefile b/lib/efi_loader/Makefile
index 056376ff7a..34d02ba7de 100644
--- a/lib/efi_loader/Makefile
+++ b/lib/efi_loader/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_CMD_BOOTEFI_HELLO) += helloworld_efi.o
 obj-y += efi_bootmgr.o
 obj-y += efi_boottime.o
 obj-$(CONFIG_EFI_HAVE_CAPSULE_SUPPORT) += efi_capsule.o
+obj-$(CONFIG_EFI_CAPSULE_FIRMWARE_FIT) += efi_firmware.o
 obj-y += efi_console.o
 obj-y += efi_device_path.o
 obj-$(CONFIG_EFI_DEVICE_PATH_TO_TEXT) += efi_device_path_to_text.o
diff --git a/lib/efi_loader/efi_capsule.c b/lib/efi_loader/efi_capsule.c
index 2f41c17f50..8265aac226 100644
--- a/lib/efi_loader/efi_capsule.c
+++ b/lib/efi_loader/efi_capsule.c
@@ -804,7 +804,17 @@ static void efi_capsule_scan_done(void)
  */
 efi_status_t __weak arch_efi_load_capsule_drivers(void)
 {
-	return EFI_SUCCESS;
+	__maybe_unused efi_handle_t handle;
+	efi_status_t ret = EFI_SUCCESS;
+
+	if (IS_ENABLED(CONFIG_EFI_CAPSULE_FIRMWARE_FIT)) {
+		handle = NULL;
+		ret = EFI_CALL(efi_install_multiple_protocol_interfaces(
+				&handle, &efi_guid_firmware_management_protocol,
+				&efi_fmp_fit, NULL));
+	}
+
+	return ret;
 }
 
 /**
diff --git a/lib/efi_loader/efi_firmware.c b/lib/efi_loader/efi_firmware.c
new file mode 100644
index 0000000000..4c395f4eb5
--- /dev/null
+++ b/lib/efi_loader/efi_firmware.c
@@ -0,0 +1,291 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * EFI Firmware management protocol
+ *
+ *  Copyright (c) 2020 Linaro Limited
+ *			Author: AKASHI Takahiro
+ */
+
+#include <common.h>
+#include <charset.h>
+#include <dfu.h>
+#include <efi_loader.h>
+#include <image.h>
+#include <linux/list.h>
+
+/*
+ * This FIRMWARE_MANAGEMENT_PROTOCOL driver provides a firmware update
+ * method with existing FIT image format, and handles
+ *   - multiple regions of firmware via DFU
+ * but doesn't support
+ *   - versioning of firmware image
+ *   - package information
+ */
+const efi_guid_t efi_firmware_image_type_uboot_fit =
+	EFI_FIRMWARE_IMAGE_TYPE_UBOOT_FIT_GUID;
+
+/**
+ * efi_get_dfu_info - return information about the current firmware image
+ * @this:			Protocol instance
+ * @image_info_size:		Size of @image_info
+ * @image_info:			Image information
+ * @descriptor_version:		Pointer to version number
+ * @descriptor_count:		Pointer to number of descriptors
+ * @descriptor_size:		Pointer to descriptor size
+ * package_version:		Package version
+ * package_version_name:	Package version's name
+ * image_type:			Image type GUID
+ *
+ * Return information bout the current firmware image in @image_info.
+ * @image_info will consist of a number of descriptors.
+ * Each descriptor will be created based on "dfu_alt_info" variable.
+ *
+ * Return		status code
+ */
+static efi_status_t efi_get_dfu_info(
+	efi_uintn_t *image_info_size,
+	struct efi_firmware_image_descriptor *image_info,
+	u32 *descriptor_version,
+	u8 *descriptor_count,
+	efi_uintn_t *descriptor_size,
+	u32 *package_version,
+	u16 **package_version_name,
+	const efi_guid_t *image_type)
+{
+	struct dfu_entity *dfu;
+	size_t names_len, total_size;
+	int dfu_num, i;
+	u16 *name, *next;
+
+	dfu_init_env_entities(NULL, NULL);
+
+	names_len = 0;
+	dfu_num = 0;
+	list_for_each_entry(dfu, &dfu_list, list) {
+		names_len += (utf8_utf16_strlen(dfu->name) + 1) * 2;
+		dfu_num++;
+	}
+	if (!dfu_num) {
+		EFI_PRINT("Probably dfu_alt_info not defined\n");
+		*image_info_size = 0;
+		dfu_free_entities();
+
+		return EFI_SUCCESS;
+	}
+
+	total_size = sizeof(*image_info) * dfu_num + names_len;
+	/*
+	 * we will assume that sizeof(*image_info) * dfu_name
+	 * is, at least, a multiple of 2. So the start address for
+	 * image_id_name would be aligned with 2 bytes.
+	 */
+	if (*image_info_size < total_size) {
+		*image_info_size = total_size;
+		dfu_free_entities();
+
+		return EFI_BUFFER_TOO_SMALL;
+	}
+	*image_info_size = total_size;
+
+	*descriptor_version = EFI_FIRMWARE_IMAGE_DESCRIPTOR_VERSION;
+	*descriptor_count = dfu_num;
+	*descriptor_size = sizeof(*image_info);
+	*package_version = 0xffffffff; /* not supported */
+	*package_version_name = NULL; /* not supported */
+
+	/* DFU alt number should correspond to image_index */
+	i = 0;
+	/* Name area starts just after descriptors */
+	name = (u16 *)((u8 *)image_info + sizeof(*image_info) * dfu_num);
+	next = name;
+	list_for_each_entry(dfu, &dfu_list, list) {
+		image_info[i].image_index = dfu->alt + 1;
+		image_info[i].image_type_id = *image_type;
+		image_info[i].image_id = dfu->alt;
+
+		/* copy the DFU entity name */
+		utf8_utf16_strcpy(&next, dfu->name);
+		image_info[i].image_id_name = name;
+		name = ++next;
+
+		image_info[i].version = 0; /* not supported */
+		image_info[i].version_name = NULL; /* not supported */
+		image_info[i].size = 0;
+		image_info[i].attributes_supported =
+				IMAGE_ATTRIBUTE_IMAGE_UPDATABLE;
+		image_info[i].attributes_setting =
+				IMAGE_ATTRIBUTE_IMAGE_UPDATABLE;
+		image_info[i].lowest_supported_image_version = 0;
+		image_info[i].last_attempt_version = 0;
+		image_info[i].last_attempt_status = LAST_ATTEMPT_STATUS_SUCCESS;
+		image_info[i].hardware_instance = 1;
+		image_info[i].dependencies = NULL;
+
+		i++;
+	}
+
+	dfu_free_entities();
+
+	return EFI_SUCCESS;
+}
+
+/**
+ * efi_firmware_fit_get_image_info - return information about the current
+ *				     firmware image
+ * @this:			Protocol instance
+ * @image_info_size:		Size of @image_info
+ * @image_info:			Image information
+ * @descriptor_version:		Pointer to version number
+ * @descriptor_count:		Pointer to number of descriptors
+ * @descriptor_size:		Pointer to descriptor size
+ * package_version:		Package version
+ * package_version_name:	Package version's name
+ *
+ * Return information bout the current firmware image in @image_info.
+ * @image_info will consist of a number of descriptors.
+ * Each descriptor will be created based on "dfu_alt_info" variable.
+ *
+ * Return		status code
+ */
+static
+efi_status_t EFIAPI efi_firmware_fit_get_image_info(
+	struct efi_firmware_management_protocol *this,
+	efi_uintn_t *image_info_size,
+	struct efi_firmware_image_descriptor *image_info,
+	u32 *descriptor_version,
+	u8 *descriptor_count,
+	efi_uintn_t *descriptor_size,
+	u32 *package_version,
+	u16 **package_version_name)
+{
+	efi_status_t ret;
+
+	EFI_ENTRY("%p %p %p %p %p %p %p %p\n", this,
+		  image_info_size, image_info,
+		  descriptor_version, descriptor_count, descriptor_size,
+		  package_version, package_version_name);
+
+	if (!image_info_size)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	if (*image_info_size &&
+	    (!image_info || !descriptor_version || !descriptor_count ||
+	     !descriptor_size || !package_version || !package_version_name))
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	ret = efi_get_dfu_info(image_info_size, image_info,
+			       descriptor_version, descriptor_count,
+			       descriptor_size,
+			       package_version, package_version_name,
+			       &efi_firmware_image_type_uboot_fit);
+
+	return EFI_EXIT(ret);
+}
+
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_get_image_unsupported(
+	struct efi_firmware_management_protocol *this,
+	u8 image_index,
+	void *image,
+	efi_uintn_t *image_size)
+{
+	EFI_ENTRY("%p %d %p %p\n", this, image_index, image, image_size);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
+
+/**
+ * efi_firmware_fit_set_image - update the firmware image
+ * @this:		Protocol instance
+ * @image_index:	Image index number
+ * @image:		New image
+ * @image_size:		Size of new image
+ * @vendor_code:	Vendor-specific update policy
+ * @progress:		Function to report the progress of update
+ * @abort_reason:	Pointer to string of abort reason
+ *
+ * Update the firmware to new image, using dfu. The new image should
+ * have FIT image format commonly used in U-Boot.
+ * @vendor_code, @progress and @abort_reason are not supported.
+ *
+ * Return:		status code
+ */
+static
+efi_status_t EFIAPI efi_firmware_fit_set_image(
+	struct efi_firmware_management_protocol *this,
+	u8 image_index,
+	const void *image,
+	efi_uintn_t image_size,
+	const void *vendor_code,
+	efi_status_t (*progress)(efi_uintn_t completion),
+	u16 **abort_reason)
+{
+	EFI_ENTRY("%p %d %p %ld %p %p %p\n", this, image_index, image,
+		  image_size, vendor_code, progress, abort_reason);
+
+	if (!image || image_index != 1)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+
+	if (fit_update(image))
+		return EFI_EXIT(EFI_DEVICE_ERROR);
+
+	return EFI_EXIT(EFI_SUCCESS);
+}
+
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_check_image_unsupported(
+	struct efi_firmware_management_protocol *this,
+	u8 image_index,
+	const void *image,
+	efi_uintn_t *image_size,
+	u32 *image_updatable)
+{
+	EFI_ENTRY("%p %d %p %p %p\n", this, image_index, image, image_size,
+		  image_updatable);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
+
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_get_package_info_unsupported(
+	struct efi_firmware_management_protocol *this,
+	u32 *package_version,
+	u16 **package_version_name,
+	u32 *package_version_name_maxlen,
+	u64 *attributes_supported,
+	u64 *attributes_setting)
+{
+	EFI_ENTRY("%p %p %p %p %p %p\n", this, package_version,
+		  package_version_name, package_version_name_maxlen,
+		  attributes_supported, attributes_setting);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
+
+/* Place holder; not supported */
+static
+efi_status_t EFIAPI efi_firmware_set_package_info_unsupported(
+	struct efi_firmware_management_protocol *this,
+	const void *image,
+	efi_uintn_t *image_size,
+	const void *vendor_code,
+	u32 package_version,
+	const u16 *package_version_name)
+{
+	EFI_ENTRY("%p %p %p %p %x %p\n", this, image, image_size, vendor_code,
+		  package_version, package_version_name);
+
+	return EFI_EXIT(EFI_UNSUPPORTED);
+}
+
+const struct efi_firmware_management_protocol efi_fmp_fit = {
+	.get_image_info = efi_firmware_fit_get_image_info,
+	.get_image = efi_firmware_get_image_unsupported,
+	.set_image = efi_firmware_fit_set_image,
+	.check_image = efi_firmware_check_image_unsupported,
+	.get_package_info = efi_firmware_get_package_info_unsupported,
+	.set_package_info = efi_firmware_set_package_info_unsupported,
+};
-- 
2.29.2

